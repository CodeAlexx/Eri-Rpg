{"file_path": "verification.py", "content": "\"\"\"\nVerification system for EriRPG.\n\nExecutes verification commands (lint, test, etc.) and collects results\nto gate runner progress and ensure code quality.\n\nUsage:\n    verifier = Verifier(config)\n    result = verifier.run_step_verification(step)\n    if not result.passed:\n        print(f\"Verification failed: {result.output}\")\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, TYPE_CHECKING\nimport json\nimport os\nimport subprocess\nimport shlex\n\nif TYPE_CHECKING:\n    from erirpg.graph import Graph\n\n\nclass VerificationStatus(Enum):\n    \"\"\"Status of a verification run.\"\"\"\n    PENDING = \"pending\"\n    PASSED = \"passed\"\n    FAILED = \"failed\"\n    SKIPPED = \"skipped\"\n    ERROR = \"error\"\n\n\n@dataclass\nclass VerificationCommand:\n    \"\"\"A single verification command to run.\"\"\"\n    name: str\n    command: str\n    working_dir: str = \"\"\n    timeout: int = 300  # 5 minutes default\n    required: bool = True  # If false, failure doesn't block progress\n    run_on: List[str] = field(default_factory=list)  # Step types to run on, empty = all\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"command\": self.command,\n            \"working_dir\": self.working_dir,\n            \"timeout\": self.timeout,\n            \"required\": self.required,\n            \"run_on\": self.run_on,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"VerificationCommand\":\n        \"\"\"Deserialize from dictionary.\"\"\"\n        return cls(\n            name=data.get(\"name\", \"\"),\n            command=data.get(\"command\", \"\"),\n            working_dir=data.get(\"working_dir\", \"\"),\n            timeout=data.get(\"timeout\", 300),\n            required=data.get(\"required\", True),\n            run_on=data.get(\"run_on\", []),\n        )\n\n\n@dataclass\nclass CommandResult:\n    \"\"\"Result of running a single verification command.\"\"\"\n    name: str\n    command: str\n    status: str = \"pending\"  # VerificationStatus value\n    exit_code: int = 0\n    stdout: str = \"\"\n    stderr: str = \"\"\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    error_message: str = \"\"\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"command\": self.command,\n            \"status\": self.status,\n            \"exit_code\": self.exit_code,\n            \"stdout\": self.stdout,\n            \"stderr\": self.stderr,\n            \"started_at\": self.started_at.isoformat() if self.started_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"error_message\": self.error_message,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"CommandResult\":\n        \"\"\"Deserialize from dictionary.\"\"\"\n        return cls(\n            name=data.get(\"name\", \"\"),\n            command=data.get(\"command\", \"\"),\n            status=data.get(\"status\", \"pending\"),\n            exit_code=data.get(\"exit_code\", 0),\n            stdout=data.get(\"stdout\", \"\"),\n            stderr=data.get(\"stderr\", \"\"),\n            started_at=datetime.fromisoformat(data[\"started_at\"]) if data.get(\"started_at\") else None,\n            completed_at=datetime.fromisoformat(data[\"completed_at\"]) if data.get(\"completed_at\") else None,\n            error_message=data.get(\"error_message\", \"\"),\n        )\n\n    @property\n    def passed(self) -> bool:\n        \"\"\"Check if command passed.\"\"\"\n        return self.status == VerificationStatus.PASSED.value\n\n    @property\n    def duration(self) -> Optional[float]:\n        \"\"\"Get command duration in seconds.\"\"\"\n        if self.started_at and self.completed_at:\n            return (self.completed_at - self.started_at).total_seconds()\n        return None\n\n\n@dataclass\nclass VerificationResult:\n    \"\"\"Result of running all verification commands for a step.\"\"\"\n    step_id: str\n    status: str = \"pending\"  # VerificationStatus value\n    command_results: List[CommandResult] = field(default_factory=list)\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dictionary.\"\"\"\n        return {\n            \"step_id\": self.step_id,\n            \"status\": self.status,\n            \"command_results\": [r.to_dict() for r in self.command_results],\n            \"started_at\": self.started_at.isoformat() if self.started_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"VerificationResult\":\n        \"\"\"Deserialize from dictionary.\"\"\"\n        return cls(\n            step_id=data.get(\"step_id\", \"\"),\n            status=data.get(\"status\", \"pending\"),\n            command_results=[CommandResult.from_dict(r) for r in data.get(\"command_results\", [])],\n            started_at=datetime.fromisoformat(data[\"started_at\"]) if data.get(\"started_at\") else None,\n            completed_at=datetime.fromisoformat(data[\"completed_at\"]) if data.get(\"completed_at\") else None,\n        )\n\n    @property\n    def passed(self) -> bool:\n        \"\"\"Check if all required commands passed.\"\"\"\n        return self.status == VerificationStatus.PASSED.value\n\n    @property\n    def failed_commands(self) -> List[CommandResult]:\n        \"\"\"Get list of failed command results.\"\"\"\n        return [r for r in self.command_results if r.status == VerificationStatus.FAILED.value]\n\n    def format_report(self) -> str:\n        \"\"\"Format a human-readable report.\"\"\"\n        lines = [\n            f\"Verification Report: {self.step_id}\",\n            \"=\" * 50,\n            f\"Status: {self.status}\",\n        ]\n\n        if self.started_at:\n            lines.append(f\"Started: {self.started_at.strftime('%Y-%m-%d %H:%M:%S')}\")\n        if self.completed_at:\n            lines.append(f\"Completed: {self.completed_at.strftime('%Y-%m-%d %H:%M:%S')}\")\n\n        lines.append(\"\")\n        lines.append(\"Commands:\")\n\n        for result in self.command_results:\n            status_icon = {\n                \"passed\": \"\u2713\",\n                \"failed\": \"\u2717\",\n                \"skipped\": \"\u25cb\",\n                \"error\": \"!\",\n                \"pending\": \"?\",\n            }.get(result.status, \"?\")\n\n            lines.append(f\"  {status_icon} {result.name}\")\n            lines.append(f\"    Command: {result.command}\")\n            lines.append(f\"    Exit code: {result.exit_code}\")\n\n            if result.duration:\n                lines.append(f\"    Duration: {result.duration:.2f}s\")\n\n            if result.error_message:\n                lines.append(f\"    Error: {result.error_message}\")\n\n            if result.stdout.strip():\n                lines.append(\"    Output:\")\n                for line in result.stdout.strip().split(\"\\n\")[:10]:  # First 10 lines\n                    lines.append(f\"      {line}\")\n                if len(result.stdout.strip().split(\"\\n\")) > 10:\n                    lines.append(\"      ... (truncated)\")\n\n            if result.stderr.strip():\n                lines.append(\"    Errors:\")\n                for line in result.stderr.strip().split(\"\\n\")[:10]:\n                    lines.append(f\"      {line}\")\n                if len(result.stderr.strip().split(\"\\n\")) > 10:\n                    lines.append(\"      ... (truncated)\")\n\n        return \"\\n\".join(lines)\n\n\n@dataclass\nclass VerificationConfig:\n    \"\"\"Configuration for verification commands.\"\"\"\n    commands: List[VerificationCommand] = field(default_factory=list)\n    run_after_each_step: bool = False\n    run_at_checkpoints: bool = True\n    stop_on_failure: bool = True\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dictionary.\"\"\"\n        return {\n            \"commands\": [c.to_dict() for c in self.commands],\n            \"run_after_each_step\": self.run_after_each_step,\n            \"run_at_checkpoints\": self.run_at_checkpoints,\n            \"stop_on_failure\": self.stop_on_failure,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"VerificationConfig\":\n        \"\"\"Deserialize from dictionary.\"\"\"\n        return cls(\n            commands=[VerificationCommand.from_dict(c) for c in data.get(\"commands\", [])],\n            run_after_each_step=data.get(\"run_after_each_step\", False),\n            run_at_checkpoints=data.get(\"run_at_checkpoints\", True),\n            stop_on_failure=data.get(\"stop_on_failure\", True),\n        )\n\n    def validate(self) -> List[str]:\n        \"\"\"Validate the configuration.\"\"\"\n        errors = []\n        for i, cmd in enumerate(self.commands):\n            if not cmd.name:\n                errors.append(f\"Command {i}: name is required\")\n            if not cmd.command:\n                errors.append(f\"Command {i}: command is required\")\n            if cmd.timeout <= 0:\n                errors.append(f\"Command {i}: timeout must be positive\")\n        return errors\n\n    def get_commands_for_step(self, step_type: str) -> List[VerificationCommand]:\n        \"\"\"Get commands that should run for a given step type.\"\"\"\n        return [\n            cmd for cmd in self.commands\n            if not cmd.run_on or step_type in cmd.run_on\n        ]\n\n\nclass Verifier:\n    \"\"\"Executes verification commands.\"\"\"\n\n    def __init__(self, config: VerificationConfig, project_path: str):\n        self.config = config\n        self.project_path = project_path\n\n    def run_command(self, cmd: VerificationCommand) -> CommandResult:\n        \"\"\"Run a single verification command.\"\"\"\n        result = CommandResult(\n            name=cmd.name,\n            command=cmd.command,\n            started_at=datetime.now(),\n        )\n\n        # Determine working directory\n        working_dir = cmd.working_dir or self.project_path\n        if not os.path.isabs(working_dir):\n            working_dir = os.path.join(self.project_path, working_dir)\n\n        try:\n            # Run the command\n            process = subprocess.run(\n                cmd.command,\n                shell=True,\n                cwd=working_dir,\n                capture_output=True,\n                text=True,\n                timeout=cmd.timeout,\n            )\n\n            result.exit_code = process.returncode\n            result.stdout = process.stdout\n            result.stderr = process.stderr\n            result.completed_at = datetime.now()\n\n            if process.returncode == 0:\n                result.status = VerificationStatus.PASSED.value\n            else:\n                result.status = VerificationStatus.FAILED.value\n\n        except subprocess.TimeoutExpired:\n            result.status = VerificationStatus.ERROR.value\n            result.error_message = f\"Command timed out after {cmd.timeout} seconds\"\n            result.completed_at = datetime.now()\n\n        except Exception as e:\n            result.status = VerificationStatus.ERROR.value\n            result.error_message = str(e)\n            result.completed_at = datetime.now()\n\n        return result\n\n    def run_verification(\n        self,\n        step_id: str,\n        step_type: str = \"\",\n    ) -> VerificationResult:\n        \"\"\"Run all applicable verification commands for a step.\n\n        Args:\n            step_id: ID of the step being verified\n            step_type: Type of step (used to filter commands)\n\n        Returns:\n            VerificationResult with all command results\n        \"\"\"\n        result = VerificationResult(\n            step_id=step_id,\n            started_at=datetime.now(),\n        )\n\n        # Get applicable commands\n        commands = self.config.get_commands_for_step(step_type) if step_type else self.config.commands\n\n        if not commands:\n            result.status = VerificationStatus.SKIPPED.value\n            result.completed_at = datetime.now()\n            return result\n\n        # Run each command\n        all_passed = True\n        for cmd in commands:\n            cmd_result = self.run_command(cmd)\n            result.command_results.append(cmd_result)\n\n            # Check if this failure should stop progress\n            if not cmd_result.passed and cmd.required:\n                all_passed = False\n                if self.config.stop_on_failure:\n                    break\n\n        result.completed_at = datetime.now()\n        result.status = VerificationStatus.PASSED.value if all_passed else VerificationStatus.FAILED.value\n\n        return result\n\n    def should_run_for_step(self, is_checkpoint: bool = False) -> bool:\n        \"\"\"Determine if verification should run based on config.\"\"\"\n        if self.config.run_after_each_step:\n            return True\n        if is_checkpoint and self.config.run_at_checkpoints:\n            return True\n        return False\n\n\n# =============================================================================\n# Verification Storage\n# =============================================================================\n\ndef save_verification_result(\n    project_path: str,\n    run_id: str,\n    result: VerificationResult,\n) -> str:\n    \"\"\"Save verification result to run directory.\n\n    Args:\n        project_path: Path to the project\n        run_id: ID of the run\n        result: VerificationResult to save\n\n    Returns:\n        Path to the saved file\n    \"\"\"\n    from erirpg.runs import get_run_dir\n\n    verification_dir = os.path.join(get_run_dir(project_path, run_id), \"verification\")\n    os.makedirs(verification_dir, exist_ok=True)\n\n    file_path = os.path.join(verification_dir, f\"{result.step_id}.json\")\n    with open(file_path, \"w\") as f:\n        json.dump(result.to_dict(), f, indent=2)\n\n    return file_path\n\n\ndef load_verification_result(\n    project_path: str,\n    run_id: str,\n    step_id: str,\n) -> Optional[VerificationResult]:\n    \"\"\"Load verification result from run directory.\n\n    Args:\n        project_path: Path to the project\n        run_id: ID of the run\n        step_id: ID of the step\n\n    Returns:\n        VerificationResult or None if not found\n    \"\"\"\n    from erirpg.runs import get_run_dir\n\n    file_path = os.path.join(\n        get_run_dir(project_path, run_id),\n        \"verification\",\n        f\"{step_id}.json\"\n    )\n\n    if not os.path.exists(file_path):\n        return None\n\n    with open(file_path, \"r\") as f:\n        data = json.load(f)\n\n    return VerificationResult.from_dict(data)\n\n\ndef list_verification_results(\n    project_path: str,\n    run_id: str,\n) -> List[VerificationResult]:\n    \"\"\"List all verification results for a run.\n\n    Args:\n        project_path: Path to the project\n        run_id: ID of the run\n\n    Returns:\n        List of VerificationResults\n    \"\"\"\n    from erirpg.runs import get_run_dir\n\n    verification_dir = os.path.join(get_run_dir(project_path, run_id), \"verification\")\n\n    if not os.path.exists(verification_dir):\n        return []\n\n    results = []\n    for filename in os.listdir(verification_dir):\n        if filename.endswith(\".json\"):\n            step_id = filename[:-5]  # Remove .json\n            result = load_verification_result(project_path, run_id, step_id)\n            if result:\n                results.append(result)\n\n    return results\n\n\ndef format_verification_summary(results: List[VerificationResult]) -> str:\n    \"\"\"Format a summary of all verification results.\n\n    Args:\n        results: List of verification results\n\n    Returns:\n        Formatted summary string\n    \"\"\"\n    if not results:\n        return \"No verification results.\"\n\n    passed = sum(1 for r in results if r.passed)\n    failed = sum(1 for r in results if r.status == VerificationStatus.FAILED.value)\n    skipped = sum(1 for r in results if r.status == VerificationStatus.SKIPPED.value)\n\n    lines = [\n        \"Verification Summary\",\n        \"=\" * 40,\n        f\"Total: {len(results)}\",\n        f\"Passed: {passed}\",\n        f\"Failed: {failed}\",\n        f\"Skipped: {skipped}\",\n        \"\",\n    ]\n\n    if failed > 0:\n        lines.append(\"Failed Steps:\")\n        for result in results:\n            if result.status == VerificationStatus.FAILED.value:\n                lines.append(f\"  \u2022 {result.step_id}\")\n                for cmd_result in result.failed_commands:\n                    lines.append(f\"    - {cmd_result.name}: {cmd_result.error_message or 'exit code ' + str(cmd_result.exit_code)}\")\n\n    return \"\\n\".join(lines)\n\n\n# =============================================================================\n# Config Loading\n# =============================================================================\n\ndef load_verification_config(project_path: str) -> Optional[VerificationConfig]:\n    \"\"\"Load verification config from project.\n\n    Looks for .eri-rpg/verification.json or verification section in project config.\n\n    Args:\n        project_path: Path to the project\n\n    Returns:\n        VerificationConfig or None if not found\n    \"\"\"\n    # Try dedicated verification config\n    config_path = os.path.join(project_path, \".eri-rpg\", \"verification.json\")\n    if os.path.exists(config_path):\n        with open(config_path, \"r\") as f:\n            data = json.load(f)\n        return VerificationConfig.from_dict(data)\n\n    # Try project config\n    project_config_path = os.path.join(project_path, \".eri-rpg\", \"config.json\")\n    if os.path.exists(project_config_path):\n        with open(project_config_path, \"r\") as f:\n            project_data = json.load(f)\n        if \"verification\" in project_data:\n            return VerificationConfig.from_dict(project_data[\"verification\"])\n\n    return None\n\n\ndef save_verification_config(project_path: str, config: VerificationConfig) -> str:\n    \"\"\"Save verification config to project.\n\n    Args:\n        project_path: Path to the project\n        config: VerificationConfig to save\n\n    Returns:\n        Path to the saved file\n    \"\"\"\n    config_dir = os.path.join(project_path, \".eri-rpg\")\n    os.makedirs(config_dir, exist_ok=True)\n\n    config_path = os.path.join(config_dir, \"verification.json\")\n    with open(config_path, \"w\") as f:\n        json.dump(config.to_dict(), f, indent=2)\n\n    return config_path\n\n\n# =============================================================================\n# Default Configurations\n# =============================================================================\n\ndef get_default_python_config() -> VerificationConfig:\n    \"\"\"Get default verification config for Python projects.\"\"\"\n    return VerificationConfig(\n        commands=[\n            VerificationCommand(\n                name=\"lint\",\n                command=\"ruff check .\",\n                required=False,\n            ),\n            VerificationCommand(\n                name=\"type-check\",\n                command=\"mypy .\",\n                required=False,\n            ),\n            VerificationCommand(\n                name=\"test\",\n                command=\"pytest\",\n                required=True,\n            ),\n        ],\n        run_after_each_step=False,\n        run_at_checkpoints=True,\n        stop_on_failure=True,\n    )\n\n\ndef get_default_node_config() -> VerificationConfig:\n    \"\"\"Get default verification config for Node.js projects.\"\"\"\n    return VerificationConfig(\n        commands=[\n            VerificationCommand(\n                name=\"lint\",\n                command=\"npm run lint\",\n                required=False,\n            ),\n            VerificationCommand(\n                name=\"type-check\",\n                command=\"npm run typecheck\",\n                required=False,\n            ),\n            VerificationCommand(\n                name=\"test\",\n                command=\"npm test\",\n                required=True,\n            ),\n        ],\n        run_after_each_step=False,\n        run_at_checkpoints=True,\n        stop_on_failure=True,\n    )\n\n\n# =============================================================================\n# Contract Validation\n# =============================================================================\n\n@dataclass\nclass BreakingChange:\n    \"\"\"A breaking change in an interface signature.\"\"\"\n    module: str\n    interface_name: str\n    before_signature: str\n    after_signature: str\n    change_type: str = \"\"  # \"removed\", \"modified\", \"params_changed\"\n    details: str = \"\"\n\n    def format(self) -> str:\n        \"\"\"Format for display.\"\"\"\n        return (\n            f\"  \u2717 {self.module}::{self.interface_name}\\n\"\n            f\"    Before: {self.before_signature}\\n\"\n            f\"    After:  {self.after_signature}\\n\"\n            f\"    Type:   {self.change_type}\"\n        )\n\n\ndef signatures_compatible(before: str, after: str) -> bool:\n    \"\"\"\n    Check if two signatures are compatible.\n\n    Compatible means:\n    - Same function/method name\n    - Same required parameters (can add optional ones)\n    - Same return type (if typed)\n\n    This is a simplified check - real compatibility depends on language.\n    \"\"\"\n    if not before or not after:\n        return True  # Can't compare empty signatures\n\n    # Exact match is always compatible\n    if before == after:\n        return True\n\n    # Extract function name (everything before first '(')\n    before_name = before.split('(')[0].strip() if '(' in before else before\n    after_name = after.split('(')[0].strip() if '(' in after else after\n\n    if before_name != after_name:\n        return False  # Name changed = breaking\n\n    # Extract parameters\n    def extract_params(sig: str) -> List[str]:\n        if '(' not in sig or ')' not in sig:\n            return []\n        params_str = sig[sig.find('(')+1:sig.rfind(')')]\n        if not params_str.strip():\n            return []\n        # Split by comma, but be careful of nested structures\n        params = []\n        depth = 0\n        current = \"\"\n        for char in params_str:\n            if char in '([{':\n                depth += 1\n            elif char in ')]}':\n                depth -= 1\n            elif char == ',' and depth == 0:\n                params.append(current.strip())\n                current = \"\"\n                continue\n            current += char\n        if current.strip():\n            params.append(current.strip())\n        return params\n\n    before_params = extract_params(before)\n    after_params = extract_params(after)\n\n    # Check required params (those without defaults)\n    def is_required(param: str) -> bool:\n        # Has no default value\n        return '=' not in param and '*' not in param\n\n    before_required = [p for p in before_params if is_required(p)]\n    after_required = [p for p in after_params if is_required(p)]\n\n    # All before required params must still exist\n    # (simplified: just check count - real check would compare names/types)\n    if len(after_required) > len(before_required):\n        return False  # Added required params = breaking\n\n    return True\n\n\ndef validate_interface_contracts(\n    before_graph: \"Graph\",\n    after_graph: \"Graph\",\n) -> List[BreakingChange]:\n    \"\"\"\n    Detect if any interface signatures changed incompatibly.\n\n    Compares interfaces between two versions of a graph to find\n    breaking changes that could affect dependent code.\n\n    Args:\n        before_graph: Graph before changes\n        after_graph: Graph after changes\n\n    Returns:\n        List of BreakingChange objects for incompatible changes\n    \"\"\"\n    from erirpg.graph import Graph\n\n    breaking = []\n\n    for module_path, before_module in before_graph.modules.items():\n        if module_path not in after_graph.modules:\n            # Module removed entirely - check if it had public interfaces\n            for iface in before_module.interfaces:\n                breaking.append(BreakingChange(\n                    module=module_path,\n                    interface_name=iface.name,\n                    before_signature=iface.signature,\n                    after_signature=\"<removed>\",\n                    change_type=\"removed\",\n                    details=\"Module was removed\",\n                ))\n            continue\n\n        after_module = after_graph.modules[module_path]\n\n        # Build lookup for after interfaces\n        after_interfaces = {i.name: i for i in after_module.interfaces}\n\n        for before_iface in before_module.interfaces:\n            if before_iface.name not in after_interfaces:\n                # Interface removed\n                breaking.append(BreakingChange(\n                    module=module_path,\n                    interface_name=before_iface.name,\n                    before_signature=before_iface.signature,\n                    after_signature=\"<removed>\",\n                    change_type=\"removed\",\n                    details=\"Interface was removed\",\n                ))\n                continue\n\n            after_iface = after_interfaces[before_iface.name]\n\n            # Check signature compatibility\n            if not signatures_compatible(before_iface.signature, after_iface.signature):\n                # Determine change type\n                change_type = \"modified\"\n                if \"(\" in before_iface.signature and \"(\" in after_iface.signature:\n                    change_type = \"params_changed\"\n\n                breaking.append(BreakingChange(\n                    module=module_path,\n                    interface_name=before_iface.name,\n                    before_signature=before_iface.signature,\n                    after_signature=after_iface.signature,\n                    change_type=change_type,\n                ))\n\n    return breaking\n\n\ndef format_breaking_changes(changes: List[BreakingChange]) -> str:\n    \"\"\"Format breaking changes for display.\"\"\"\n    if not changes:\n        return \"\u2713 No breaking changes detected\"\n\n    lines = [\n        f\"{'\u2550' * 50}\",\n        f\" \u26a0\ufe0f  BREAKING CHANGES DETECTED ({len(changes)})\",\n        f\"{'\u2550' * 50}\",\n    ]\n\n    for change in changes:\n        lines.append(change.format())\n        lines.append(\"\")\n\n    lines.append(\"These changes may break dependent code.\")\n    lines.append(\"Review impact zone before proceeding.\")\n\n    return \"\\n\".join(lines)\n", "timestamp": "2026-01-26T19:40:25.450764"}