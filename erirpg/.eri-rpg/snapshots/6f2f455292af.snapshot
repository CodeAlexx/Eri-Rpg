{"file_path": "hooks/pretooluse.py", "content": "#!/usr/bin/env python3\n\"\"\"\nEriRPG PreToolUse Hook - HARD ENFORCEMENT\n\nThis hook is called by Claude Code BEFORE any Edit/Write tool executes.\nIt checks if there's an active EriRPG run with preflight completed.\n\nIf not: BLOCKS the operation.\nIf yes: Allows but only for preflighted files.\n\nTo install, add to ~/.claude/settings.json:\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Edit|Write|MultiEdit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 -m erirpg.hooks.pretooluse\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n\nOr with explicit path (set ERIRPG_ROOT env var):\n  \"command\": \"ERIRPG_ROOT=/path/to/eri-rpg python3 ${ERIRPG_ROOT}/erirpg/hooks/pretooluse.py\"\n\"\"\"\n\nimport json\nimport os\nimport sys\nimport traceback\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Portable path resolution - use Path(__file__).parent\nHOOK_DIR = Path(__file__).parent.resolve()\nERIRPG_ROOT = os.environ.get('ERIRPG_ROOT', str(HOOK_DIR.parent.parent))\nLOG_FILE = \"/tmp/erirpg-hook.log\"\n\n\ndef log(msg: str):\n    \"\"\"Log to file for debugging.\"\"\"\n    try:\n        with open(LOG_FILE, \"a\") as f:\n            f.write(f\"[{datetime.now().isoformat()}] {msg}\\n\")\n    except Exception:\n        pass  # Can't log, ignore\n\n\ndef get_active_run_state(project_path: str) -> dict:\n    \"\"\"Check for active EriRPG run in project.\"\"\"\n    run_dir = Path(project_path) / \".eri-rpg\" / \"runs\"\n    if not run_dir.exists():\n        return None\n\n    # Find most recent run\n    runs = list(run_dir.glob(\"*.json\"))\n    if not runs:\n        return None\n\n    # Get latest by mtime\n    latest = max(runs, key=lambda p: p.stat().st_mtime)\n\n    try:\n        with open(latest) as f:\n            run_state = json.load(f)\n\n        # Check if run is still in progress\n        if run_state.get(\"completed_at\") is None:\n            return run_state\n    except Exception:\n        pass\n\n    return None\n\n\ndef get_preflight_state(project_path: str) -> dict:\n    \"\"\"Check for active preflight state.\"\"\"\n    preflight_file = Path(project_path) / \".eri-rpg\" / \"preflight_state.json\"\n    if not preflight_file.exists():\n        return None\n\n    try:\n        with open(preflight_file) as f:\n            return json.load(f)\n    except Exception:\n        return None\n\n\ndef get_quick_fix_state(project_path: str) -> dict:\n    \"\"\"Check for active quick fix state.\"\"\"\n    quick_fix_file = Path(project_path) / \".eri-rpg\" / \"quick_fix_state.json\"\n    if not quick_fix_file.exists():\n        return None\n\n    try:\n        with open(quick_fix_file) as f:\n            return json.load(f)\n    except Exception:\n        return None\n\n\ndef main():\n    \"\"\"Main hook entry point.\"\"\"\n    log(\"=\" * 50)\n    log(\"HOOK INVOKED\")\n    try:\n        # Read input from Claude Code\n        raw_input = sys.stdin.read()\n        log(f\"Raw stdin: {raw_input[:500]}\")\n        input_data = json.loads(raw_input)\n        log(f\"Parsed input keys: {list(input_data.keys())}\")\n\n        tool_name = input_data.get(\"tool_name\", \"\")\n        tool_input = input_data.get(\"tool_input\", {})\n        cwd = input_data.get(\"cwd\", os.getcwd())\n        log(f\"tool_name={tool_name}, cwd={cwd}\")\n\n        # Only check Edit/Write/MultiEdit\n        if tool_name not in [\"Edit\", \"Write\", \"MultiEdit\"]:\n            # Allow other tools\n            log(f\"Tool {tool_name} not in watch list, allowing\")\n            print(json.dumps({}))\n            sys.exit(0)\n\n        # Get file path from tool input\n        file_path = tool_input.get(\"file_path\", \"\")\n        log(f\"file_path from input: {file_path}\")\n        if not file_path:\n            # No file path, allow (will fail anyway)\n            print(json.dumps({}))\n            sys.exit(0)\n\n        # Resolve to absolute path\n        if not os.path.isabs(file_path):\n            file_path = os.path.join(cwd, file_path)\n        file_path = os.path.abspath(file_path)\n\n        # Always allow writes to .eri-rpg directory\n        if \"/.eri-rpg/\" in file_path or file_path.endswith(\"/.eri-rpg\"):\n            print(json.dumps({}))\n            sys.exit(0)\n\n        # Always allow temp files\n        if file_path.startswith(\"/tmp/\") or file_path.startswith(\"/var/tmp/\"):\n            print(json.dumps({}))\n            sys.exit(0)\n\n        # Find project root (look for .eri-rpg directory)\n        project_path = cwd\n        check_path = Path(file_path).parent\n        log(f\"Looking for .eri-rpg starting from: {check_path}\")\n        while check_path != check_path.parent:\n            if (check_path / \".eri-rpg\").exists():\n                project_path = str(check_path)\n                log(f\"Found .eri-rpg at: {project_path}\")\n                break\n            check_path = check_path.parent\n        else:\n            log(f\"No .eri-rpg found, using cwd: {project_path}\")\n\n        # Check for quick fix mode FIRST (lightweight mode, no full run required)\n        log(f\"Checking for quick fix in: {project_path}\")\n        quick_fix = get_quick_fix_state(project_path)\n        if quick_fix and quick_fix.get(\"quick_fix_active\"):\n            target_file = quick_fix.get(\"target_file\", \"\")\n            rel_path = os.path.relpath(file_path, project_path)\n            # Normalize paths for comparison\n            rel_path = os.path.normpath(rel_path)\n            target_file = os.path.normpath(target_file)\n            log(f\"Quick fix active: target={target_file}, rel_path={rel_path}\")\n\n            if rel_path == target_file or file_path == target_file:\n                # File matches quick fix target - ALLOW\n                log(f\"ALLOWING (quick fix): {rel_path}\")\n                output = {\"decision\": \"allow\"}\n                output_str = json.dumps(output)\n                log(f\"OUTPUT: {output_str}\")\n                print(output_str)\n                sys.exit(0)\n            else:\n                # Wrong file for quick fix\n                log(f\"BLOCKING: {rel_path} not quick fix target {target_file}\")\n                output = {\n                    \"decision\": \"block\",\n                    \"reason\": (\n                        f\"ERI-RPG ENFORCEMENT: Quick fix is for a different file.\\n\"\n                        f\"Requested: {rel_path}\\n\"\n                        f\"Quick fix target: {target_file}\\n\\n\"\n                        f\"Complete current quick fix first:\\n\"\n                        f\"  eri-rpg quick-done <project>\\n\\n\"\n                        f\"Or start a new quick fix:\\n\"\n                        f\"  eri-rpg quick <project> {rel_path} \\\"description\\\"\"\n                    )\n                }\n                output_str = json.dumps(output)\n                log(f\"OUTPUT: {output_str}\")\n                print(output_str)\n                sys.exit(0)\n\n        # Check for active run\n        log(f\"Checking for active run in: {project_path}\")\n        run_state = get_active_run_state(project_path)\n        log(f\"Run state: {run_state.get('id') if run_state else None}\")\n        if not run_state:\n            # No active run - BLOCK\n            log(f\"BLOCKING: No active run\")\n            output = {\n                \"decision\": \"block\",\n                \"reason\": (\n                    f\"ERI-RPG ENFORCEMENT: No active run.\\n\"\n                    f\"File: {os.path.basename(file_path)}\\n\\n\"\n                    f\"Start an EriRPG run first:\\n\"\n                    f\"  from erirpg.agent import Agent\\n\"\n                    f\"  agent = Agent.from_goal('task', project_path='{project_path}')\\n\"\n                    f\"  agent.preflight(['{os.path.relpath(file_path, project_path)}'], 'modify')\\n\\n\"\n                    f\"Or use quick fix for single-file edits:\\n\"\n                    f\"  eri-rpg quick <project> {os.path.relpath(file_path, project_path)} \\\"description\\\"\"\n                )\n            }\n            output_str = json.dumps(output)\n            log(f\"OUTPUT: {output_str}\")\n            print(output_str)\n            sys.exit(0)\n\n        # Check for preflight state\n        log(f\"Checking preflight state\")\n        preflight = get_preflight_state(project_path)\n        log(f\"Preflight: ready={preflight.get('ready') if preflight else None}, targets={preflight.get('target_files') if preflight else None}\")\n        if not preflight or not preflight.get(\"ready\"):\n            # No preflight - BLOCK\n            log(f\"BLOCKING: No preflight or not ready\")\n            output = {\n                \"decision\": \"block\",\n                \"reason\": (\n                    f\"ERI-RPG ENFORCEMENT: Preflight required.\\n\"\n                    f\"File: {os.path.basename(file_path)}\\n\\n\"\n                    f\"Run preflight first:\\n\"\n                    f\"  agent.preflight(['{os.path.relpath(file_path, project_path)}'], 'modify')\"\n                )\n            }\n            output_str = json.dumps(output)\n            log(f\"OUTPUT: {output_str}\")\n            print(output_str)\n            sys.exit(0)\n\n        # Check if file is in preflight targets\n        allowed_files = preflight.get(\"target_files\", [])\n        rel_path = os.path.relpath(file_path, project_path)\n        # Normalize paths for comparison\n        rel_path = os.path.normpath(rel_path)\n        normalized_allowed = [os.path.normpath(f) for f in allowed_files]\n        log(f\"Checking file: rel_path={rel_path}, allowed={normalized_allowed}\")\n\n        if rel_path not in normalized_allowed and file_path not in allowed_files:\n            log(f\"BLOCKING: {rel_path} not in {allowed_files}\")\n            # File not in preflight - BLOCK\n            output = {\n                \"decision\": \"block\",\n                \"reason\": (\n                    f\"ERI-RPG ENFORCEMENT: File not in preflight.\\n\"\n                    f\"File: {rel_path}\\n\"\n                    f\"Allowed: {allowed_files}\\n\\n\"\n                    f\"Re-run preflight with this file:\\n\"\n                    f\"  agent.preflight(['{rel_path}'], 'modify')\"\n                )\n            }\n            output_str = json.dumps(output)\n            log(f\"OUTPUT: {output_str}\")\n            print(output_str)\n            sys.exit(0)\n\n        # All checks passed - ALLOW (auto-approve, no prompt)\n        log(f\"ALLOWING: {rel_path} is in preflight targets\")\n        output = {\n            \"decision\": \"allow\"\n        }\n        output_str = json.dumps(output)\n        log(f\"OUTPUT: {output_str}\")\n        print(output_str)\n        sys.exit(0)\n\n    except Exception as e:\n        # On error, ALLOW (fail open for safety)\n        # But warn about the error\n        log(f\"EXCEPTION: {str(e)}\")\n        log(f\"TRACEBACK: {traceback.format_exc()}\")\n        output = {\n            \"systemMessage\": f\"EriRPG hook error (allowing): {str(e)}\"\n        }\n        print(json.dumps(output))\n        sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n", "timestamp": "2026-01-26T22:23:55.561163"}