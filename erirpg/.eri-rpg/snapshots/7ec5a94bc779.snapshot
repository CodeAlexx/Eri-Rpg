{"file_path": "quick.py", "content": "\"\"\"\nEriRPG Quick Fix Mode - Lightweight single-file edits.\n\nSkip the full spec ceremony for simple, focused changes:\n- Single-file edits\n- Small bug fixes\n- Minor improvements\n- Quick tweaks\n\nNo run state, no spec, no steps. Just:\n1. Auto-preflight (strict=False)\n2. Snapshot file\n3. Allow edit\n4. Auto-commit with description\n5. Done\n\nUsage:\n    from erirpg.quick import quick_fix\n\n    commit = quick_fix(\"myproject\", \"path/to/file.py\", \"Fix typo in docstring\")\n\nOr via CLI:\n    eri-rpg quick myproject path/to/file.py \"Fix typo in docstring\"\n\nOr via Agent API:\n    agent = QuickAgent(\"myproject\")\n    agent.fix(\"path/to/file.py\", \"Fix typo\")\n\"\"\"\n\nimport json\nimport os\nimport subprocess\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\nfrom erirpg.registry import Registry\nfrom erirpg.memory import git_head, in_git_repo\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# GLOBAL STATE - Quick fix mode active flag\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n_QUICK_FIX_ACTIVE: bool = False\n_QUICK_FIX_FILE: Optional[str] = None\n_QUICK_FIX_PROJECT: Optional[str] = None\n\n\ndef is_quick_fix_active() -> bool:\n    \"\"\"Check if quick fix mode is active.\"\"\"\n    return _QUICK_FIX_ACTIVE\n\n\ndef get_quick_fix_file() -> Optional[str]:\n    \"\"\"Get the file being quick-fixed.\"\"\"\n    return _QUICK_FIX_FILE\n\n\ndef get_quick_fix_project() -> Optional[str]:\n    \"\"\"Get the project being quick-fixed.\"\"\"\n    return _QUICK_FIX_PROJECT\n\n\ndef _set_quick_fix_active(active: bool, file_path: Optional[str] = None, project: Optional[str] = None) -> None:\n    \"\"\"Set quick fix mode state (internal use only).\"\"\"\n    global _QUICK_FIX_ACTIVE, _QUICK_FIX_FILE, _QUICK_FIX_PROJECT\n    _QUICK_FIX_ACTIVE = active\n    _QUICK_FIX_FILE = file_path if active else None\n    _QUICK_FIX_PROJECT = project if active else None\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# QUICK FIX STATE FILE - For hook integration\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef save_quick_fix_state(project_path: str, file_path: str, description: str) -> Path:\n    \"\"\"\n    Save quick fix state to file for Claude Code hooks.\n\n    The pretooluse hook checks this file to allow quick fix edits\n    without requiring a full run.\n    \"\"\"\n    state = {\n        \"quick_fix_active\": True,\n        \"target_file\": file_path,\n        \"description\": description,\n        \"timestamp\": datetime.now().isoformat(),\n    }\n\n    state_dir = Path(project_path) / \".eri-rpg\"\n    state_dir.mkdir(parents=True, exist_ok=True)\n\n    state_file = state_dir / \"quick_fix_state.json\"\n    with open(state_file, \"w\") as f:\n        json.dump(state, f, indent=2)\n\n    return state_file\n\n\ndef clear_quick_fix_state(project_path: str) -> None:\n    \"\"\"Clear quick fix state file.\"\"\"\n    state_file = Path(project_path) / \".eri-rpg\" / \"quick_fix_state.json\"\n    if state_file.exists():\n        state_file.unlink()\n\n\ndef load_quick_fix_state(project_path: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Load quick fix state from file.\"\"\"\n    state_file = Path(project_path) / \".eri-rpg\" / \"quick_fix_state.json\"\n    if not state_file.exists():\n        return None\n\n    try:\n        with open(state_file) as f:\n            return json.load(f)\n    except Exception:\n        return None\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# QUICK FIX FUNCTION\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef quick_fix(\n    project: str,\n    file_path: str,\n    description: str,\n    auto_commit: bool = True,\n    dry_run: bool = False,\n) -> Optional[str]:\n    \"\"\"\n    Single-file edit without full spec ceremony.\n\n    This is the lightweight alternative to Agent.from_goal() for simple fixes.\n    No run state, no spec, no steps - just preflight, snapshot, edit, commit.\n\n    Args:\n        project: Project name (from registry)\n        file_path: Path to the file (relative to project)\n        description: Description of the fix (used for commit message)\n        auto_commit: Whether to git commit after edit (default: True)\n        dry_run: If True, only setup but don't actually allow edits\n\n    Returns:\n        Commit hash if successful and auto_commit=True, else \"ok\"\n\n    Raises:\n        ValueError: If project not found\n        FileNotFoundError: If file doesn't exist\n\n    Usage:\n        # Start quick fix mode\n        commit = quick_fix(\"myproject\", \"src/utils.py\", \"Fix off-by-one error\")\n\n        # Now Claude Code can edit the file\n        # The hook will allow it because quick_fix_state.json exists\n\n        # After edit is done, the file is auto-committed\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        raise ValueError(f\"Project '{project}' not found. Add it with: eri-rpg add {project} <path>\")\n\n    project_path = proj.path\n\n    # Normalize file path\n    file_path = os.path.normpath(file_path)\n    full_path = Path(project_path) / file_path\n\n    if not full_path.exists():\n        raise FileNotFoundError(f\"File not found: {full_path}\")\n\n    # Snapshot file before changes\n    original_content = full_path.read_text()\n    snapshot_path = _save_snapshot(project_path, file_path, original_content)\n\n    # Set global state\n    _set_quick_fix_active(True, file_path, project)\n\n    # Save state file for hook integration\n    save_quick_fix_state(project_path, file_path, description)\n\n    if dry_run:\n        print(f\"Quick fix mode activated (dry run)\")\n        print(f\"  Project: {project}\")\n        print(f\"  File: {file_path}\")\n        print(f\"  Description: {description}\")\n        print(f\"  Snapshot: {snapshot_path}\")\n        return \"dry_run\"\n\n    print(f\"Quick fix mode activated\")\n    print(f\"  File: {file_path}\")\n    print(f\"  Edit the file, then run: eri-rpg quick-done {project}\")\n\n    return \"ready\"\n\n\ndef quick_done(\n    project: str,\n    auto_commit: bool = True,\n    commit_message: Optional[str] = None,\n) -> Optional[str]:\n    \"\"\"\n    Complete a quick fix - commit changes and cleanup.\n\n    Call this after making edits to finalize the quick fix.\n\n    Args:\n        project: Project name\n        auto_commit: Whether to git commit (default: True)\n        commit_message: Custom commit message (default: uses description from quick_fix)\n\n    Returns:\n        Commit hash if committed, else \"ok\"\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        raise ValueError(f\"Project '{project}' not found\")\n\n    project_path = proj.path\n\n    # Load quick fix state\n    state = load_quick_fix_state(project_path)\n    if not state or not state.get(\"quick_fix_active\"):\n        print(\"No active quick fix to complete\")\n        return None\n\n    file_path = state.get(\"target_file\")\n    description = commit_message or state.get(\"description\", \"Quick fix\")\n\n    commit_hash = None\n\n    # Git commit if enabled\n    if auto_commit and in_git_repo(project_path):\n        commit_hash = _git_commit(\n            project_path,\n            [file_path],\n            f\"[quick-fix] {description}\"\n        )\n        if commit_hash:\n            print(f\"Committed: {commit_hash[:8]}\")\n\n    # Clear state\n    _set_quick_fix_active(False)\n    clear_quick_fix_state(project_path)\n\n    print(f\"Quick fix complete: {file_path}\")\n\n    return commit_hash or \"ok\"\n\n\ndef quick_cancel(project: str) -> None:\n    \"\"\"\n    Cancel a quick fix and restore original file.\n\n    Args:\n        project: Project name\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        raise ValueError(f\"Project '{project}' not found\")\n\n    project_path = proj.path\n\n    # Load quick fix state\n    state = load_quick_fix_state(project_path)\n    if not state or not state.get(\"quick_fix_active\"):\n        print(\"No active quick fix to cancel\")\n        return\n\n    file_path = state.get(\"target_file\")\n\n    # Restore from snapshot\n    restored = _restore_snapshot(project_path, file_path)\n\n    # Clear state\n    _set_quick_fix_active(False)\n    clear_quick_fix_state(project_path)\n\n    if restored:\n        print(f\"Restored: {file_path}\")\n    else:\n        print(f\"No snapshot found for: {file_path}\")\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# QUICK AGENT - Object-oriented interface\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nclass QuickAgent:\n    \"\"\"\n    Lightweight agent for quick fixes.\n\n    Alternative to the full Agent when you just need to make\n    a simple, single-file change.\n\n    Usage:\n        agent = QuickAgent(\"myproject\")\n        agent.fix(\"src/utils.py\", \"Fix typo\")\n        # Make edits...\n        commit = agent.done()\n    \"\"\"\n\n    def __init__(self, project: str):\n        \"\"\"\n        Initialize quick agent for a project.\n\n        Args:\n            project: Project name from registry\n        \"\"\"\n        registry = Registry.get_instance()\n        proj = registry.get(project)\n\n        if not proj:\n            raise ValueError(f\"Project '{project}' not found\")\n\n        self.project = project\n        self.project_path = proj.path\n        self._active_file: Optional[str] = None\n        self._description: Optional[str] = None\n        self._snapshot: Optional[str] = None\n\n    def fix(self, file_path: str, description: str) -> \"QuickAgent\":\n        \"\"\"\n        Start a quick fix on a file.\n\n        Args:\n            file_path: Path to file (relative to project)\n            description: What you're fixing\n\n        Returns:\n            self (for chaining)\n        \"\"\"\n        # Normalize path\n        file_path = os.path.normpath(file_path)\n        full_path = Path(self.project_path) / file_path\n\n        if not full_path.exists():\n            raise FileNotFoundError(f\"File not found: {full_path}\")\n\n        # Snapshot\n        self._snapshot = full_path.read_text()\n        _save_snapshot(self.project_path, file_path, self._snapshot)\n\n        # Set state\n        self._active_file = file_path\n        self._description = description\n\n        # Global state and file for hooks\n        _set_quick_fix_active(True, file_path, self.project)\n        save_quick_fix_state(self.project_path, file_path, description)\n\n        return self\n\n    def done(self, auto_commit: bool = True) -> Optional[str]:\n        \"\"\"\n        Complete the quick fix.\n\n        Args:\n            auto_commit: Whether to git commit\n\n        Returns:\n            Commit hash or \"ok\"\n        \"\"\"\n        if not self._active_file:\n            raise RuntimeError(\"No active quick fix. Call fix() first.\")\n\n        commit_hash = None\n\n        if auto_commit and in_git_repo(self.project_path):\n            commit_hash = _git_commit(\n                self.project_path,\n                [self._active_file],\n                f\"[quick-fix] {self._description}\"\n            )\n\n        # Cleanup\n        _set_quick_fix_active(False)\n        clear_quick_fix_state(self.project_path)\n\n        self._active_file = None\n        self._description = None\n        self._snapshot = None\n\n        return commit_hash or \"ok\"\n\n    def cancel(self) -> None:\n        \"\"\"Cancel and restore original file.\"\"\"\n        if not self._active_file:\n            return\n\n        _restore_snapshot(self.project_path, self._active_file)\n\n        _set_quick_fix_active(False)\n        clear_quick_fix_state(self.project_path)\n\n        self._active_file = None\n        self._description = None\n        self._snapshot = None\n\n    @property\n    def is_active(self) -> bool:\n        \"\"\"Check if a quick fix is in progress.\"\"\"\n        return self._active_file is not None\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# HELPER FUNCTIONS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef _save_snapshot(project_path: str, file_path: str, content: str) -> Path:\n    \"\"\"Save file snapshot for potential rollback.\"\"\"\n    snapshot_dir = Path(project_path) / \".eri-rpg\" / \"snapshots\"\n    snapshot_dir.mkdir(parents=True, exist_ok=True)\n\n    # Use file path hash for unique name\n    import hashlib\n    path_hash = hashlib.sha256(file_path.encode()).hexdigest()[:12]\n    snapshot_file = snapshot_dir / f\"{path_hash}.snapshot\"\n\n    # Save with metadata\n    snapshot_data = {\n        \"file_path\": file_path,\n        \"content\": content,\n        \"timestamp\": datetime.now().isoformat(),\n    }\n\n    with open(snapshot_file, \"w\") as f:\n        json.dump(snapshot_data, f)\n\n    return snapshot_file\n\n\ndef _restore_snapshot(project_path: str, file_path: str) -> bool:\n    \"\"\"Restore file from snapshot.\"\"\"\n    import hashlib\n\n    snapshot_dir = Path(project_path) / \".eri-rpg\" / \"snapshots\"\n    path_hash = hashlib.sha256(file_path.encode()).hexdigest()[:12]\n    snapshot_file = snapshot_dir / f\"{path_hash}.snapshot\"\n\n    if not snapshot_file.exists():\n        return False\n\n    try:\n        with open(snapshot_file) as f:\n            data = json.load(f)\n\n        content = data.get(\"content\", \"\")\n        full_path = Path(project_path) / file_path\n        full_path.write_text(content)\n\n        # Remove snapshot after restore\n        snapshot_file.unlink()\n\n        return True\n    except Exception:\n        return False\n\n\ndef _git_commit(project_path: str, files: List[str], message: str) -> Optional[str]:\n    \"\"\"Create git commit for files.\"\"\"\n    try:\n        # Stage files\n        full_paths = [str(Path(project_path) / f) for f in files]\n        subprocess.run(\n            ['git', 'add'] + full_paths,\n            check=True,\n            capture_output=True,\n            cwd=project_path,\n        )\n\n        # Commit\n        subprocess.run(\n            ['git', 'commit', '-m', message],\n            check=True,\n            capture_output=True,\n            cwd=project_path,\n        )\n\n        # Get commit hash\n        return git_head()\n    except subprocess.CalledProcessError:\n        return None\n\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# EXPORTS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n__all__ = [\n    # Functions\n    \"quick_fix\",\n    \"quick_done\",\n    \"quick_cancel\",\n    # State checks\n    \"is_quick_fix_active\",\n    \"get_quick_fix_file\",\n    \"get_quick_fix_project\",\n    \"load_quick_fix_state\",\n    # Class\n    \"QuickAgent\",\n]\n", "timestamp": "2026-01-26T17:43:21.350073"}