{"file_path": "cli.py", "content": "\"\"\"\nEriRPG CLI - One tool. Three modes. No bloat.\n\nModes:\n- new: Create new project from scratch\n- take: Transplant feature from Project A to Project B\n- work: Modify existing project\n\nCommands:\n- Setup: add, remove, list, index\n- Modes: new, take, work\n- Exploration: show, find, impact\n- Knowledge: learn, recall, relearn, decide, pattern, log, knowledge\n- Flow: status, next, validate, done, reset\n\"\"\"\n\nimport click\nimport json\nimport os\nimport sys\nimport re\n\nfrom datetime import datetime\n\nfrom erirpg.registry import Registry, Project, detect_project_language\nfrom erirpg.indexer import index_project, get_or_load_graph\nfrom erirpg.graph import Graph\nfrom erirpg.ops import find_modules, extract_feature, analyze_impact, plan_transplant, Feature, TransplantPlan\nfrom erirpg.context import generate_context, estimate_tokens\nfrom erirpg.state import State\nfrom erirpg.knowledge import Learning, Decision, HistoryEntry\nfrom erirpg.modes import run_take, run_work, run_new, run_next, QUESTIONS\nfrom erirpg.memory import StoredLearning, load_knowledge, save_knowledge\nfrom erirpg.refs import CodeRef\n\n\n@click.group()\n@click.version_option(version=\"0.1.0\")\ndef cli():\n    \"\"\"EriRPG - Cross-project feature transplant tool.\n\n    Register projects, index codebases, find capabilities,\n    extract features, and generate context for Claude Code.\n    \"\"\"\n    pass\n\n\n# ============================================================================\n# Setup Commands\n# ============================================================================\n\n@cli.command()\n@click.argument(\"name\")\n@click.argument(\"path\", type=click.Path())\n@click.option(\"--lang\", default=None, type=click.Choice([\"python\", \"rust\", \"c\"]),\n              help=\"Programming language (auto-detected if not specified). Supported: python, rust, c.\")\ndef add(name: str, path: str, lang: str):\n    \"\"\"Register a project.\n\n    NAME: Unique project identifier\n    PATH: Path to project root\n    \"\"\"\n    registry = Registry.get_instance()\n\n    # Auto-detect language if not specified\n    if lang is None:\n        lang = detect_project_language(path)\n        if lang == \"unknown\":\n            click.echo(\"Warning: Could not detect language, defaulting to 'python'\", err=True)\n            lang = \"python\"\n        else:\n            click.echo(f\"Auto-detected language: {lang}\")\n\n    try:\n        project = registry.add(name, path, lang)\n        click.echo(f\"Added project: {name}\")\n        click.echo(f\"  Path: {project.path}\")\n        click.echo(f\"  Language: {lang}\")\n        click.echo(f\"\\nNext: eri-rpg index {name}\")\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n    except FileNotFoundError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n@cli.command()\n@click.argument(\"name\")\ndef remove(name: str):\n    \"\"\"Remove a project from registry.\"\"\"\n    registry = Registry.get_instance()\n\n    if registry.remove(name):\n        click.echo(f\"Removed project: {name}\")\n    else:\n        click.echo(f\"Error: Project '{name}' not found\", err=True)\n        sys.exit(1)\n\n\n@cli.command(\"list\")\ndef list_projects():\n    \"\"\"List registered projects.\"\"\"\n    registry = Registry.get_instance()\n    projects = registry.list()\n\n    if not projects:\n        click.echo(\"No projects registered.\")\n        click.echo(\"Add one with: eri-rpg add <name> <path>\")\n        return\n\n    for p in projects:\n        status = \"indexed\" if p.is_indexed() else \"not indexed\"\n        age = \"\"\n        if p.index_age_days() is not None:\n            days = p.index_age_days()\n            if days < 1:\n                age = \" (today)\"\n            else:\n                age = f\" ({int(days)} days ago)\"\n\n        click.echo(f\"{p.name}: {p.path} ({p.lang}, {status}{age})\")\n\n\n@cli.command()\n@click.argument(\"name\")\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Show progress\")\ndef index(name: str, verbose: bool):\n    \"\"\"Index a project's codebase.\n\n    Parses all files, extracts interfaces, builds dependency graph.\n    \"\"\"\n    registry = Registry.get_instance()\n    project = registry.get(name)\n\n    if not project:\n        click.echo(f\"Error: Project '{name}' not found\", err=True)\n        click.echo(\"Add it with: eri-rpg add <name> <path>\")\n        sys.exit(1)\n\n    click.echo(f\"Indexing {name}...\")\n    try:\n        graph = index_project(project, verbose=verbose)\n        registry.update_indexed(name)\n\n        stats = graph.stats()\n        click.echo(f\"\\nIndexed:\")\n        click.echo(f\"  Modules: {stats['modules']}\")\n        click.echo(f\"  Dependencies: {stats['edges']}\")\n        click.echo(f\"  Lines: {stats['total_lines']:,}\")\n        click.echo(f\"  Interfaces: {stats['total_interfaces']}\")\n        click.echo(f\"\\nSaved to: {project.graph_path}\")\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n# ============================================================================\n# Mode Commands (new, take, work)\n# ============================================================================\n\n@cli.command()\n@click.argument(\"description\")\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Show detailed progress\")\ndef take(description: str, verbose: bool):\n    \"\"\"Transplant a feature from one project to another.\n\n    One command does it all: find \u2192 learn \u2192 spec \u2192 context \u2192 guide.\n\n    \\b\n    Examples:\n        eri-rpg take \"masked_loss from onetrainer into eritrainer\"\n        eri-rpg take \"gradient checkpointing from onetrainer\"\n\n    The second form uses current directory as target.\n    \"\"\"\n    result = run_take(description, verbose=verbose)\n\n    if not result['success']:\n        click.echo(f\"Error: {result['error']}\", err=True)\n        sys.exit(1)\n\n    # Show guide\n    click.echo(result['guide'])\n\n    # Show knowledge hints if some modules need learning\n    knowledge = result.get('knowledge_status', {})\n    need_learning = knowledge.get('need_to_learn', [])\n\n    if need_learning and len(need_learning) <= 3:\n        click.echo(\"Tip: After understanding these modules, store learnings:\")\n        for path in need_learning:\n            click.echo(f\"  eri-rpg learn {result['source']} {path}\")\n        click.echo(\"\")\n\n\n@cli.command()\n@click.argument(\"project\", required=False)\n@click.argument(\"task\")\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Show detailed progress\")\ndef work(project: str, task: str, verbose: bool):\n    \"\"\"Modify an existing project.\n\n    Find relevant code, load knowledge, generate context, guide.\n\n    \\b\n    Examples:\n        eri-rpg work eritrainer \"add dark mode to settings\"\n        eri-rpg work \"fix the memory leak in dataloader\"\n\n    The second form uses current directory as project.\n    \"\"\"\n    result = run_work(project, task, verbose=verbose)\n\n    if not result['success']:\n        click.echo(f\"Error: {result['error']}\", err=True)\n        sys.exit(1)\n\n    # Show guide\n    click.echo(result['guide'])\n\n    # Show knowledge hints\n    knowledge = result.get('knowledge', {})\n    unknown = knowledge.get('unknown', [])\n\n    if unknown and len(unknown) <= 3:\n        click.echo(\"Tip: After understanding these modules, store learnings:\")\n        for path in unknown:\n            click.echo(f\"  eri-rpg learn {result['project']} {path}\")\n        click.echo(\"\")\n\n\n@cli.command()\ndef done():\n    \"\"\"Mark current work as complete.\n\n    Updates state and logs completion.\n    \"\"\"\n    state = State.load()\n\n    if state.phase == \"idle\":\n        click.echo(\"Nothing in progress.\")\n        return\n\n    task = state.current_task or \"Unknown task\"\n    state.log(\"done\", f\"Completed: {task}\")\n    state.reset()\n\n    click.echo(f\"\u2713 Marked complete: {task}\")\n    click.echo(\"\")\n    click.echo(\"If you learned something new, store it:\")\n    click.echo(\"  eri-rpg learn <project> <module>\")\n\n\n@cli.command(\"new\")\n@click.argument(\"description\")\n@click.option(\"-o\", \"--output\", default=None, help=\"Where to create project\")\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Show detailed progress\")\ndef new_project(description: str, output: str, verbose: bool):\n    \"\"\"Create a new project from scratch.\n\n    Asks questions, generates spec, creates structure, guides you.\n\n    \\b\n    Example:\n        eri-rpg new \"video editor with timeline and effects\"\n    \"\"\"\n    # Interactive question flow\n    click.echo(\"\")\n    click.echo(f\"Creating: {description}\")\n    click.echo(\"\")\n    click.echo(\"I need a few details:\")\n    click.echo(\"\")\n\n    answers = {}\n\n    for q in QUESTIONS:\n        if q.options:\n            # Multiple choice\n            click.echo(f\"{q.question}\")\n            click.echo(f\"  ({q.why})\")\n            for i, opt in enumerate(q.options, 1):\n                default_marker = \" [default]\" if opt == q.default else \"\"\n                click.echo(f\"  {i}. {opt}{default_marker}\")\n\n            while True:\n                choice = click.prompt(\"Choice\", default=str(q.options.index(q.default) + 1) if q.default else \"1\")\n                try:\n                    idx = int(choice) - 1\n                    if 0 <= idx < len(q.options):\n                        answers[q.id] = q.options[idx]\n                        break\n                except ValueError:\n                    # Maybe they typed the option name\n                    if choice in q.options:\n                        answers[q.id] = choice\n                        break\n                click.echo(\"Invalid choice, try again\")\n        else:\n            # Free text\n            click.echo(f\"{q.question}\")\n            click.echo(f\"  ({q.why})\")\n\n            if q.required:\n                value = click.prompt(\">\")\n            else:\n                value = click.prompt(\">\", default=q.default or \"\")\n\n            answers[q.id] = value\n\n        click.echo(\"\")\n\n    # Run new mode with answers\n    result = run_new(description, output_dir=output, answers=answers, verbose=verbose)\n\n    if not result['success']:\n        if result.get('need_input'):\n            click.echo(\"Error: Questions not answered\", err=True)\n        else:\n            click.echo(f\"Error: {result.get('error', 'Unknown error')}\", err=True)\n        sys.exit(1)\n\n    # Show guide\n    click.echo(result['guide'])\n\n\n@cli.command(\"next\")\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Show detailed progress\")\ndef next_chunk(verbose: bool):\n    \"\"\"Advance to next chunk in new project.\n\n    Use after completing a chunk to get context for the next one.\n    \"\"\"\n    result = run_next(verbose=verbose)\n\n    if not result['success']:\n        click.echo(f\"Error: {result['error']}\", err=True)\n        sys.exit(1)\n\n    if result.get('done'):\n        click.echo(\"\")\n        click.echo(\"\u2550\" * 56)\n        click.echo(f\"\ud83c\udf89 PROJECT COMPLETE: {result['message']}\")\n        click.echo(\"\u2550\" * 56)\n        click.echo(\"\")\n        click.echo(\"Next steps:\")\n        click.echo(\"  - Index the project: eri-rpg index <name>\")\n        click.echo(\"  - Store learnings: eri-rpg learn <name> <module>\")\n        click.echo(\"\")\n    else:\n        click.echo(result['guide'])\n        click.echo(f\"Remaining chunks: {result['remaining']}\")\n        click.echo(\"\")\n\n\n# ============================================================================\n# Exploration Commands\n# ============================================================================\n\n@cli.command()\n@click.argument(\"project\")\ndef show(project: str):\n    \"\"\"Show project structure and metadata.\"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Project header\n    click.echo(f\"Project: {project}\")\n    if proj.description:\n        click.echo(f\"Description: {proj.description}\")\n    click.echo(f\"Path: {proj.path}\")\n    click.echo(f\"Language: {proj.lang}\")\n\n    # Index status\n    if proj.indexed_at:\n        age_days = (datetime.now() - proj.indexed_at).days\n        age_str = \"today\" if age_days == 0 else f\"{age_days}d ago\"\n        click.echo(f\"Indexed: {age_str}\")\n    else:\n        click.echo(\"Indexed: not indexed\")\n\n    click.echo(\"\")\n\n    # TODOs\n    if proj.todos:\n        click.echo(\"TODOs:\")\n        for i, todo in enumerate(proj.todos):\n            click.echo(f\"  [{i}] {todo}\")\n        click.echo(\"\")\n\n    # Notes\n    if proj.notes:\n        click.echo(\"Notes:\")\n        for line in proj.notes.split('\\n'):\n            click.echo(f\"  {line}\")\n        click.echo(\"\")\n\n    # Try to load graph for stats\n    try:\n        graph = get_or_load_graph(proj)\n        stats = graph.stats()\n        knowledge = graph.knowledge\n        k_stats = knowledge.stats()\n\n        click.echo(f\"Modules: {stats['modules']}\")\n        click.echo(f\"Lines: {stats['total_lines']:,}\")\n        click.echo(f\"Patterns: {k_stats['patterns']} stored\")\n        click.echo(f\"Decisions: {k_stats['decisions']} stored\")\n        click.echo(f\"Learnings: {k_stats['learnings']} stored\")\n        click.echo(\"\")\n\n        # Group by top-level directory\n        dirs = {}\n        for mod_path in sorted(graph.modules.keys()):\n            parts = mod_path.split(\"/\")\n            top = parts[0] if len(parts) > 1 else \"(root)\"\n            if top not in dirs:\n                dirs[top] = []\n            dirs[top].append(mod_path)\n\n        for dir_name, modules in sorted(dirs.items()):\n            click.echo(f\"{dir_name}/\")\n            for mod in modules[:5]:  # Show first 5\n                m = graph.get_module(mod)\n                ifaces = \", \".join(i.name for i in m.interfaces[:3])\n                if len(m.interfaces) > 3:\n                    ifaces += \"...\"\n                click.echo(f\"  {mod}: {ifaces}\")\n            if len(modules) > 5:\n                click.echo(f\"  ... and {len(modules) - 5} more\")\n\n    except ValueError:\n        click.echo(\"(not indexed - run: eri-rpg index {})\".format(project))\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"query\")\n@click.option(\"-n\", \"--limit\", default=10, help=\"Max results\")\ndef find(project: str, query: str, limit: int):\n    \"\"\"Find modules matching a query.\n\n    Searches summaries, interface names, and docstrings.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    results = find_modules(graph, query, limit=limit)\n\n    if not results:\n        click.echo(f\"No modules match: {query}\")\n        click.echo(\"Try broader terms or: eri-rpg show {project}\")\n        return\n\n    click.echo(f\"Matching modules in {project}:\")\n    click.echo(\"\")\n    for mod, score in results:\n        summary = mod.summary[:60] + \"...\" if len(mod.summary) > 60 else mod.summary\n        click.echo(f\"  {mod.path} ({score:.2f})\")\n        if summary:\n            click.echo(f\"    {summary}\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\ndef impact(project: str, module_path: str):\n    \"\"\"Analyze impact of changing a module.\n\n    Shows direct and transitive dependents.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    try:\n        analysis = analyze_impact(graph, module_path)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    click.echo(f\"Impact analysis for {module_path}:\")\n    click.echo(\"\")\n\n    if analysis[\"summary\"]:\n        click.echo(f\"Summary: {analysis['summary']}\")\n\n    click.echo(f\"Interfaces: {', '.join(analysis['interfaces'])}\")\n    click.echo(\"\")\n\n    click.echo(f\"Direct dependents ({len(analysis['direct_dependents'])}):\")\n    for d in analysis[\"direct_dependents\"]:\n        click.echo(f\"  - {d}\")\n\n    if analysis[\"transitive_dependents\"]:\n        click.echo(f\"\\nTransitive dependents ({len(analysis['transitive_dependents'])}):\")\n        for d in analysis[\"transitive_dependents\"][:5]:\n            click.echo(f\"  - {d}\")\n        if len(analysis[\"transitive_dependents\"]) > 5:\n            click.echo(f\"  ... and {len(analysis['transitive_dependents']) - 5} more\")\n\n    click.echo(f\"\\nTotal affected: {analysis['total_affected']}\")\n    click.echo(f\"Risk: {analysis['risk']}\")\n\n\n# ============================================================================\n# Transplant Commands\n# ============================================================================\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"query\")\n@click.option(\"-o\", \"--output\", required=True, help=\"Output file path\")\n@click.option(\"-n\", \"--name\", default=None, help=\"Feature name\")\ndef extract(project: str, query: str, output: str, name: str):\n    \"\"\"Extract a feature from a project.\n\n    Finds matching modules, includes dependencies, saves as JSON.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    feature_name = name or query.replace(\" \", \"_\")\n\n    try:\n        feature = extract_feature(graph, proj, query, feature_name)\n        feature.save(output)\n\n        click.echo(f\"Extracted feature: {feature_name}\")\n        click.echo(f\"Components: {len(feature.components)}\")\n        for c in feature.components:\n            click.echo(f\"  - {c}\")\n        click.echo(f\"Provides: {len(feature.provides)} interfaces\")\n        click.echo(f\"Requires: {len(feature.requires)} packages\")\n        click.echo(f\"\\nSaved to: {output}\")\n\n        # Update state\n        state = State.load()\n        state.update(\n            current_task=f\"Transplant {feature_name} from {project}\",\n            phase=\"extracting\",\n            feature_file=output,\n        )\n        state.log(\"extract\", f\"Extracted {feature_name} to {output}\")\n\n        click.echo(f\"\\nNext: eri-rpg plan {output} <target_project>\")\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n@cli.command()\n@click.argument(\"feature_file\", type=click.Path(exists=True))\n@click.argument(\"target_project\")\ndef plan(feature_file: str, target_project: str):\n    \"\"\"Plan transplant to target project.\n\n    Creates mappings and wiring tasks.\n    \"\"\"\n    registry = Registry.get_instance()\n    target = registry.get(target_project)\n\n    if not target:\n        click.echo(f\"Error: Target project '{target_project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        target_graph = get_or_load_graph(target)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    feature = Feature.load(feature_file)\n    transplant_plan = plan_transplant(feature, target_graph, target)\n\n    # Save plan\n    plan_file = feature_file.replace(\".json\", \".plan.json\")\n    transplant_plan.save(plan_file)\n\n    click.echo(f\"Transplant plan: {feature.name} -> {target_project}\")\n    click.echo(\"\")\n\n    click.echo(\"Mappings:\")\n    for m in transplant_plan.mappings:\n        click.echo(f\"  {m.source_interface}: {m.action}\")\n        if m.notes:\n            click.echo(f\"    {m.notes}\")\n\n    if transplant_plan.wiring:\n        click.echo(\"\\nWiring tasks:\")\n        for w in transplant_plan.wiring:\n            click.echo(f\"  {w.file}: {w.details}\")\n\n    click.echo(f\"\\nSaved to: {plan_file}\")\n\n    # Update state\n    state = State.load()\n    state.update(phase=\"planning\", plan_file=plan_file)\n    state.log(\"plan\", f\"Created plan at {plan_file}\")\n\n    click.echo(f\"\\nNext: eri-rpg context {feature_file} {target_project}\")\n\n\n@cli.command()\n@click.argument(\"feature_file\", type=click.Path(exists=True))\n@click.argument(\"target_project\")\n@click.option(\"--no-learnings\", is_flag=True, help=\"Include full source instead of learnings\")\ndef context(feature_file: str, target_project: str, no_learnings: bool):\n    \"\"\"Generate context for Claude Code.\n\n    Creates a markdown file with source code, target interfaces,\n    and transplant plan. Uses stored learnings when available\n    for ~85% token reduction on revisited modules.\n    \"\"\"\n    registry = Registry.get_instance()\n    target = registry.get(target_project)\n\n    if not target:\n        click.echo(f\"Error: Target project '{target_project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        target_graph = get_or_load_graph(target)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    feature = Feature.load(feature_file)\n\n    # Load source project's graph for knowledge lookup\n    source_proj = registry.get(feature.source_project)\n    source_graph = None\n    if source_proj:\n        try:\n            source_graph = get_or_load_graph(source_proj)\n        except ValueError:\n            pass  # No graph, no learnings - that's fine\n\n    # Load or generate plan\n    plan_file = feature_file.replace(\".json\", \".plan.json\")\n    if os.path.exists(plan_file):\n        transplant_plan = TransplantPlan.load(plan_file)\n    else:\n        transplant_plan = plan_transplant(feature, target_graph, target)\n        transplant_plan.save(plan_file)\n\n    context_path = generate_context(\n        feature, transplant_plan, source_graph, target_graph, target,\n        source_project=source_proj,\n        use_learnings=not no_learnings\n    )\n\n    tokens = estimate_tokens(feature, transplant_plan, source_project=source_proj)\n\n    click.echo(f\"Generated context: {context_path}\")\n    click.echo(f\"Estimated tokens: ~{tokens:,}\")\n    click.echo(\"\")\n    click.echo(\"Give this file to Claude Code:\")\n    click.echo(f\"  cat {context_path}\")\n    click.echo(\"\")\n    click.echo(\"Or reference it directly in conversation.\")\n\n    # Update state\n    state = State.load()\n    state.update(phase=\"context_ready\", context_file=context_path, waiting_on=\"claude\")\n    state.log(\"context\", f\"Generated context at {context_path}\")\n\n    click.echo(\"\\nAfter Claude implements, run: eri-rpg validate\")\n\n\n# ============================================================================\n# Orchestration Commands\n# ============================================================================\n\n@cli.command(\"do\")\n@click.argument(\"task\")\ndef do_task(task: str):\n    \"\"\"Smart mode - figure out steps for a task.\n\n    Parses task description and suggests/executes steps.\n    \"\"\"\n    state = State.load()\n    state.update(current_task=task, phase=\"idle\")\n    state.log(\"start\", task)\n\n    # Parse task patterns\n    task_lower = task.lower()\n\n    # Pattern: \"transplant X from Y to Z\"\n    match = re.search(r\"transplant\\s+(.+?)\\s+from\\s+(\\w+)\\s+to\\s+(\\w+)\", task_lower)\n    if match:\n        capability, source, target = match.groups()\n        click.echo(f\"Task: Transplant '{capability}' from {source} to {target}\")\n        click.echo(\"\")\n        click.echo(\"Steps:\")\n        click.echo(f\"  1. eri-rpg extract {source} \\\"{capability}\\\" -o feature.json\")\n        click.echo(f\"  2. eri-rpg plan feature.json {target}\")\n        click.echo(f\"  3. eri-rpg context feature.json {target}\")\n        click.echo(\"  4. Give context to Claude Code\")\n        click.echo(\"  5. eri-rpg validate\")\n        return\n\n    # Pattern: \"find X in Y\"\n    match = re.search(r\"find\\s+(.+?)\\s+in\\s+(\\w+)\", task_lower)\n    if match:\n        capability, project = match.groups()\n        click.echo(f\"Finding '{capability}' in {project}...\")\n        # Actually run find\n        from click.testing import CliRunner\n        runner = CliRunner()\n        result = runner.invoke(find, [project, capability])\n        click.echo(result.output)\n        return\n\n    # Pattern: \"what uses X in Y\"\n    match = re.search(r\"what\\s+uses\\s+(.+?)\\s+in\\s+(\\w+)\", task_lower)\n    if match:\n        module, project = match.groups()\n        click.echo(f\"Analyzing impact of {module} in {project}...\")\n        from click.testing import CliRunner\n        runner = CliRunner()\n        result = runner.invoke(impact, [project, module])\n        click.echo(result.output)\n        return\n\n    # Unknown pattern\n    click.echo(\"I don't recognize that task pattern.\")\n    click.echo(\"\")\n    click.echo(\"Supported patterns:\")\n    click.echo(\"  - transplant <capability> from <source> to <target>\")\n    click.echo(\"  - find <capability> in <project>\")\n    click.echo(\"  - what uses <module> in <project>\")\n\n\n@cli.command()\ndef status():\n    \"\"\"Show current status and next step.\"\"\"\n    state = State.load()\n    click.echo(state.format_status())\n\n\n@cli.command()\ndef validate():\n    \"\"\"Validate Claude's implementation.\n\n    Checks if transplant was completed correctly.\n    \"\"\"\n    state = State.load()\n\n    if state.phase not in [\"context_ready\", \"implementing\"]:\n        click.echo(\"Nothing to validate. Start a transplant first.\")\n        return\n\n    if not state.plan_file or not os.path.exists(state.plan_file):\n        click.echo(\"No plan file found. Cannot validate.\")\n        return\n\n    transplant_plan = TransplantPlan.load(state.plan_file)\n    registry = Registry.get_instance()\n    target = registry.get(transplant_plan.target_project)\n\n    if not target:\n        click.echo(f\"Target project '{transplant_plan.target_project}' not found.\")\n        return\n\n    click.echo(f\"Validating transplant to {transplant_plan.target_project}...\")\n    click.echo(\"\")\n\n    passed = 0\n    failed = 0\n\n    # Check mappings\n    for m in transplant_plan.mappings:\n        if m.action == \"CREATE\":\n            # Check if file exists (rough check)\n            # Would need smarter path resolution\n            click.echo(f\"? {m.source_interface}: Manual check needed\")\n        elif m.action == \"ADAPT\":\n            click.echo(f\"? {m.source_interface} -> {m.target_interface}: Manual check needed\")\n\n    # Check wiring\n    for w in transplant_plan.wiring:\n        click.echo(f\"? {w.file}: {w.action} - Manual check needed\")\n\n    click.echo(\"\")\n    click.echo(\"Manual verification required.\")\n    click.echo(\"If implementation is complete, run: eri-rpg status\")\n\n    state.update(phase=\"validating\")\n\n\n@cli.command()\ndef diagnose():\n    \"\"\"Diagnose what went wrong.\n\n    Analyzes current state and suggests fixes.\n    \"\"\"\n    state = State.load()\n\n    click.echo(\"Diagnosis:\")\n    click.echo(\"\")\n\n    if state.phase == \"idle\":\n        click.echo(\"No active task. Start with: eri-rpg do '<task>'\")\n        return\n\n    if not state.plan_file:\n        click.echo(\"No plan file. Need to plan first.\")\n        return\n\n    if not os.path.exists(state.plan_file):\n        click.echo(f\"Plan file missing: {state.plan_file}\")\n        return\n\n    transplant_plan = TransplantPlan.load(state.plan_file)\n\n    click.echo(\"Check these items:\")\n    click.echo(\"\")\n\n    for m in transplant_plan.mappings:\n        if m.action == \"CREATE\":\n            click.echo(f\"1. Create {m.source_interface}\")\n            click.echo(f\"   Suggested path: {m.notes}\")\n        elif m.action == \"ADAPT\":\n            click.echo(f\"1. Update {m.target_module} to include {m.source_interface} behavior\")\n\n    for w in transplant_plan.wiring:\n        click.echo(f\"2. {w.file}:\")\n        click.echo(f\"   {w.details}\")\n\n\n@cli.command()\ndef reset():\n    \"\"\"Reset state to idle.\"\"\"\n    state = State.load()\n    state.reset()\n    click.echo(\"State reset to idle.\")\n\n\n# ============================================================================\n# Knowledge Commands\n# ============================================================================\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\n@click.option(\"--summary\", \"-s\", prompt=True, help=\"One-line summary of the module\")\n@click.option(\"--purpose\", \"-p\", prompt=True, help=\"Detailed purpose explanation\")\n@click.option(\"--non-interactive\", \"-y\", is_flag=True, help=\"Skip interactive prompts for key functions and gotchas\")\ndef learn(project: str, module_path: str, summary: str, purpose: str, non_interactive: bool):\n    \"\"\"Store a learning about a module.\n\n    After understanding a module, record key insights so you don't\n    have to re-read it later. Saves ~85% tokens on revisits.\n\n    Example:\n        eri-rpg learn onetrainer modules/util/loss.py \\\\\n            -s \"Loss calculation utilities\" \\\\\n            -p \"Handles MSE, masked, and prior-based losses\"\n\n        # Non-interactive mode (for scripts/automation):\n        eri-rpg learn onetrainer modules/util/loss.py -y \\\\\n            -s \"Loss calculation utilities\" \\\\\n            -p \"Handles MSE, masked, and prior-based losses\"\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    key_functions = {}\n    gotchas = []\n\n    if not non_interactive:\n        # Prompt for optional details\n        click.echo(\"\\nOptional: Enter key functions (name: description), empty line to finish:\")\n        while True:\n            line = click.prompt(\"\", default=\"\", show_default=False)\n            if not line:\n                break\n            if \":\" in line:\n                name, desc = line.split(\":\", 1)\n                key_functions[name.strip()] = desc.strip()\n\n        click.echo(\"\\nOptional: Enter gotchas (one per line), empty line to finish:\")\n        while True:\n            line = click.prompt(\"\", default=\"\", show_default=False)\n            if not line:\n                break\n            gotchas.append(line)\n\n    # Create CodeRef for source file tracking\n    source_path = os.path.join(proj.path, module_path)\n    source_ref = None\n    if os.path.exists(source_path):\n        source_ref = CodeRef.from_file(proj.path, module_path)\n\n    # Create and store learning in v2 knowledge store\n    learning = StoredLearning(\n        module_path=module_path,\n        learned_at=datetime.now(),\n        summary=summary,\n        purpose=purpose,\n        key_functions=key_functions,\n        gotchas=gotchas,\n        source_ref=source_ref,\n    )\n\n    # Load existing knowledge store and add learning\n    store = load_knowledge(proj.path, project)\n    store.add_learning(learning)\n    save_knowledge(proj.path, store)\n\n    click.echo(f\"\\n\u2713 Stored learning for {module_path}\")\n    click.echo(f\"  Summary: {summary}\")\n    click.echo(f\"  Key functions: {len(key_functions)}\")\n    click.echo(f\"  Gotchas: {len(gotchas)}\")\n    if source_ref:\n        click.echo(f\"  Source tracking: enabled (staleness detection)\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\n@click.option(\"--source\", is_flag=True, help=\"Also show original source code\")\ndef recall(project: str, module_path: str, source: bool):\n    \"\"\"Retrieve what was learned about a module.\n\n    Use this instead of re-reading source code. If no learning\n    exists, you'll be prompted to read and learn.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Load from v2 knowledge store\n    store = load_knowledge(proj.path, project)\n    learning = store.get_learning(module_path)\n\n    if learning:\n        # Format with staleness check\n        click.echo(learning.format_for_context(proj.path))\n\n        if source:\n            click.echo(\"\\n--- Original Source ---\\n\")\n            source_path = os.path.join(proj.path, module_path)\n            if os.path.exists(source_path):\n                with open(source_path) as f:\n                    click.echo(f.read())\n            else:\n                click.echo(f\"Source file not found: {source_path}\")\n    else:\n        click.echo(f\"No learning stored for {module_path}\")\n        click.echo(f\"\\nTo learn this module:\")\n        click.echo(f\"  1. Read the source: cat {os.path.join(proj.path, module_path)}\")\n        click.echo(f\"  2. Store learning: eri-rpg learn {project} {module_path}\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\ndef relearn(project: str, module_path: str):\n    \"\"\"Force re-read a module (removes stored learning).\n\n    Use when the source code has changed significantly.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Load from v2 knowledge store\n    store = load_knowledge(proj.path, project)\n\n    if store.remove_learning(module_path):\n        save_knowledge(proj.path, store)\n        click.echo(f\"\u2713 Removed learning for {module_path}\")\n        click.echo(f\"\\nNow read the source and store new learning:\")\n        click.echo(f\"  eri-rpg learn {project} {module_path}\")\n    else:\n        click.echo(f\"No learning stored for {module_path}\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\ndef history(project: str, module_path: str):\n    \"\"\"Show version history for a module's learning.\n\n    Displays all recorded versions with timestamps, operations,\n    and associated git commits.\n\n    Example:\n        eri-rpg history eritrainer training/optimizer.py\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    store = load_knowledge(proj.path, project)\n    learning = store.get_learning(module_path)\n\n    if not learning:\n        click.echo(f\"No learning found for {module_path}\")\n        return\n\n    click.echo(f\"{'\u2550' * 50}\")\n    click.echo(f\" History: {module_path}\")\n    click.echo(f\"{'\u2550' * 50}\")\n    click.echo(f\"Current version: v{learning.current_version}\")\n    click.echo(\"\")\n\n    if not learning.versions:\n        click.echo(\"No version history available\")\n        click.echo(\"(Versions are created when learnings are modified)\")\n        return\n\n    for v in reversed(learning.versions):\n        marker = \" (current)\" if v.version == learning.current_version else \"\"\n        click.echo(f\"v{v.version}{marker} - {v.timestamp.strftime('%Y-%m-%d %H:%M')} - {v.operation}\")\n        if v.change_description:\n            click.echo(f\"    {v.change_description}\")\n        if v.commit_before:\n            click.echo(f\"    git before: {v.commit_before}\")\n        if v.commit_after:\n            click.echo(f\"    git after: {v.commit_after}\")\n        click.echo(\"\")\n\n    if learning.transplanted_from:\n        click.echo(f\"Transplanted from: {learning.transplanted_from}\")\n\n    if learning.transplanted_to_list:\n        click.echo(f\"Transplanted to: {', '.join(learning.transplanted_to_list)}\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"module_path\")\n@click.option(\"-v\", \"--version\", \"target_version\", type=int, default=None,\n              help=\"Version to rollback to (default: previous)\")\n@click.option(\"--code\", is_flag=True, help=\"Also restore files to disk from snapshot\")\n@click.option(\"--dry-run\", is_flag=True, help=\"Show what would be restored without doing it\")\n@click.option(\"--use-git\", is_flag=True, help=\"Use git checkout instead of stored snapshots\")\ndef rollback(project: str, module_path: str, target_version: int, code: bool, dry_run: bool, use_git: bool):\n    \"\"\"Rollback a module's learning to a previous version.\n\n    Restores the learning's summary, purpose, key_functions, and gotchas\n    to the state they were in at the specified version.\n\n    With --code: Also restores the actual file contents from stored snapshots.\n\n    Example:\n        eri-rpg rollback eritrainer training/optimizer.py\n        eri-rpg rollback eritrainer training/optimizer.py -v 2\n        eri-rpg rollback eritrainer training/optimizer.py --code\n        eri-rpg rollback eritrainer training/optimizer.py --code --dry-run\n        eri-rpg rollback eritrainer training/optimizer.py --code --use-git\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    store = load_knowledge(proj.path, project)\n    learning = store.get_learning(module_path)\n\n    if not learning:\n        click.echo(f\"No learning found for {module_path}\")\n        return\n\n    if not learning.versions:\n        click.echo(\"No version history available\")\n        return\n\n    # Find target version\n    target = target_version if target_version is not None else learning.current_version - 1\n\n    if target < 1:\n        click.echo(\"Already at earliest version (versions start at 1)\")\n        return\n\n    # Find the version by number\n    version_obj = None\n    for v in learning.versions:\n        if v.version == target:\n            version_obj = v\n            break\n\n    if not version_obj:\n        available = [v.version for v in learning.versions]\n        click.echo(f\"Version {target} not found. Available: {available}\")\n        return\n\n    old_version = learning.current_version\n\n    if code:\n        # Restore files to disk\n        if use_git and version_obj.commit_before:\n            # Use git checkout\n            import subprocess\n            if dry_run:\n                click.echo(f\"Would run: git checkout {version_obj.commit_before} -- {module_path}\")\n            else:\n                try:\n                    subprocess.run(\n                        ['git', 'checkout', version_obj.commit_before, '--', module_path],\n                        cwd=proj.path,\n                        check=True,\n                        capture_output=True,\n                    )\n                    click.echo(f\"\u2713 Restored {module_path} from git commit {version_obj.commit_before}\")\n                except subprocess.CalledProcessError as e:\n                    click.echo(f\"Git checkout failed: {e.stderr.decode() if e.stderr else str(e)}\", err=True)\n                    sys.exit(1)\n\n                # Also rollback metadata\n                learning.rollback(target)\n                store.add_learning(learning)\n                save_knowledge(proj.path, store)\n                click.echo(f\"\u2713 Rolled back learning: v{old_version} -> v{target}\")\n\n        elif version_obj.files_content:\n            # Use stored snapshot\n            result = learning.rollback_files(\n                project_path=proj.path,\n                to_version=target,\n                dry_run=dry_run,\n            )\n\n            click.echo(result.format())\n\n            if not dry_run and result.success:\n                store.add_learning(learning)\n                save_knowledge(proj.path, store)\n\n        else:\n            click.echo(f\"No code snapshot available for version {target}.\")\n            if version_obj.commit_before:\n                click.echo(f\"\\nGit commit available. Re-run with --use-git:\")\n                click.echo(f\"  eri-rpg rollback {project} {module_path} -v {target} --code --use-git\")\n            else:\n                click.echo(\"You may need to restore manually from git history.\")\n            sys.exit(1)\n\n    else:\n        # Metadata-only rollback\n        try:\n            learning.rollback(target)\n            store.add_learning(learning)\n            save_knowledge(proj.path, store)\n\n            click.echo(f\"Rolled back {module_path}: v{old_version} -> v{target}\")\n            click.echo(\"\\nNote: Only learning metadata was rolled back.\")\n            click.echo(\"To also restore file contents, use --code flag.\")\n\n            # Show what's available\n            if version_obj.files_content:\n                click.echo(f\"\\n  eri-rpg rollback {project} {module_path} -v {target} --code\")\n            elif version_obj.commit_before:\n                click.echo(f\"\\n  eri-rpg rollback {project} {module_path} -v {target} --code --use-git\")\n\n        except ValueError as e:\n            click.echo(f\"Error: {e}\", err=True)\n            sys.exit(1)\n\n\n@cli.command()\n@click.argument(\"title\")\n@click.option(\"--reason\", \"-r\", required=True, help=\"Why this decision was made\")\n@click.option(\"--affects\", \"-a\", multiple=True, help=\"Module paths affected\")\n@click.option(\"--alt\", multiple=True, help=\"Alternatives considered\")\ndef decide(title: str, reason: str, affects: tuple, alt: tuple):\n    \"\"\"Record an architectural decision.\n\n    Stores important decisions with rationale for future reference.\n\n    Example:\n        eri-rpg decide \"Use PEFT for LoRA\" \\\\\n            -r \"Better maintained than custom implementation\" \\\\\n            -a eritrainer/training/lora.py \\\\\n            --alt \"Custom LoRA\" --alt \"LoRAX\"\n    \"\"\"\n    state = State.load()\n\n    # Get current project from state or ask\n    project = state.current_task.split()[-1] if state.current_task else None\n\n    if not project:\n        click.echo(\"No active project context.\")\n        click.echo(\"Decisions are stored globally in state.\")\n\n    # Create decision ID from title\n    decision_id = title.lower().replace(\" \", \"_\")[:30]\n\n    decision = Decision(\n        id=decision_id,\n        date=datetime.now(),\n        title=title,\n        reason=reason,\n        affects=list(affects),\n        alternatives=list(alt),\n    )\n\n    # Store in state history for now (could also store in graph)\n    state.log(\"decision\", f\"{title}: {reason}\")\n\n    click.echo(f\"\u2713 Recorded decision: {title}\")\n    click.echo(f\"  Reason: {reason}\")\n    if affects:\n        click.echo(f\"  Affects: {', '.join(affects)}\")\n    if alt:\n        click.echo(f\"  Alternatives: {', '.join(alt)}\")\n\n\n@cli.command()\n@click.argument(\"project\")\n@click.argument(\"name\")\n@click.argument(\"description\")\ndef pattern(project: str, name: str, description: str):\n    \"\"\"Store a reusable pattern or gotcha.\n\n    Record patterns you discover for future reference.\n\n    Example:\n        eri-rpg pattern onetrainer local_files_only \\\\\n            \"Always use local_files_only=True with from_pretrained()\"\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    graph.knowledge.add_pattern(name, description)\n    graph.save(proj.graph_path)\n\n    click.echo(f\"\u2713 Stored pattern: {name}\")\n    click.echo(f\"  {description}\")\n\n\n@cli.command(\"patterns\")\n@click.argument(\"project\")\ndef list_patterns(project: str):\n    \"\"\"List all stored patterns for a project.\n\n    Example:\n        eri-rpg patterns myproject\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    patterns = graph.knowledge.patterns\n    if not patterns:\n        click.echo(\"No patterns stored.\")\n        click.echo(f\"\\nAdd one: eri-rpg pattern {project} <name> \\\"<description>\\\"\")\n        return\n\n    click.echo(f\"Patterns for {project}:\")\n    click.echo(\"=\" * 40)\n    for name, desc in sorted(patterns.items()):\n        click.echo(f\"\\n\u2022 {name}\")\n        click.echo(f\"  {desc}\")\n\n\n# ============================================================================\n# Project Metadata Commands\n# ============================================================================\n\n@cli.command(\"describe\")\n@click.argument(\"project\")\n@click.argument(\"description\")\ndef set_description(project: str, description: str):\n    \"\"\"Set project description.\n\n    Example:\n        eri-rpg describe myproject \"ML training toolkit for LoRA/SDXL\"\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    proj.description = description\n    registry.save()\n\n    click.echo(f\"\u2713 Description set for {project}\")\n    click.echo(f\"  {description}\")\n\n\n@cli.command(\"todo\")\n@click.argument(\"project\")\n@click.argument(\"item\", required=False)\n@click.option(\"-l\", \"--list\", \"list_todos\", is_flag=True, help=\"List all todos\")\n@click.option(\"-d\", \"--done\", \"done_index\", type=int, help=\"Mark todo as done by index\")\ndef manage_todos(project: str, item: str, list_todos: bool, done_index: int):\n    \"\"\"Manage project TODOs.\n\n    Examples:\n        eri-rpg todo myproject \"Add config validation\"\n        eri-rpg todo myproject --list\n        eri-rpg todo myproject --done 0\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # List todos\n    if list_todos or (not item and done_index is None):\n        if not proj.todos:\n            click.echo(f\"No TODOs for {project}.\")\n            click.echo(f\"\\nAdd one: eri-rpg todo {project} \\\"<item>\\\"\")\n            return\n\n        click.echo(f\"TODOs for {project}:\")\n        for i, todo in enumerate(proj.todos):\n            click.echo(f\"  [{i}] {todo}\")\n        return\n\n    # Mark as done\n    if done_index is not None:\n        if done_index < 0 or done_index >= len(proj.todos):\n            click.echo(f\"Error: Invalid index {done_index}. Valid: 0-{len(proj.todos)-1}\", err=True)\n            sys.exit(1)\n\n        removed = proj.todos.pop(done_index)\n        registry.save()\n        click.echo(f\"\u2713 Marked done: {removed}\")\n        return\n\n    # Add new todo\n    if item:\n        proj.todos.append(item)\n        registry.save()\n        click.echo(f\"\u2713 Added TODO [{len(proj.todos)-1}]: {item}\")\n\n\n@cli.command(\"notes\")\n@click.argument(\"project\")\n@click.argument(\"note\", required=False)\n@click.option(\"--show\", \"show_notes\", is_flag=True, help=\"Show notes\")\n@click.option(\"--clear\", \"clear_notes\", is_flag=True, help=\"Clear all notes\")\n@click.option(\"--append\", \"append_mode\", is_flag=True, help=\"Append to existing notes\")\ndef manage_notes(project: str, note: str, show_notes: bool, clear_notes: bool, append_mode: bool):\n    \"\"\"Manage project notes.\n\n    Examples:\n        eri-rpg notes myproject \"Needs CUDA 12.1+\"\n        eri-rpg notes myproject --show\n        eri-rpg notes myproject \"Additional info\" --append\n        eri-rpg notes myproject --clear\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Show notes\n    if show_notes or (not note and not clear_notes):\n        if not proj.notes:\n            click.echo(f\"No notes for {project}.\")\n            click.echo(f\"\\nAdd notes: eri-rpg notes {project} \\\"<note>\\\"\")\n            return\n\n        click.echo(f\"Notes for {project}:\")\n        click.echo(\"-\" * 40)\n        click.echo(proj.notes)\n        return\n\n    # Clear notes\n    if clear_notes:\n        proj.notes = \"\"\n        registry.save()\n        click.echo(f\"\u2713 Notes cleared for {project}\")\n        return\n\n    # Set/append notes\n    if note:\n        if append_mode and proj.notes:\n            proj.notes = proj.notes + \"\\n\" + note\n        else:\n            proj.notes = note\n        registry.save()\n        click.echo(f\"\u2713 Notes {'appended' if append_mode else 'set'} for {project}\")\n\n\n@cli.command(\"decision\")\n@click.argument(\"project\")\n@click.argument(\"title\")\n@click.option(\"--reason\", \"-r\", required=True, help=\"Reason for the decision\")\n@click.option(\"--affects\", \"-a\", help=\"Comma-separated list of affected files\")\n@click.option(\"--alternatives\", help=\"Comma-separated list of alternatives considered\")\ndef add_decision(project: str, title: str, reason: str, affects: str, alternatives: str):\n    \"\"\"Record an architectural decision.\n\n    Example:\n        eri-rpg decision myproject \"Use PostgreSQL\" \\\\\n            --reason \"Need concurrent writes\" \\\\\n            --affects \"src/db.py,src/models.py\" \\\\\n            --alternatives \"SQLite,MySQL\"\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    # Parse comma-separated lists\n    affects_list = [a.strip() for a in affects.split(\",\")] if affects else []\n    alternatives_list = [a.strip() for a in alternatives.split(\",\")] if alternatives else []\n\n    # Create decision ID\n    decision_id = f\"dec-{len(graph.knowledge.decisions) + 1:03d}\"\n\n    decision = Decision(\n        id=decision_id,\n        date=datetime.now(),\n        title=title,\n        reason=reason,\n        affects=affects_list,\n        alternatives=alternatives_list,\n    )\n\n    graph.knowledge.add_decision(decision)\n    graph.save(proj.graph_path)\n\n    click.echo(f\"\u2713 Recorded decision: {decision_id}\")\n    click.echo(f\"  Title: {title}\")\n    click.echo(f\"  Reason: {reason}\")\n    if affects_list:\n        click.echo(f\"  Affects: {', '.join(affects_list)}\")\n    if alternatives_list:\n        click.echo(f\"  Alternatives: {', '.join(alternatives_list)}\")\n\n\n@cli.command(\"decisions\")\n@click.argument(\"project\")\ndef list_decisions(project: str):\n    \"\"\"List all architectural decisions for a project.\n\n    Example:\n        eri-rpg decisions myproject\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    decisions = graph.knowledge.decisions\n    if not decisions:\n        click.echo(\"No decisions recorded.\")\n        click.echo(f\"\\nAdd one: eri-rpg decision {project} \\\"<title>\\\" --reason \\\"<why>\\\"\")\n        return\n\n    click.echo(f\"Decisions for {project}:\")\n    click.echo(\"=\" * 50)\n    for d in decisions:\n        age_days = (datetime.now() - d.date).days\n        age_str = \"today\" if age_days == 0 else f\"{age_days}d ago\"\n        click.echo(f\"\\n[{d.id}] {d.title} ({age_str})\")\n        click.echo(f\"  Reason: {d.reason}\")\n        if d.affects:\n            click.echo(f\"  Affects: {', '.join(d.affects)}\")\n        if d.alternatives:\n            click.echo(f\"  Alternatives: {', '.join(d.alternatives)}\")\n\n\n@cli.command()\n@click.argument(\"action\")\n@click.option(\"--feature\", \"-f\", help=\"Feature name\")\n@click.option(\"--from-proj\", help=\"Source project\")\n@click.option(\"--to-path\", help=\"Target path\")\ndef log(action: str, feature: str, from_proj: str, to_path: str):\n    \"\"\"Log an action to project history.\n\n    Records transplants, modifications, and other actions.\n\n    Example:\n        eri-rpg log \"Transplanted masked loss\" \\\\\n            -f masked_loss --from-proj onetrainer \\\\\n            --to-path eritrainer/training/masked_loss.py\n    \"\"\"\n    entry = HistoryEntry(\n        date=datetime.now(),\n        action=\"transplant\" if \"transplant\" in action.lower() else \"modify\",\n        description=action,\n        feature=feature,\n        from_project=from_proj,\n        to_path=to_path,\n    )\n\n    state = State.load()\n    state.log(entry.action, action)\n\n    click.echo(f\"\u2713 Logged: {action}\")\n    if feature:\n        click.echo(f\"  Feature: {feature}\")\n    if from_proj:\n        click.echo(f\"  From: {from_proj}\")\n    if to_path:\n        click.echo(f\"  To: {to_path}\")\n\n\n@cli.command(\"knowledge\")\n@click.argument(\"project\")\ndef show_knowledge(project: str):\n    \"\"\"Show all stored knowledge for a project.\n\n    Displays learnings, patterns, and statistics.\n    \"\"\"\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    try:\n        graph = get_or_load_graph(proj)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    knowledge = graph.knowledge\n    stats = knowledge.stats()\n\n    click.echo(f\"Knowledge for {project}\")\n    click.echo(\"=\" * 40)\n    click.echo(\"\")\n\n    click.echo(f\"Learnings: {stats['learnings']}\")\n    if knowledge.learnings:\n        for path, learning in sorted(knowledge.learnings.items()):\n            age_days = (datetime.now() - learning.learned_at).days\n            age_str = \"today\" if age_days == 0 else f\"{age_days}d ago\"\n            click.echo(f\"  \u2022 {path} ({age_str})\")\n            click.echo(f\"    {learning.summary}\")\n\n    click.echo(\"\")\n    click.echo(f\"Patterns: {stats['patterns']}\")\n    if knowledge.patterns:\n        for name, desc in sorted(knowledge.patterns.items()):\n            click.echo(f\"  \u2022 {name}: {desc[:60]}...\")\n\n    click.echo(\"\")\n    click.echo(f\"History entries: {stats['history_entries']}\")\n    recent = knowledge.get_recent_history(5)\n    if recent:\n        click.echo(\"  Recent:\")\n        for h in recent:\n            click.echo(f\"  \u2022 [{h.date.strftime('%m/%d')}] {h.action}: {h.description[:40]}...\")\n\n    # Token savings estimate\n    if stats['learnings'] > 0:\n        click.echo(\"\")\n        click.echo(\"Token savings estimate:\")\n        # Rough estimate: 500 tokens per learning vs 2000 tokens for source\n        saved = stats['learnings'] * 1500\n        click.echo(f\"  ~{saved:,} tokens saved per context generation\")\n\n\n# ============================================================================\n# Spec Commands\n# ============================================================================\n\n@cli.group()\ndef spec():\n    \"\"\"Spec management commands.\n\n    Specs are first-class inputs that describe tasks, projects, and transplants.\n    They provide a structured way to define work with validation and versioning.\n\n    \\b\n        spec new <type>       - Create spec from template\n        spec validate <path>  - Validate a spec file\n        spec show <path>      - Display spec contents\n        spec list             - List specs in project\n    \"\"\"\n    pass\n\n\n@spec.command(\"new\")\n@click.argument(\"spec_type\", type=click.Choice([\"task\", \"project\", \"transplant\"]))\n@click.option(\"-o\", \"--output\", default=None, help=\"Output path (default: .eri-rpg/specs/)\")\n@click.option(\"--name\", \"-n\", default=None, help=\"Spec name\")\ndef spec_new(spec_type: str, output: str, name: str):\n    \"\"\"Create a new spec from template.\n\n    Creates a spec file with example values that you can edit.\n\n    \\b\n    Examples:\n        eri-rpg spec new task\n        eri-rpg spec new project -n my-app\n        eri-rpg spec new transplant -o ./specs/my-transplant.json\n    \"\"\"\n    from erirpg.specs import get_spec_template, create_spec, SPEC_VERSION\n\n    template = get_spec_template(spec_type)\n\n    if name:\n        template[\"name\"] = name\n\n    # Create the spec to normalize and generate ID\n    spec = create_spec(spec_type, **{k: v for k, v in template.items() if k != \"spec_type\"})\n\n    # Determine output path\n    if output:\n        output_path = output\n    else:\n        # Default to .eri-rpg/specs/ in current directory\n        specs_dir = os.path.join(os.getcwd(), \".eri-rpg\", \"specs\")\n        os.makedirs(specs_dir, exist_ok=True)\n        output_path = os.path.join(specs_dir, f\"{spec.id}.json\")\n\n    spec.save(output_path)\n\n    click.echo(f\"Created {spec_type} spec: {output_path}\")\n    click.echo(\"\")\n    click.echo(\"Edit the file to customize, then validate:\")\n    click.echo(f\"  eri-rpg spec validate {output_path}\")\n\n\n@spec.command(\"validate\")\n@click.argument(\"path\", type=click.Path(exists=True))\ndef spec_validate(path: str):\n    \"\"\"Validate a spec file.\n\n    Checks for required fields and valid values.\n\n    \\b\n    Example:\n        eri-rpg spec validate ./specs/my-task.json\n    \"\"\"\n    from erirpg.specs import load_spec, validate_spec\n\n    try:\n        spec = load_spec(path)\n        is_valid, errors = validate_spec(spec)\n\n        if is_valid:\n            click.echo(f\"\u2713 Valid {spec.spec_type} spec: {spec.id}\")\n            click.echo(f\"  Name: {getattr(spec, 'name', 'N/A')}\")\n            click.echo(f\"  Version: {spec.version}\")\n        else:\n            click.echo(f\"\u2717 Invalid spec: {path}\", err=True)\n            click.echo(\"\")\n            for error in errors:\n                click.echo(f\"  - {error}\", err=True)\n            sys.exit(1)\n\n    except json.JSONDecodeError as e:\n        click.echo(f\"Error: Invalid JSON in {path}\", err=True)\n        click.echo(f\"  {e}\", err=True)\n        sys.exit(1)\n    except Exception as e:\n        click.echo(f\"Error loading spec: {e}\", err=True)\n        sys.exit(1)\n\n\n@spec.command(\"show\")\n@click.argument(\"path\", type=click.Path(exists=True))\n@click.option(\"--json\", \"as_json\", is_flag=True, help=\"Output as JSON\")\ndef spec_show(path: str, as_json: bool):\n    \"\"\"Display spec contents.\n\n    Shows the spec in a readable format.\n\n    \\b\n    Example:\n        eri-rpg spec show ./specs/my-task.json\n        eri-rpg spec show ./specs/my-task.json --json\n    \"\"\"\n    from erirpg.specs import load_spec\n\n    try:\n        spec = load_spec(path)\n\n        if as_json:\n            click.echo(json.dumps(spec.to_dict(), indent=2))\n            return\n\n        # Human-readable format\n        click.echo(f\"Spec: {spec.id}\")\n        click.echo(\"=\" * 50)\n        click.echo(f\"Type: {spec.spec_type}\")\n        click.echo(f\"Version: {spec.version}\")\n        click.echo(f\"Created: {spec.created_at.strftime('%Y-%m-%d %H:%M')}\")\n        click.echo(f\"Updated: {spec.updated_at.strftime('%Y-%m-%d %H:%M')}\")\n        click.echo(\"\")\n\n        # Type-specific fields\n        if spec.spec_type == \"task\":\n            click.echo(f\"Name: {spec.name}\")\n            click.echo(f\"Task Type: {spec.task_type or '(not set)'}\")\n            click.echo(f\"Status: {spec.status}\")\n            click.echo(f\"Priority: {spec.priority}\")\n            if spec.source_project:\n                click.echo(f\"Source: {spec.source_project}\")\n            if spec.target_project:\n                click.echo(f\"Target: {spec.target_project}\")\n            if spec.query:\n                click.echo(f\"Query: {spec.query}\")\n            if spec.description:\n                click.echo(f\"\\nDescription:\\n  {spec.description}\")\n\n        elif spec.spec_type == \"project\":\n            click.echo(f\"Name: {spec.name}\")\n            click.echo(f\"Language: {spec.language}\")\n            if spec.framework:\n                click.echo(f\"Framework: {spec.framework}\")\n            click.echo(f\"Core Feature: {spec.core_feature}\")\n            if spec.output_path:\n                click.echo(f\"Output: {spec.output_path}\")\n            if spec.directories:\n                click.echo(f\"\\nDirectories: {', '.join(spec.directories)}\")\n            if spec.dependencies:\n                click.echo(f\"Dependencies: {', '.join(spec.dependencies)}\")\n\n        elif spec.spec_type == \"transplant\":\n            click.echo(f\"Name: {spec.name}\")\n            click.echo(f\"Source: {spec.source_project}\")\n            click.echo(f\"Target: {spec.target_project}\")\n            click.echo(f\"Feature: {spec.feature_name or '(from file)'}\")\n            if spec.feature_file:\n                click.echo(f\"Feature File: {spec.feature_file}\")\n            if spec.components:\n                click.echo(f\"\\nComponents ({len(spec.components)}):\")\n                for comp in spec.components[:5]:\n                    click.echo(f\"  - {comp}\")\n                if len(spec.components) > 5:\n                    click.echo(f\"  ... and {len(spec.components) - 5} more\")\n\n        # Common fields\n        if spec.tags:\n            click.echo(f\"\\nTags: {', '.join(spec.tags)}\")\n        if spec.notes:\n            click.echo(f\"\\nNotes:\\n  {spec.notes}\")\n\n    except Exception as e:\n        click.echo(f\"Error loading spec: {e}\", err=True)\n        sys.exit(1)\n\n\n@spec.command(\"list\")\n@click.option(\"-t\", \"--type\", \"spec_type\", type=click.Choice([\"task\", \"project\", \"transplant\"]),\n              help=\"Filter by spec type\")\n@click.option(\"-p\", \"--path\", default=None, help=\"Project path (default: current directory)\")\ndef spec_list(spec_type: str, path: str):\n    \"\"\"List specs in a project.\n\n    Shows all specs stored in the project's .eri-rpg/specs/ directory.\n\n    \\b\n    Example:\n        eri-rpg spec list\n        eri-rpg spec list -t task\n        eri-rpg spec list -p /path/to/project\n    \"\"\"\n    from erirpg.specs import list_specs, load_spec\n\n    project_path = path or os.getcwd()\n    specs = list_specs(project_path, spec_type=spec_type)\n\n    if not specs:\n        click.echo(\"No specs found.\")\n        click.echo(f\"\\nCreate one with: eri-rpg spec new <type>\")\n        return\n\n    click.echo(f\"Specs in {project_path}:\")\n    click.echo(\"\")\n\n    for spec_path in specs:\n        try:\n            s = load_spec(spec_path)\n            name = getattr(s, \"name\", s.id)\n            click.echo(f\"  [{s.spec_type}] {name}\")\n            click.echo(f\"    ID: {s.id}\")\n            click.echo(f\"    Path: {spec_path}\")\n        except Exception as e:\n            click.echo(f\"  [error] {spec_path}: {e}\")\n        click.echo(\"\")\n\n\n# ============================================================================\n# Plan Commands\n# ============================================================================\n\n@cli.group(\"plan\")\ndef plan_group():\n    \"\"\"Plan management commands.\n\n    Plans convert specs into executable step-by-step workflows.\n    They track dependencies, risk levels, and progress.\n\n    \\b\n        plan generate <spec>  - Generate plan from spec\n        plan show <plan>      - Display plan contents\n        plan list             - List plans in project\n        plan next <plan>      - Show next step to execute\n    \"\"\"\n    pass\n\n\n@plan_group.command(\"generate\")\n@click.argument(\"spec_path\", type=click.Path(exists=True))\n@click.option(\"-o\", \"--output\", default=None, help=\"Output path (default: .eri-rpg/plans/)\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path for context\")\ndef plan_generate(spec_path: str, output: str, project: str):\n    \"\"\"Generate a plan from a spec.\n\n    Creates an execution plan with ordered steps.\n\n    \\b\n    Example:\n        eri-rpg plan generate ./specs/my-task.json\n        eri-rpg plan generate ./specs/transplant.json -p ./myproject\n    \"\"\"\n    from erirpg.specs import load_spec\n    from erirpg.planner import generate_plan, save_plan_to_project\n\n    try:\n        spec = load_spec(spec_path)\n    except Exception as e:\n        click.echo(f\"Error loading spec: {e}\", err=True)\n        sys.exit(1)\n\n    # Get graph and knowledge if project specified\n    graph = None\n    knowledge = None\n    if project:\n        registry = Registry.get_instance()\n        proj = registry.get(project)\n        if proj:\n            try:\n                graph = get_or_load_graph(proj)\n                knowledge = graph.knowledge if hasattr(graph, 'knowledge') else None\n            except ValueError:\n                pass\n\n    # Generate plan\n    try:\n        plan = generate_plan(spec, graph, knowledge)\n    except Exception as e:\n        click.echo(f\"Error generating plan: {e}\", err=True)\n        sys.exit(1)\n\n    # Save plan\n    if output:\n        plan.save(output)\n        output_path = output\n    else:\n        project_path = project or os.getcwd()\n        output_path = save_plan_to_project(plan, project_path)\n\n    click.echo(f\"Generated plan: {output_path}\")\n    click.echo(\"\")\n    click.echo(plan.format_summary())\n\n\n@plan_group.command(\"show\")\n@click.argument(\"path\", type=click.Path(exists=True))\n@click.option(\"--json\", \"as_json\", is_flag=True, help=\"Output as JSON\")\n@click.option(\"--verbose\", \"-v\", is_flag=True, help=\"Show step details\")\ndef plan_show(path: str, as_json: bool, verbose: bool):\n    \"\"\"Display plan contents.\n\n    Shows the plan with all steps and their status.\n\n    \\b\n    Example:\n        eri-rpg plan show ./plans/my-plan.json\n        eri-rpg plan show ./plans/my-plan.json --verbose\n    \"\"\"\n    from erirpg.planner import Plan\n\n    try:\n        plan = Plan.load(path)\n    except Exception as e:\n        click.echo(f\"Error loading plan: {e}\", err=True)\n        sys.exit(1)\n\n    if as_json:\n        click.echo(json.dumps(plan.to_dict(), indent=2))\n        return\n\n    click.echo(f\"Plan: {plan.name or plan.id}\")\n    click.echo(\"=\" * 50)\n    click.echo(f\"Spec: {plan.spec_id} ({plan.spec_type})\")\n    click.echo(f\"Status: {plan.status}\")\n    click.echo(f\"Created: {plan.created_at.strftime('%Y-%m-%d %H:%M')}\")\n    click.echo(f\"Progress: {plan.completed_steps}/{plan.total_steps} steps\")\n    click.echo(\"\")\n    click.echo(\"Steps:\")\n\n    for step in sorted(plan.steps, key=lambda s: s.order):\n        status_icon = {\n            \"pending\": \"\u25cb\",\n            \"in_progress\": \"\u25d0\",\n            \"completed\": \"\u25cf\",\n            \"failed\": \"\u2717\",\n            \"skipped\": \"\u25cb\",\n        }.get(step.status, \"?\")\n\n        risk_badge = f\" [{step.risk}]\" if step.risk != \"low\" else \"\"\n        click.echo(f\"  {status_icon} {step.order}. [{step.step_type}] {step.action}{risk_badge}\")\n\n        if verbose:\n            if step.details:\n                click.echo(f\"      Details: {step.details}\")\n            if step.depends_on:\n                click.echo(f\"      Depends on: {', '.join(step.depends_on)}\")\n            if step.verify_command:\n                click.echo(f\"      Verify: {step.verify_command}\")\n            if step.error:\n                click.echo(f\"      Error: {step.error}\")\n            click.echo(\"\")\n\n\n@plan_group.command(\"list\")\n@click.option(\"-p\", \"--path\", default=None, help=\"Project path (default: current directory)\")\ndef plan_list(path: str):\n    \"\"\"List plans in a project.\n\n    Shows all plans stored in the project's .eri-rpg/plans/ directory.\n\n    \\b\n    Example:\n        eri-rpg plan list\n        eri-rpg plan list -p /path/to/project\n    \"\"\"\n    from erirpg.planner import list_plans, Plan\n\n    project_path = path or os.getcwd()\n    plans = list_plans(project_path)\n\n    if not plans:\n        click.echo(\"No plans found.\")\n        click.echo(\"\\nGenerate one with: eri-rpg plan generate <spec>\")\n        return\n\n    click.echo(f\"Plans in {project_path}:\")\n    click.echo(\"\")\n\n    for plan_path in plans:\n        try:\n            p = Plan.load(plan_path)\n            status_icon = {\n                \"pending\": \"\u25cb\",\n                \"in_progress\": \"\u25d0\",\n                \"completed\": \"\u25cf\",\n                \"failed\": \"\u2717\",\n            }.get(p.status, \"?\")\n\n            click.echo(f\"  {status_icon} {p.name or p.id}\")\n            click.echo(f\"    Status: {p.status} ({p.completed_steps}/{p.total_steps} steps)\")\n            click.echo(f\"    Path: {plan_path}\")\n        except Exception as e:\n            click.echo(f\"  [error] {plan_path}: {e}\")\n        click.echo(\"\")\n\n\n@plan_group.command(\"next\")\n@click.argument(\"path\", type=click.Path(exists=True))\ndef plan_next(path: str):\n    \"\"\"Show next step to execute.\n\n    Displays the next pending step that can be executed.\n\n    \\b\n    Example:\n        eri-rpg plan next ./plans/my-plan.json\n    \"\"\"\n    from erirpg.planner import Plan\n\n    try:\n        plan = Plan.load(path)\n    except Exception as e:\n        click.echo(f\"Error loading plan: {e}\", err=True)\n        sys.exit(1)\n\n    if plan.status == \"completed\":\n        click.echo(\"Plan is complete!\")\n        return\n\n    if plan.status == \"failed\":\n        # Find failed step\n        for step in plan.steps:\n            if step.status == \"failed\":\n                click.echo(f\"Plan failed at step {step.order}: {step.action}\")\n                click.echo(f\"Error: {step.error}\")\n                return\n\n    next_step = plan.get_next_step()\n\n    if not next_step:\n        click.echo(\"No steps ready to execute.\")\n        click.echo(\"All pending steps may be blocked by incomplete dependencies.\")\n        return\n\n    click.echo(f\"Next step: {next_step.order}. {next_step.action}\")\n    click.echo(\"\")\n    click.echo(f\"Type: {next_step.step_type}\")\n    click.echo(f\"Target: {next_step.target}\")\n    if next_step.details:\n        click.echo(f\"Details: {next_step.details}\")\n    if next_step.risk != \"low\":\n        click.echo(f\"Risk: {next_step.risk} - {next_step.risk_reason}\")\n    if next_step.verify_command:\n        click.echo(f\"Verify with: {next_step.verify_command}\")\n\n    click.echo(\"\")\n    click.echo(f\"To mark complete: eri-rpg plan step {path} {next_step.id} complete\")\n\n\n@plan_group.command(\"step\")\n@click.argument(\"path\", type=click.Path(exists=True))\n@click.argument(\"step_id\")\n@click.argument(\"action\", type=click.Choice([\"start\", \"complete\", \"fail\", \"skip\"]))\n@click.option(\"--error\", default=\"\", help=\"Error message (for fail action)\")\ndef plan_step(path: str, step_id: str, action: str, error: str):\n    \"\"\"Update step status.\n\n    Mark a step as started, completed, failed, or skipped.\n\n    \\b\n    Example:\n        eri-rpg plan step ./plan.json step-00-abc123 start\n        eri-rpg plan step ./plan.json step-00-abc123 complete\n        eri-rpg plan step ./plan.json step-00-abc123 fail --error \"Import error\"\n    \"\"\"\n    from erirpg.planner import Plan\n\n    try:\n        plan = Plan.load(path)\n    except Exception as e:\n        click.echo(f\"Error loading plan: {e}\", err=True)\n        sys.exit(1)\n\n    step = plan.get_step(step_id)\n    if not step:\n        click.echo(f\"Step not found: {step_id}\", err=True)\n        sys.exit(1)\n\n    if action == \"start\":\n        step.mark_in_progress()\n        click.echo(f\"Started: {step.action}\")\n    elif action == \"complete\":\n        step.mark_completed()\n        click.echo(f\"Completed: {step.action}\")\n    elif action == \"fail\":\n        step.mark_failed(error or \"Unknown error\")\n        click.echo(f\"Failed: {step.action}\")\n    elif action == \"skip\":\n        step.mark_skipped()\n        click.echo(f\"Skipped: {step.action}\")\n\n    plan.update_stats()\n    plan.save(path)\n\n    click.echo(f\"\\nPlan progress: {plan.completed_steps}/{plan.total_steps} steps\")\n    if plan.status == \"completed\":\n        click.echo(\"Plan complete!\")\n\n\n# ============================================================================\n# Run Commands\n# ============================================================================\n\n@cli.group(\"run\")\ndef run_group():\n    \"\"\"Run management commands.\n\n    Runs execute plans step-by-step with pause/resume support.\n\n    \\b\n        run start <plan>   - Start executing a plan\n        run resume <run>   - Resume a paused run\n        run list           - List all runs\n        run show <run>     - Show run details\n        run report <run>   - Generate run report\n    \"\"\"\n    pass\n\n\n@run_group.command(\"start\")\n@click.argument(\"plan_path\", type=click.Path(exists=True))\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\ndef run_start(plan_path: str, project: str):\n    \"\"\"Start executing a plan.\n\n    Creates a new run and shows the first step to execute.\n\n    \\b\n    Example:\n        eri-rpg run start ./plans/my-plan.json\n    \"\"\"\n    from erirpg.planner import Plan\n    from erirpg.runner import Runner\n\n    project_path = project or os.getcwd()\n\n    try:\n        plan = Plan.load(plan_path)\n    except Exception as e:\n        click.echo(f\"Error loading plan: {e}\", err=True)\n        sys.exit(1)\n\n    runner = Runner(plan, project_path)\n    run = runner.start()\n\n    click.echo(f\"Started run: {run.id}\")\n    click.echo(f\"Plan: {plan.name or plan.id}\")\n    click.echo(\"\")\n\n    next_step = runner.get_next_step()\n    if next_step:\n        ctx = runner.prepare_step(next_step)\n        click.echo(f\"First step: {next_step.action}\")\n        click.echo(f\"Context: {ctx.context_file}\")\n        click.echo(\"\")\n        click.echo(\"Give the context to Claude, then mark complete:\")\n        click.echo(f\"  eri-rpg run step {run.id} {next_step.id} complete\")\n    else:\n        click.echo(\"No steps to execute.\")\n\n\n@run_group.command(\"resume\")\n@click.argument(\"run_id\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\ndef run_resume(run_id: str, project: str):\n    \"\"\"Resume a paused run.\n\n    Continues from where the run left off.\n\n    \\b\n    Example:\n        eri-rpg run resume run-my-plan-20240101-120000\n    \"\"\"\n    from erirpg.runner import Runner\n\n    project_path = project or os.getcwd()\n\n    try:\n        runner = Runner.resume(run_id, project_path)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    click.echo(f\"Resumed run: {run_id}\")\n    progress = runner.get_progress()\n    click.echo(f\"Progress: {progress['completed_steps']}/{progress['total_steps']} steps\")\n    click.echo(\"\")\n\n    next_step = runner.get_next_step()\n    if next_step:\n        ctx = runner.prepare_step(next_step)\n        click.echo(f\"Next step: {next_step.action}\")\n        click.echo(f\"Context: {ctx.context_file}\")\n    elif progress['status'] == 'completed':\n        click.echo(\"Run is complete!\")\n    elif progress['status'] == 'failed':\n        click.echo(\"Run has failed. Check the report for details.\")\n    else:\n        click.echo(\"No steps ready to execute.\")\n\n\n@run_group.command(\"list\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"-n\", \"--limit\", default=10, help=\"Max runs to show\")\ndef run_list_cmd(project: str, limit: int):\n    \"\"\"List all runs in a project.\n\n    \\b\n    Example:\n        eri-rpg run list\n        eri-rpg run list -n 5\n    \"\"\"\n    from erirpg.runner import list_runs\n\n    project_path = project or os.getcwd()\n    runs = list_runs(project_path)\n\n    if not runs:\n        click.echo(\"No runs found.\")\n        click.echo(\"\\nStart one with: eri-rpg run start <plan>\")\n        return\n\n    click.echo(f\"Runs in {project_path}:\")\n    click.echo(\"\")\n\n    for run in runs[:limit]:\n        status_icon = {\n            \"pending\": \"\u25cb\",\n            \"in_progress\": \"\u25d0\",\n            \"paused\": \"\u23f8\",\n            \"completed\": \"\u25cf\",\n            \"failed\": \"\u2717\",\n            \"cancelled\": \"\u25cb\",\n        }.get(run.status, \"?\")\n\n        click.echo(f\"  {status_icon} {run.id}\")\n        click.echo(f\"    Plan: {run.plan_id}\")\n        click.echo(f\"    Status: {run.status} ({run.completed_steps} steps done)\")\n        click.echo(f\"    Started: {run.started_at.strftime('%Y-%m-%d %H:%M')}\")\n        click.echo(\"\")\n\n    if len(runs) > limit:\n        click.echo(f\"  ... and {len(runs) - limit} more\")\n\n\n@run_group.command(\"show\")\n@click.argument(\"run_id\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"--json\", \"as_json\", is_flag=True, help=\"Output as JSON\")\ndef run_show(run_id: str, project: str, as_json: bool):\n    \"\"\"Show run details.\n\n    \\b\n    Example:\n        eri-rpg run show run-my-plan-20240101-120000\n    \"\"\"\n    from erirpg.runs import load_run\n\n    project_path = project or os.getcwd()\n    run = load_run(project_path, run_id)\n\n    if not run:\n        click.echo(f\"Run not found: {run_id}\", err=True)\n        sys.exit(1)\n\n    if as_json:\n        click.echo(json.dumps(run.to_dict(), indent=2))\n        return\n\n    click.echo(run.format_summary())\n    click.echo(\"\")\n\n    if run.step_results:\n        click.echo(\"Step Results:\")\n        for result in run.step_results:\n            status_icon = {\n                \"pending\": \"\u25cb\",\n                \"in_progress\": \"\u25d0\",\n                \"completed\": \"\u25cf\",\n                \"failed\": \"\u2717\",\n                \"skipped\": \"\u25cb\",\n            }.get(result.status, \"?\")\n\n            click.echo(f\"  {status_icon} {result.step_id}: {result.status}\")\n            if result.error:\n                click.echo(f\"      Error: {result.error}\")\n            if result.duration:\n                click.echo(f\"      Duration: {result.duration:.1f}s\")\n\n\n@run_group.command(\"report\")\n@click.argument(\"run_id\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"-o\", \"--output\", default=None, help=\"Output file path\")\ndef run_report(run_id: str, project: str, output: str):\n    \"\"\"Generate a run report.\n\n    \\b\n    Example:\n        eri-rpg run report run-my-plan-20240101-120000\n        eri-rpg run report run-my-plan-20240101-120000 -o report.md\n    \"\"\"\n    from erirpg.runner import Runner\n\n    project_path = project or os.getcwd()\n\n    try:\n        runner = Runner.resume(run_id, project_path)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    report = runner.get_report()\n\n    if output:\n        with open(output, \"w\") as f:\n            f.write(report)\n        click.echo(f\"Report saved to: {output}\")\n    else:\n        click.echo(report)\n\n\n@run_group.command(\"step\")\n@click.argument(\"run_id\")\n@click.argument(\"step_id\")\n@click.argument(\"action\", type=click.Choice([\"start\", \"complete\", \"fail\", \"skip\"]))\n@click.option(\"--error\", default=\"\", help=\"Error message (for fail action)\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\ndef run_step(run_id: str, step_id: str, action: str, error: str, project: str):\n    \"\"\"Update step status in a run.\n\n    \\b\n    Example:\n        eri-rpg run step run-xxx step-00-abc start\n        eri-rpg run step run-xxx step-00-abc complete\n        eri-rpg run step run-xxx step-00-abc fail --error \"Import failed\"\n    \"\"\"\n    from erirpg.runner import Runner\n\n    project_path = project or os.getcwd()\n\n    try:\n        runner = Runner.resume(run_id, project_path)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n    step = runner.plan.get_step(step_id)\n    if not step:\n        click.echo(f\"Step not found: {step_id}\", err=True)\n        sys.exit(1)\n\n    if action == \"start\":\n        runner.mark_step_started(step)\n        click.echo(f\"Started: {step.action}\")\n    elif action == \"complete\":\n        runner.mark_step_completed(step)\n        click.echo(f\"Completed: {step.action}\")\n    elif action == \"fail\":\n        runner.mark_step_failed(step, error or \"Unknown error\")\n        click.echo(f\"Failed: {step.action}\")\n    elif action == \"skip\":\n        runner.mark_step_skipped(step)\n        click.echo(f\"Skipped: {step.action}\")\n\n    progress = runner.get_progress()\n    click.echo(f\"\\nProgress: {progress['completed_steps']}/{progress['total_steps']} steps\")\n\n    if progress['status'] == 'completed':\n        click.echo(\"Run complete!\")\n    else:\n        next_step = runner.get_next_step()\n        if next_step:\n            click.echo(f\"\\nNext step: {next_step.action}\")\n\n\n# ============================================================================\n# Memory Commands (v2 storage system)\n# ============================================================================\n\n@cli.group()\ndef memory():\n    \"\"\"Memory management commands (v2 storage).\n\n    The v2 memory system stores knowledge in a separate knowledge.json\n    file that survives reindexing. Commands:\n\n    \\b\n        memory status    - Show memory stats and staleness\n        memory search    - Search learnings by keyword\n        memory stale     - List stale learnings\n        memory refresh   - Update stale learning\n        memory migrate   - Migrate v1 knowledge to v2\n    \"\"\"\n    pass\n\n\n@memory.command(\"status\")\n@click.argument(\"project\")\ndef memory_status(project: str):\n    \"\"\"Show memory status for a project.\n\n    Displays v2 knowledge store stats, staleness info, and health metrics.\n    \"\"\"\n    from erirpg.memory import load_knowledge, get_knowledge_path\n    from erirpg.migration import get_migration_status\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Get migration status\n    migration = get_migration_status(proj.path)\n\n    click.echo(f\"Memory Status for {project}\")\n    click.echo(\"=\" * 40)\n    click.echo(\"\")\n\n    # Storage info\n    click.echo(\"Storage:\")\n    click.echo(f\"  graph.json: {'exists' if migration['graph_exists'] else 'missing'}\")\n    click.echo(f\"  knowledge.json: {'exists' if migration['knowledge_exists'] else 'missing'}\")\n\n    if migration['has_embedded_knowledge']:\n        click.echo(\"\")\n        click.echo(\"WARNING: v1 knowledge embedded in graph.json\")\n        click.echo(f\"  Embedded learnings: {migration['embedded_learnings']}\")\n        click.echo(f\"  Run: eri-rpg memory migrate {project}\")\n\n    # v2 knowledge stats\n    if migration['knowledge_exists']:\n        knowledge_path = get_knowledge_path(proj.path)\n        store = load_knowledge(proj.path, project)\n        stats = store.stats()\n\n        click.echo(\"\")\n        click.echo(\"v2 Knowledge Store:\")\n        click.echo(f\"  Learnings: {stats['learnings']}\")\n        click.echo(f\"  Decisions: {stats['decisions']}\")\n        click.echo(f\"  Patterns: {stats['patterns']}\")\n        click.echo(f\"  Runs tracked: {stats['runs']}\")\n\n        # Staleness check\n        stale = store.get_stale_learnings(proj.path)\n        fresh = store.get_fresh_learnings(proj.path)\n\n        click.echo(\"\")\n        click.echo(\"Staleness:\")\n        click.echo(f\"  Fresh: {len(fresh)}\")\n        click.echo(f\"  Stale: {len(stale)}\")\n\n        if stale:\n            click.echo(\"\")\n            click.echo(\"Stale learnings need refresh:\")\n            for path in stale[:5]:\n                click.echo(f\"  - {path}\")\n            if len(stale) > 5:\n                click.echo(f\"  ... and {len(stale) - 5} more\")\n            click.echo(f\"\\nRun: eri-rpg memory stale {project}\")\n\n        # Health score\n        total = stats['learnings']\n        if total > 0:\n            health = (len(fresh) / total) * 100\n            click.echo(\"\")\n            click.echo(f\"Health Score: {health:.0f}%\")\n    else:\n        click.echo(\"\")\n        click.echo(\"No v2 knowledge store yet.\")\n        click.echo(f\"Create learnings with: eri-rpg learn {project} <module>\")\n\n\n@memory.command(\"search\")\n@click.argument(\"project\")\n@click.argument(\"query\")\n@click.option(\"-n\", \"--limit\", default=10, help=\"Max results\")\ndef memory_search(project: str, query: str, limit: int):\n    \"\"\"Search learnings by keyword.\n\n    Searches summaries, purposes, functions, and gotchas.\n    \"\"\"\n    from erirpg.memory import load_knowledge, get_knowledge_path\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    knowledge_path = get_knowledge_path(proj.path)\n    if not os.path.exists(knowledge_path):\n        click.echo(f\"No knowledge.json found for {project}\")\n        click.echo(f\"Create learnings first: eri-rpg learn {project} <module>\")\n        return\n\n    store = load_knowledge(proj.path, project)\n    results = store.search(query, limit=limit)\n\n    if not results:\n        click.echo(f\"No learnings match: {query}\")\n        return\n\n    click.echo(f\"Search results for '{query}':\")\n    click.echo(\"\")\n\n    for path, learning, score in results:\n        is_stale = learning.is_stale(proj.path)\n        stale_marker = \" [STALE]\" if is_stale else \"\"\n        click.echo(f\"  {path} (score: {score:.2f}){stale_marker}\")\n        click.echo(f\"    {learning.summary}\")\n        click.echo(\"\")\n\n\n@memory.command(\"stale\")\n@click.argument(\"project\")\ndef memory_stale(project: str):\n    \"\"\"List all stale learnings.\n\n    Shows learnings whose source files have changed since\n    the learning was created.\n    \"\"\"\n    from erirpg.memory import load_knowledge, get_knowledge_path\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    knowledge_path = get_knowledge_path(proj.path)\n    if not os.path.exists(knowledge_path):\n        click.echo(f\"No knowledge.json found for {project}\")\n        return\n\n    store = load_knowledge(proj.path, project)\n    stale = store.get_stale_learnings(proj.path)\n\n    if not stale:\n        click.echo(f\"All learnings are fresh!\")\n        return\n\n    click.echo(f\"Stale learnings in {project}:\")\n    click.echo(\"\")\n\n    for path in stale:\n        learning = store.get_learning(path)\n        if learning:\n            age_days = (datetime.now() - learning.learned_at).days\n            click.echo(f\"  {path}\")\n            click.echo(f\"    Learned: {age_days} days ago\")\n            click.echo(f\"    Summary: {learning.summary}\")\n            click.echo(\"\")\n\n    click.echo(\"To refresh a learning:\")\n    click.echo(f\"  eri-rpg memory refresh {project} <module_path>\")\n    click.echo(\"\")\n    click.echo(\"Or re-learn from scratch:\")\n    click.echo(f\"  eri-rpg relearn {project} <module_path>\")\n\n\n@memory.command(\"refresh\")\n@click.argument(\"project\")\n@click.argument(\"module_path\")\ndef memory_refresh(project: str, module_path: str):\n    \"\"\"Refresh a stale learning.\n\n    Updates the CodeRef to current file state without changing\n    the learning content. Use 'relearn' if content changed.\n    \"\"\"\n    from erirpg.memory import load_knowledge, save_knowledge, get_knowledge_path\n    from erirpg.refs import CodeRef\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    knowledge_path = get_knowledge_path(proj.path)\n    if not os.path.exists(knowledge_path):\n        click.echo(f\"No knowledge.json found for {project}\")\n        sys.exit(1)\n\n    store = load_knowledge(proj.path, project)\n    learning = store.get_learning(module_path)\n\n    if not learning:\n        click.echo(f\"No learning found for: {module_path}\")\n        sys.exit(1)\n\n    # Check if source file exists\n    file_path = os.path.join(proj.path, module_path)\n    if not os.path.exists(file_path):\n        click.echo(f\"Source file no longer exists: {module_path}\")\n        click.echo(\"Consider removing this learning or updating the path.\")\n        sys.exit(1)\n\n    # Check if actually stale\n    if not learning.is_stale(proj.path):\n        click.echo(f\"Learning is not stale: {module_path}\")\n        return\n\n    # Create new CodeRef with current file state\n    try:\n        new_ref = CodeRef.from_file(proj.path, module_path)\n        learning.source_ref = new_ref\n        learning.version += 1\n        store.add_learning(learning)\n        save_knowledge(proj.path, store)\n\n        click.echo(f\"Refreshed learning: {module_path}\")\n        click.echo(f\"  New version: {learning.version}\")\n        click.echo(\"\")\n        click.echo(\"Note: Only the CodeRef was updated. If the code logic changed,\")\n        click.echo(f\"consider re-learning: eri-rpg relearn {project} {module_path}\")\n    except Exception as e:\n        click.echo(f\"Error refreshing: {e}\", err=True)\n        sys.exit(1)\n\n\n@memory.command(\"migrate\")\n@click.argument(\"project\")\n@click.option(\"--force\", is_flag=True, help=\"Force migration even if knowledge.json exists\")\ndef memory_migrate(project: str, force: bool):\n    \"\"\"Migrate v1 knowledge to v2 format.\n\n    Extracts knowledge from graph.json into separate knowledge.json\n    and creates CodeRefs for learnings.\n    \"\"\"\n    from erirpg.migration import (\n        check_migration_needed,\n        migrate_knowledge,\n        get_migration_status,\n    )\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Check migration status\n    status = get_migration_status(proj.path)\n\n    if not status['has_embedded_knowledge']:\n        click.echo(\"No v1 knowledge to migrate.\")\n        return\n\n    if status['knowledge_exists'] and not force:\n        click.echo(\"knowledge.json already exists.\")\n        click.echo(\"Use --force to overwrite.\")\n        return\n\n    # Perform migration\n    click.echo(f\"Migrating knowledge for {project}...\")\n\n    result = migrate_knowledge(proj.path, project)\n\n    if result['migrated']:\n        click.echo(\"\")\n        click.echo(\"Migration complete:\")\n        click.echo(f\"  Learnings: {result['learnings']}\")\n        click.echo(f\"  Decisions: {result['decisions']}\")\n        click.echo(f\"  Patterns: {result['patterns']}\")\n        click.echo(f\"  CodeRefs created: {result['refs_created']}\")\n        if result['refs_failed'] > 0:\n            click.echo(f\"  CodeRefs failed (files missing): {result['refs_failed']}\")\n        click.echo(\"\")\n        click.echo(\"Knowledge now stored in knowledge.json (survives reindex)\")\n    else:\n        click.echo(f\"Migration failed: {result['error']}\", err=True)\n        sys.exit(1)\n\n\n# ============================================================================\n# Verification Commands\n# ============================================================================\n\n@cli.group(\"verify\")\ndef verify_group():\n    \"\"\"Verification commands.\n\n    Run lint, test, and other validation commands to ensure code quality.\n\n    \\b\n        verify run <run_id>       - Run verification for a run\n        verify config             - Show/create verification config\n        verify results <run_id>   - Show verification results\n    \"\"\"\n    pass\n\n\n@verify_group.command(\"run\")\n@click.argument(\"run_id\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"--step\", default=None, help=\"Run for specific step only\")\ndef verify_run(run_id: str, project: str, step: str):\n    \"\"\"Run verification commands for a run.\n\n    Executes all configured verification commands and saves results.\n\n    \\b\n    Example:\n        eri-rpg verify run run-my-plan-20240101-120000\n        eri-rpg verify run run-xxx --step step-00-abc\n    \"\"\"\n    from erirpg.runs import load_run\n    from erirpg.verification import (\n        Verifier,\n        load_verification_config,\n        save_verification_result,\n        VerificationConfig,\n    )\n\n    project_path = project or os.getcwd()\n    run = load_run(project_path, run_id)\n\n    if not run:\n        click.echo(f\"Run not found: {run_id}\", err=True)\n        sys.exit(1)\n\n    # Load config\n    config = load_verification_config(project_path)\n    if not config:\n        click.echo(\"No verification config found.\", err=True)\n        click.echo(\"Create one with: eri-rpg verify config --init\")\n        sys.exit(1)\n\n    verifier = Verifier(config, project_path)\n\n    if step:\n        # Run for single step\n        result = verifier.run_verification(step)\n        save_verification_result(project_path, run_id, result)\n        click.echo(result.format_report())\n    else:\n        # Run for all steps\n        click.echo(f\"Running verification for {len(run.step_results)} steps...\")\n        click.echo(\"\")\n\n        for step_result in run.step_results:\n            if step_result.status == \"completed\":\n                click.echo(f\"Verifying: {step_result.step_id}\")\n                result = verifier.run_verification(step_result.step_id)\n                save_verification_result(project_path, run_id, result)\n\n                if result.passed:\n                    click.echo(f\"  \u2713 Passed\")\n                else:\n                    click.echo(f\"  \u2717 Failed\")\n                    for cmd_result in result.failed_commands:\n                        click.echo(f\"    - {cmd_result.name}: exit {cmd_result.exit_code}\")\n\n        click.echo(\"\")\n        click.echo(\"Verification complete.\")\n\n\n@verify_group.command(\"config\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"--init\", \"init_config\", is_flag=True, help=\"Create default config\")\n@click.option(\"--type\", \"project_type\", type=click.Choice([\"python\", \"node\"]), default=\"python\", help=\"Project type for default config\")\ndef verify_config(project: str, init_config: bool, project_type: str):\n    \"\"\"Show or create verification config.\n\n    \\b\n    Example:\n        eri-rpg verify config              # Show current config\n        eri-rpg verify config --init       # Create default Python config\n        eri-rpg verify config --init --type node  # Create Node.js config\n    \"\"\"\n    from erirpg.verification import (\n        load_verification_config,\n        save_verification_config,\n        get_default_python_config,\n        get_default_node_config,\n    )\n\n    project_path = project or os.getcwd()\n\n    if init_config:\n        if project_type == \"python\":\n            config = get_default_python_config()\n        else:\n            config = get_default_node_config()\n\n        path = save_verification_config(project_path, config)\n        click.echo(f\"Created verification config: {path}\")\n        click.echo(\"\")\n        click.echo(\"Commands:\")\n        for cmd in config.commands:\n            req = \"required\" if cmd.required else \"optional\"\n            click.echo(f\"  {cmd.name}: {cmd.command} ({req})\")\n        return\n\n    config = load_verification_config(project_path)\n    if not config:\n        click.echo(\"No verification config found.\")\n        click.echo(\"Create one with: eri-rpg verify config --init\")\n        return\n\n    click.echo(\"Verification Config\")\n    click.echo(\"=\" * 40)\n    click.echo(f\"Run after each step: {config.run_after_each_step}\")\n    click.echo(f\"Run at checkpoints: {config.run_at_checkpoints}\")\n    click.echo(f\"Stop on failure: {config.stop_on_failure}\")\n    click.echo(\"\")\n    click.echo(\"Commands:\")\n    for cmd in config.commands:\n        req = \"required\" if cmd.required else \"optional\"\n        click.echo(f\"  {cmd.name}: {cmd.command} ({req})\")\n        if cmd.run_on:\n            click.echo(f\"    Only on: {', '.join(cmd.run_on)}\")\n\n\n@verify_group.command(\"results\")\n@click.argument(\"run_id\")\n@click.option(\"-p\", \"--project\", default=None, help=\"Project path\")\n@click.option(\"--step\", default=None, help=\"Show results for specific step\")\n@click.option(\"--json\", \"as_json\", is_flag=True, help=\"Output as JSON\")\ndef verify_results(run_id: str, project: str, step: str, as_json: bool):\n    \"\"\"Show verification results for a run.\n\n    \\b\n    Example:\n        eri-rpg verify results run-my-plan-20240101-120000\n        eri-rpg verify results run-xxx --step step-00-abc\n    \"\"\"\n    from erirpg.verification import (\n        list_verification_results,\n        load_verification_result,\n        format_verification_summary,\n    )\n\n    project_path = project or os.getcwd()\n\n    if step:\n        result = load_verification_result(project_path, run_id, step)\n        if not result:\n            click.echo(f\"No verification result for step: {step}\", err=True)\n            sys.exit(1)\n\n        if as_json:\n            click.echo(json.dumps(result.to_dict(), indent=2))\n        else:\n            click.echo(result.format_report())\n    else:\n        results = list_verification_results(project_path, run_id)\n\n        if not results:\n            click.echo(\"No verification results found.\")\n            click.echo(f\"Run verification with: eri-rpg verify run {run_id}\")\n            return\n\n        if as_json:\n            click.echo(json.dumps([r.to_dict() for r in results], indent=2))\n        else:\n            click.echo(format_verification_summary(results))\n\n\n# ============================================================================\n# Spec-Driven Execution Commands (NEW)\n# ============================================================================\n\n@cli.command(\"goal-plan\")\n@click.argument(\"project\")\n@click.argument(\"goal\")\n@click.option(\"-o\", \"--output\", default=None, help=\"Output spec file path\")\ndef goal_plan(project: str, goal: str, output: str):\n    \"\"\"Generate a spec from a goal.\n\n    Creates a structured spec with ordered steps from a natural language goal.\n    This is the entry point for spec-driven execution.\n\n    \\b\n    Example:\n        eri-rpg goal-plan eritrainer \"add logging to config.py\"\n        eri-rpg goal-plan myproject \"refactor auth module\" -o spec.yaml\n    \"\"\"\n    from erirpg.spec import Spec\n    from erirpg.planner import Planner\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        click.echo(f\"\\nAdd it first: eri-rpg add {project} /path/to/project\")\n        sys.exit(1)\n\n    # Load graph and knowledge for intelligent planning\n    graph = None\n    knowledge = None\n    try:\n        graph = get_or_load_graph(proj)\n    except Exception:\n        pass\n\n    try:\n        knowledge = load_knowledge(proj.path, project)\n    except Exception:\n        pass\n\n    # Generate spec\n    planner = Planner(project, graph, knowledge)\n    spec = planner.plan(goal)\n\n    # Save spec\n    if output:\n        spec_path = output\n    else:\n        spec_dir = os.path.join(proj.path, \".eri-rpg\", \"specs\")\n        os.makedirs(spec_dir, exist_ok=True)\n        spec_path = os.path.join(spec_dir, f\"{spec.id}.yaml\")\n\n    spec.save(spec_path)\n\n    click.echo(f\"Generated spec: {spec_path}\")\n    click.echo(\"\")\n    click.echo(spec.format_status())\n    click.echo(\"\")\n    click.echo(f\"Execute with: eri-rpg goal-run {project}\")\n\n\n@cli.command(\"goal-run\")\n@click.argument(\"project\")\n@click.option(\"--spec\", \"spec_path\", default=None, help=\"Specific spec file to run\")\n@click.option(\"--resume\", \"resume_run\", is_flag=True, help=\"Resume incomplete run\")\ndef goal_run(project: str, spec_path: str, resume_run: bool):\n    \"\"\"Execute a spec for a project.\n\n    Runs the latest spec (or specified spec) step by step.\n    Agent refuses to proceed if verification fails.\n\n    \\b\n    Example:\n        eri-rpg goal-run eritrainer\n        eri-rpg goal-run myproject --spec ./spec.yaml\n        eri-rpg goal-run myproject --resume\n    \"\"\"\n    from erirpg.spec import Spec\n    from erirpg.agent import Agent\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Check for resume\n    if resume_run:\n        agent = Agent.resume(proj.path)\n        if agent:\n            click.echo(f\"Resumed run: {agent._run.id if agent._run else 'unknown'}\")\n            click.echo(\"\")\n            click.echo(agent.get_spec_status())\n            return\n        else:\n            click.echo(\"No incomplete run to resume.\")\n\n    # Load spec\n    if spec_path:\n        spec = Spec.load(spec_path)\n    else:\n        # Find latest spec\n        spec_dir = os.path.join(proj.path, \".eri-rpg\", \"specs\")\n        if not os.path.exists(spec_dir):\n            click.echo(\"No specs found.\")\n            click.echo(f\"\\nGenerate one: eri-rpg goal-plan {project} \\\"<goal>\\\"\")\n            sys.exit(1)\n\n        specs = sorted([\n            os.path.join(spec_dir, f)\n            for f in os.listdir(spec_dir)\n            if f.endswith(\".yaml\")\n        ], key=os.path.getmtime, reverse=True)\n\n        if not specs:\n            click.echo(\"No specs found.\")\n            click.echo(f\"\\nGenerate one: eri-rpg goal-plan {project} \\\"<goal>\\\"\")\n            sys.exit(1)\n\n        spec = Spec.load(specs[0])\n        click.echo(f\"Using latest spec: {specs[0]}\")\n        click.echo(\"\")\n\n    # Create agent from spec\n    agent = Agent.from_new_spec(spec, proj.path)\n\n    click.echo(f\"Started run: {agent._run.id if agent._run else 'new'}\")\n    click.echo(\"\")\n    click.echo(agent.get_spec_status())\n    click.echo(\"\")\n    click.echo(\"Use the Agent API in Claude Code:\")\n    click.echo(\"  agent = Agent.resume(project_path)\")\n    click.echo(\"  step = agent.next_step()\")\n    click.echo(\"  # Execute step\")\n    click.echo(\"  if agent.verify_step():\")\n    click.echo(\"      agent.complete_step()\")\n\n\n@cli.command(\"goal-status\")\n@click.argument(\"project\")\ndef goal_status(project: str):\n    \"\"\"Show spec execution status for a project.\n\n    Displays progress, current step, and any blockers.\n\n    \\b\n    Example:\n        eri-rpg goal-status eritrainer\n    \"\"\"\n    from erirpg.agent import Agent\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    # Try to resume existing run\n    agent = Agent.resume(proj.path)\n\n    if not agent:\n        click.echo(f\"No active run for {project}.\")\n        click.echo(\"\")\n\n        # Check for specs\n        spec_dir = os.path.join(proj.path, \".eri-rpg\", \"specs\")\n        if os.path.exists(spec_dir):\n            specs = [f for f in os.listdir(spec_dir) if f.endswith(\".yaml\")]\n            if specs:\n                click.echo(f\"Found {len(specs)} spec(s).\")\n                click.echo(f\"Start with: eri-rpg goal-run {project}\")\n            else:\n                click.echo(f\"Generate a spec: eri-rpg goal-plan {project} \\\"<goal>\\\"\")\n        else:\n            click.echo(f\"Generate a spec: eri-rpg goal-plan {project} \\\"<goal>\\\"\")\n        return\n\n    click.echo(agent.get_spec_status())\n\n\n# ============================================================================\n# Quick Fix Commands (Lightweight Mode)\n# ============================================================================\n\n@cli.command(\"quick\")\n@click.argument(\"project\")\n@click.argument(\"file_path\")\n@click.argument(\"description\")\n@click.option(\"--no-commit\", is_flag=True, help=\"Don't auto-commit after edit\")\n@click.option(\"--dry-run\", is_flag=True, help=\"Show what would happen without doing it\")\ndef quick_cmd(project: str, file_path: str, description: str, no_commit: bool, dry_run: bool):\n    \"\"\"Start a quick fix on a single file.\n\n    Lightweight mode for simple, focused changes without full spec ceremony.\n    No run state, no steps - just snapshot, edit, commit.\n\n    \\b\n    Examples:\n        eri-rpg quick myproject src/utils.py \"Fix off-by-one error\"\n        eri-rpg quick eritrainer train.py \"Add debug logging\"\n\n    After editing, complete with: eri-rpg quick-done <project>\n    Or cancel with: eri-rpg quick-cancel <project>\n    \"\"\"\n    from erirpg.quick import quick_fix\n\n    try:\n        result = quick_fix(\n            project=project,\n            file_path=file_path,\n            description=description,\n            auto_commit=not no_commit,\n            dry_run=dry_run,\n        )\n        if result == \"ready\":\n            click.echo(\"\")\n            click.echo(\"Now edit the file. When done:\")\n            click.echo(f\"  eri-rpg quick-done {project}\")\n            click.echo(\"\")\n            click.echo(\"To cancel and restore:\")\n            click.echo(f\"  eri-rpg quick-cancel {project}\")\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n    except FileNotFoundError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n@cli.command(\"quick-done\")\n@click.argument(\"project\")\n@click.option(\"--no-commit\", is_flag=True, help=\"Don't commit changes\")\n@click.option(\"-m\", \"--message\", default=None, help=\"Custom commit message\")\ndef quick_done_cmd(project: str, no_commit: bool, message: str):\n    \"\"\"Complete a quick fix and commit changes.\n\n    \\b\n    Example:\n        eri-rpg quick-done myproject\n        eri-rpg quick-done myproject -m \"Better commit message\"\n    \"\"\"\n    from erirpg.quick import quick_done\n\n    try:\n        result = quick_done(\n            project=project,\n            auto_commit=not no_commit,\n            commit_message=message,\n        )\n        if result:\n            click.echo(\"\")\n            click.echo(\"Quick fix completed successfully.\")\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n@cli.command(\"quick-cancel\")\n@click.argument(\"project\")\ndef quick_cancel_cmd(project: str):\n    \"\"\"Cancel a quick fix and restore the original file.\n\n    \\b\n    Example:\n        eri-rpg quick-cancel myproject\n    \"\"\"\n    from erirpg.quick import quick_cancel\n\n    try:\n        quick_cancel(project)\n        click.echo(\"\")\n        click.echo(\"Quick fix cancelled.\")\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n\n\n@cli.command(\"quick-status\")\n@click.argument(\"project\")\ndef quick_status_cmd(project: str):\n    \"\"\"Check if a quick fix is active.\n\n    \\b\n    Example:\n        eri-rpg quick-status myproject\n    \"\"\"\n    from erirpg.quick import load_quick_fix_state\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    state = load_quick_fix_state(proj.path)\n\n    if not state or not state.get(\"quick_fix_active\"):\n        click.echo(f\"No active quick fix for {project}\")\n        return\n\n    click.echo(f\"Quick fix active:\")\n    click.echo(f\"  File: {state.get('target_file')}\")\n    click.echo(f\"  Description: {state.get('description')}\")\n    click.echo(f\"  Started: {state.get('timestamp')}\")\n    click.echo(\"\")\n    click.echo(f\"Complete: eri-rpg quick-done {project}\")\n    click.echo(f\"Cancel: eri-rpg quick-cancel {project}\")\n\n\n# ============================================================================\n# Cleanup Commands (Run Management)\n# ============================================================================\n\n@cli.command(\"cleanup\")\n@click.argument(\"project\")\n@click.option(\"--prune\", is_flag=True, help=\"Delete stale/abandoned runs\")\n@click.option(\"--days\", default=7, help=\"Consider runs older than N days as stale (default: 7)\")\n@click.option(\"--force\", is_flag=True, help=\"Delete without confirmation\")\ndef cleanup_cmd(project: str, prune: bool, days: int, force: bool):\n    \"\"\"List and optionally prune abandoned runs.\n\n    Stale runs are IN_PROGRESS runs that haven't been touched in N days.\n\n    \\b\n    Examples:\n        eri-rpg cleanup myproject          # List runs\n        eri-rpg cleanup myproject --prune  # Delete stale runs\n        eri-rpg cleanup myproject --prune --days 1  # Delete runs older than 1 day\n    \"\"\"\n    from pathlib import Path\n    from datetime import datetime, timedelta\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    run_dir = Path(proj.path) / \".eri-rpg\" / \"runs\"\n    if not run_dir.exists():\n        click.echo(f\"No runs found for {project}\")\n        return\n\n    runs = list(run_dir.glob(\"*.json\"))\n    if not runs:\n        click.echo(f\"No runs found for {project}\")\n        return\n\n    # Analyze runs\n    now = datetime.now()\n    stale_threshold = now - timedelta(days=days)\n\n    completed = []\n    in_progress = []\n    stale = []\n\n    for run_file in runs:\n        try:\n            with open(run_file) as f:\n                run_data = json.load(f)\n\n            run_id = run_data.get(\"id\", run_file.stem)\n            goal = run_data.get(\"spec\", {}).get(\"goal\", \"Unknown\")[:40]\n            started = run_data.get(\"started_at\", \"\")\n            completed_at = run_data.get(\"completed_at\")\n\n            # Parse timestamp\n            try:\n                if started:\n                    started_dt = datetime.fromisoformat(started.replace(\"Z\", \"+00:00\").split(\"+\")[0])\n                else:\n                    started_dt = datetime.fromtimestamp(run_file.stat().st_mtime)\n            except Exception:\n                started_dt = datetime.fromtimestamp(run_file.stat().st_mtime)\n\n            run_info = {\n                \"id\": run_id,\n                \"goal\": goal,\n                \"started\": started_dt,\n                \"file\": run_file,\n            }\n\n            if completed_at:\n                completed.append(run_info)\n            elif started_dt < stale_threshold:\n                stale.append(run_info)\n            else:\n                in_progress.append(run_info)\n\n        except Exception as e:\n            click.echo(f\"Warning: Could not parse {run_file.name}: {e}\", err=True)\n\n    # Show summary\n    click.echo(f\"Runs for {project}:\")\n    click.echo(f\"  Completed: {len(completed)}\")\n    click.echo(f\"  In Progress: {len(in_progress)}\")\n    click.echo(f\"  Stale (>{days} days): {len(stale)}\")\n    click.echo(\"\")\n\n    if stale:\n        click.echo(\"Stale runs:\")\n        for run in stale:\n            age = (now - run[\"started\"]).days\n            click.echo(f\"  {run['id']}: {run['goal']}... ({age} days old)\")\n        click.echo(\"\")\n\n    if in_progress:\n        click.echo(\"Active runs:\")\n        for run in in_progress:\n            age = (now - run[\"started\"]).days\n            click.echo(f\"  {run['id']}: {run['goal']}... ({age} days old)\")\n        click.echo(\"\")\n\n    if prune and stale:\n        if not force:\n            click.confirm(f\"Delete {len(stale)} stale run(s)?\", abort=True)\n\n        for run in stale:\n            run[\"file\"].unlink()\n            click.echo(f\"Deleted: {run['id']}\")\n\n        click.echo(f\"\\nPruned {len(stale)} stale run(s).\")\n\n        # Also clean up preflight state if no active runs\n        if not in_progress:\n            preflight_file = Path(proj.path) / \".eri-rpg\" / \"preflight_state.json\"\n            if preflight_file.exists():\n                preflight_file.unlink()\n                click.echo(\"Cleared stale preflight state.\")\n    elif prune:\n        click.echo(\"No stale runs to prune.\")\n\n\n@cli.command(\"runs\")\n@click.argument(\"project\")\n@click.option(\"--all\", \"show_all\", is_flag=True, help=\"Show all runs including completed\")\ndef runs_cmd(project: str, show_all: bool):\n    \"\"\"List runs for a project.\n\n    \\b\n    Example:\n        eri-rpg runs myproject\n        eri-rpg runs myproject --all\n    \"\"\"\n    from pathlib import Path\n    from datetime import datetime\n\n    registry = Registry.get_instance()\n    proj = registry.get(project)\n\n    if not proj:\n        click.echo(f\"Error: Project '{project}' not found\", err=True)\n        sys.exit(1)\n\n    run_dir = Path(proj.path) / \".eri-rpg\" / \"runs\"\n    if not run_dir.exists():\n        click.echo(f\"No runs found for {project}\")\n        return\n\n    runs = sorted(run_dir.glob(\"*.json\"), key=lambda p: p.stat().st_mtime, reverse=True)\n    if not runs:\n        click.echo(f\"No runs found for {project}\")\n        return\n\n    click.echo(f\"Runs for {project}:\")\n    click.echo(\"\")\n\n    for run_file in runs:\n        try:\n            with open(run_file) as f:\n                run_data = json.load(f)\n\n            run_id = run_data.get(\"id\", run_file.stem)\n            goal = run_data.get(\"spec\", {}).get(\"goal\", \"Unknown\")[:50]\n            completed_at = run_data.get(\"completed_at\")\n\n            if completed_at and not show_all:\n                continue\n\n            status = \"COMPLETED\" if completed_at else \"IN_PROGRESS\"\n            status_icon = \"\u2713\" if completed_at else \"\u25cb\"\n\n            # Get progress\n            plan = run_data.get(\"plan\", {})\n            steps = plan.get(\"steps\", [])\n            completed_steps = sum(1 for s in steps if s.get(\"status\") == \"completed\")\n            total_steps = len(steps)\n\n            click.echo(f\"  {status_icon} {run_id}\")\n            click.echo(f\"    Goal: {goal}...\")\n            click.echo(f\"    Status: {status} ({completed_steps}/{total_steps} steps)\")\n            click.echo(\"\")\n\n        except Exception as e:\n            click.echo(f\"  ? {run_file.name} (error: {e})\")\n\n    click.echo(\"\")\n    click.echo(\"Resume a run: eri-rpg goal-status <project>\")\n    click.echo(\"Cleanup stale: eri-rpg cleanup <project> --prune\")\n\n\n# ============================================================================\n# Entry Point\n# ============================================================================\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    cli()\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n# ============================================================================\n# Install/Uninstall Commands\n# ============================================================================\n\n@cli.command()\ndef install():\n    \"\"\"Install EriRPG commands and hooks for Claude Code.\"\"\"\n    from erirpg.install import install_claude_code\n    install_claude_code()\n\n\n@cli.command()\ndef uninstall():\n    \"\"\"Remove EriRPG from Claude Code.\"\"\"\n    from erirpg.install import uninstall_claude_code\n    uninstall_claude_code()\n\n\n@cli.command(\"install-status\")\ndef install_status():\n    \"\"\"Check EriRPG installation status.\"\"\"\n    from erirpg.install import check_installation\n    status = check_installation()\n    click.echo(\"EriRPG Installation Status:\")\n    if status[\"commands_installed\"]:\n        click.echo(f\"  Commands: {', '.join(status['commands'])}\")\n    else:\n        click.echo(\"  Commands: Not installed\")\n    if status[\"hooks_installed\"]:\n        click.echo(f\"  Hooks: {', '.join(status['hooks'])}\")\n    else:\n        click.echo(\"  Hooks: Not installed\")\n", "timestamp": "2026-01-26T19:46:49.723926"}