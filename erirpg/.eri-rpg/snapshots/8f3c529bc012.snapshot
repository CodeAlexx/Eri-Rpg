{"file_path": "memory.py", "content": "\"\"\"\nPersistent semantic memory for EriRPG.\n\nThis module provides the KnowledgeStore - a separate storage layer for\nsemantic knowledge that persists independently of the structural graph.\n\nKey design principles:\n- Knowledge survives reindexing (stored in separate knowledge.json)\n- Staleness is tracked via CodeRefs\n- Search enables finding relevant learnings by query\n- Version history enables rollback and operation tracking\n\nStorage structure:\n    .eri-rpg/\n    \u251c\u2500\u2500 graph.json       # Structural index (rebuildable)\n    \u251c\u2500\u2500 knowledge.json   # Semantic memory (PRESERVED)\n    \u2514\u2500\u2500 runs/            # Execution history (in knowledge.json)\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Set\nimport json\nimport os\nimport hashlib\nimport subprocess\nfrom pathlib import Path\n\nfrom erirpg.refs import CodeRef\n\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef hash_file(path: str) -> str:\n    \"\"\"Get SHA256 hash of file content (first 16 chars).\"\"\"\n    if not os.path.exists(path):\n        return \"\"\n    try:\n        with open(path, 'rb') as f:\n            return hashlib.sha256(f.read()).hexdigest()[:16]\n    except Exception:\n        return \"\"\n\n\ndef read_file_content(path: str) -> str:\n    \"\"\"Read file content safely.\"\"\"\n    try:\n        with open(path, 'r', errors='replace') as f:\n            return f.read()\n    except Exception:\n        return \"\"\n\n\ndef git_head() -> Optional[str]:\n    \"\"\"Get current git HEAD commit (first 12 chars).\"\"\"\n    try:\n        result = subprocess.run(\n            ['git', 'rev-parse', 'HEAD'],\n            capture_output=True,\n            text=True,\n            timeout=5,\n        )\n        if result.returncode == 0:\n            return result.stdout.strip()[:12]\n    except Exception:\n        pass\n    return None\n\n\ndef in_git_repo() -> bool:\n    \"\"\"Check if we're in a git repo.\"\"\"\n    return git_head() is not None\n\n\n# ============================================================================\n# Learning Version (Snapshot)\n# ============================================================================\n\n@dataclass\nclass LearningVersion:\n    \"\"\"Snapshot of a learning at a point in time.\n\n    Captures the state of a learning before a change is made,\n    enabling rollback if something goes wrong.\n    \"\"\"\n    version: int\n    timestamp: datetime\n    operation: str  # \"refactor\" | \"modify\" | \"transplant\" | \"create\"\n\n    # Snapshot of understanding\n    summary: str\n    purpose: str\n    key_functions: Dict[str, str] = field(default_factory=dict)\n    gotchas: List[str] = field(default_factory=list)\n\n    # What changed\n    change_description: str = \"\"\n\n    # File state at snapshot time\n    files_hashes: Dict[str, str] = field(default_factory=dict)  # path -> content hash\n    files_content: Optional[Dict[str, str]] = None  # path -> content (for small files)\n\n    # Git info (if available)\n    commit_before: Optional[str] = None\n    commit_after: Optional[str] = None\n\n    def to_dict(self) -> dict:\n        d = {\n            \"version\": self.version,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"operation\": self.operation,\n            \"summary\": self.summary,\n            \"purpose\": self.purpose,\n            \"key_functions\": self.key_functions,\n            \"gotchas\": self.gotchas,\n            \"change_description\": self.change_description,\n            \"files_hashes\": self.files_hashes,\n            \"commit_before\": self.commit_before,\n            \"commit_after\": self.commit_after,\n        }\n        # Only include files_content if present and non-empty\n        if self.files_content:\n            d[\"files_content\"] = self.files_content\n        return d\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"LearningVersion\":\n        return cls(\n            version=d[\"version\"],\n            timestamp=datetime.fromisoformat(d[\"timestamp\"]),\n            operation=d[\"operation\"],\n            summary=d.get(\"summary\", \"\"),\n            purpose=d.get(\"purpose\", \"\"),\n            key_functions=d.get(\"key_functions\", {}),\n            gotchas=d.get(\"gotchas\", []),\n            change_description=d.get(\"change_description\", \"\"),\n            files_hashes=d.get(\"files_hashes\", {}),\n            files_content=d.get(\"files_content\"),\n            commit_before=d.get(\"commit_before\"),\n            commit_after=d.get(\"commit_after\"),\n        )\n\n\n@dataclass\nclass RollbackResult:\n    \"\"\"Result of a file rollback operation.\n\n    Tracks what was restored, what failed, and provides\n    a formatted report for display.\n    \"\"\"\n    from_version: int\n    to_version: int\n    module_path: str\n    success: bool = True\n    error: str = \"\"\n    metadata_restored: bool = False\n    files_restored: List[Dict] = field(default_factory=list)\n    files_failed: List[str] = field(default_factory=list)\n    git_commit: Optional[str] = None  # If git rollback was used\n\n    def format(self) -> str:\n        \"\"\"Format rollback result for display.\"\"\"\n        lines = [\n            f\"{'\u2550' * 50}\",\n            f\" ROLLBACK: {self.module_path}\",\n            f\"{'\u2550' * 50}\",\n            f\"From version: {self.from_version} \u2192 {self.to_version}\",\n        ]\n\n        if not self.success:\n            lines.append(f\"\\n\u2717 FAILED: {self.error}\")\n            return \"\\n\".join(lines)\n\n        lines.append(\"\")\n\n        if self.files_restored:\n            lines.append(f\"Files ({len(self.files_restored)}):\")\n            for f in self.files_restored:\n                action = f.get(\"action\", \"unknown\")\n                path = f.get(\"path\", \"?\")\n                size = f.get(\"bytes\", 0)\n\n                if action == \"restored\":\n                    lines.append(f\"  \u2713 {path} ({size} bytes)\")\n                elif action == \"would_restore\":\n                    lines.append(f\"  \u25cb {path} ({size} bytes) [dry run]\")\n                elif action == \"failed\":\n                    lines.append(f\"  \u2717 {path}: {f.get('error', 'unknown error')}\")\n\n        if self.files_failed:\n            lines.append(f\"\\nFailed files ({len(self.files_failed)}):\")\n            for path in self.files_failed:\n                lines.append(f\"  \u2717 {path}\")\n\n        if self.metadata_restored:\n            lines.append(\"\\n\u2713 Learning metadata restored\")\n\n        if self.git_commit:\n            lines.append(f\"\\nGit: reverted to {self.git_commit}\")\n\n        lines.append(\"\")\n        if self.success:\n            lines.append(\"\u2705 ROLLBACK COMPLETE\")\n        else:\n            lines.append(\"\u26a0\ufe0f  ROLLBACK PARTIAL - some files failed\")\n\n        return \"\\n\".join(lines)\n\n    def to_dict(self) -> dict:\n        return {\n            \"from_version\": self.from_version,\n            \"to_version\": self.to_version,\n            \"module_path\": self.module_path,\n            \"success\": self.success,\n            \"error\": self.error,\n            \"metadata_restored\": self.metadata_restored,\n            \"files_restored\": self.files_restored,\n            \"files_failed\": self.files_failed,\n            \"git_commit\": self.git_commit,\n        }\n\n\n@dataclass\nclass RunRecord:\n    \"\"\"Record of a command execution for context tracking.\n\n    Attributes:\n        timestamp: When the command was run\n        command: The command that was executed\n        modules_read: List of modules that were read during execution\n        modules_written: List of modules that were written/modified\n        success: Whether the command completed successfully\n        duration_ms: How long the command took in milliseconds\n        notes: Optional notes about the run\n    \"\"\"\n    timestamp: datetime\n    command: str\n    modules_read: List[str] = field(default_factory=list)\n    modules_written: List[str] = field(default_factory=list)\n    success: bool = True\n    duration_ms: int = 0\n    notes: str = \"\"\n\n    def to_dict(self) -> dict:\n        return {\n            \"timestamp\": self.timestamp.isoformat(),\n            \"command\": self.command,\n            \"modules_read\": self.modules_read,\n            \"modules_written\": self.modules_written,\n            \"success\": self.success,\n            \"duration_ms\": self.duration_ms,\n            \"notes\": self.notes,\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"RunRecord\":\n        return cls(\n            timestamp=datetime.fromisoformat(d[\"timestamp\"]),\n            command=d[\"command\"],\n            modules_read=d.get(\"modules_read\", []),\n            modules_written=d.get(\"modules_written\", []),\n            success=d.get(\"success\", True),\n            duration_ms=d.get(\"duration_ms\", 0),\n            notes=d.get(\"notes\", \"\"),\n        )\n\n\n@dataclass\nclass StoredLearning:\n    \"\"\"A learning stored in the knowledge store.\n\n    This is the storage representation that includes the CodeRef.\n    The Learning class in knowledge.py can be converted to/from this.\n\n    Now includes version history for rollback capability.\n    \"\"\"\n    module_path: str\n    learned_at: datetime\n    summary: str\n    purpose: str\n    key_functions: Dict[str, str] = field(default_factory=dict)\n    key_params: Dict[str, str] = field(default_factory=dict)\n    gotchas: List[str] = field(default_factory=list)\n    dependencies: List[str] = field(default_factory=list)\n    transplanted_to: Optional[str] = None\n    source_ref: Optional[CodeRef] = None\n    confidence: float = 1.0\n    version: int = 1\n\n    # Transplant tracking (enhanced)\n    transplanted_from: Optional[str] = None  # \"project:path\" if this was transplanted\n    transplanted_to_list: List[str] = field(default_factory=list)  # [\"project:path\", ...]\n\n    # Version history for rollback\n    versions: List[LearningVersion] = field(default_factory=list)\n    current_version: int = 0\n\n    def is_stale(self, project_path: str) -> bool:\n        \"\"\"Check if this learning is stale (source changed).\"\"\"\n        if self.source_ref is None:\n            return False  # No ref to check\n        return self.source_ref.is_stale(project_path)\n\n    def snapshot(\n        self,\n        operation: str,\n        change_description: str,\n        files: List[str],\n        project_path: str = \"\",\n        store_content: bool = True,\n        max_content_lines: int = 500,\n    ) -> LearningVersion:\n        \"\"\"\n        Create a snapshot before making changes.\n\n        Args:\n            operation: What we're about to do (\"refactor\", \"modify\", \"transplant\", \"create\")\n            change_description: Why we're making this change\n            files: Files being modified\n            project_path: Project root for resolving file paths\n            store_content: Whether to store file contents\n            max_content_lines: Max lines to store per file\n\n        Returns:\n            LearningVersion snapshot\n        \"\"\"\n        version = LearningVersion(\n            version=self.current_version + 1,\n            timestamp=datetime.now(),\n            operation=operation,\n            summary=self.summary,\n            purpose=self.purpose,\n            key_functions=self.key_functions.copy(),\n            gotchas=self.gotchas.copy(),\n            change_description=change_description,\n            files_hashes={},\n            commit_before=git_head(),\n        )\n\n        # Store file hashes\n        for f in files:\n            full_path = os.path.join(project_path, f) if project_path else f\n            if os.path.exists(full_path):\n                version.files_hashes[f] = hash_file(full_path)\n\n        # Store content for small files\n        if store_content:\n            version.files_content = {}\n            for f in files:\n                full_path = os.path.join(project_path, f) if project_path else f\n                if os.path.exists(full_path):\n                    content = read_file_content(full_path)\n                    if content.count('\\n') <= max_content_lines:\n                        version.files_content[f] = content\n\n        self.versions.append(version)\n        return version\n\n    def rollback(self, to_version: Optional[int] = None) -> \"StoredLearning\":\n        \"\"\"\n        Rollback metadata to a previous version.\n\n        NOTE: This only rolls back the learning metadata (summary, purpose, etc).\n        To also restore files, use rollback_files().\n\n        Args:\n            to_version: Version NUMBER to rollback to (default: previous)\n\n        Returns:\n            Self with restored state\n        \"\"\"\n        target_version = to_version if to_version is not None else self.current_version - 1\n\n        if target_version < 1:\n            raise ValueError(f\"Cannot rollback to version {target_version} (versions start at 1)\")\n\n        # Find the version by its version number (not index!)\n        old = None\n        for v in self.versions:\n            if v.version == target_version:\n                old = v\n                break\n\n        if old is None:\n            available = [v.version for v in self.versions]\n            raise ValueError(\n                f\"Version {target_version} not found. \"\n                f\"Available versions: {available}\"\n            )\n\n        self.summary = old.summary\n        self.purpose = old.purpose\n        self.key_functions = old.key_functions.copy()\n        self.gotchas = old.gotchas.copy()\n        self.current_version = target_version\n\n        return self\n\n    def rollback_files(\n        self,\n        project_path: str,\n        to_version: Optional[int] = None,\n        dry_run: bool = False,\n    ) -> \"RollbackResult\":\n        \"\"\"\n        Rollback files to a previous version's snapshot.\n\n        This actually restores file contents from the stored snapshot.\n        Also rolls back the learning metadata.\n\n        Args:\n            project_path: Project root for resolving file paths\n            to_version: Version NUMBER to rollback to (default: previous version)\n            dry_run: If True, only report what would be restored without writing\n\n        Returns:\n            RollbackResult with details of what was/would be restored\n\n        Raises:\n            ValueError: If version not found or no file content stored\n        \"\"\"\n        # Default to previous version\n        target_version = to_version if to_version is not None else self.current_version - 1\n\n        if target_version < 1:\n            raise ValueError(f\"Cannot rollback to version {target_version} (versions start at 1)\")\n\n        # Find the version by its version number (not index!)\n        old = None\n        for v in self.versions:\n            if v.version == target_version:\n                old = v\n                break\n\n        if old is None:\n            available = [v.version for v in self.versions]\n            raise ValueError(\n                f\"Version {target_version} not found. \"\n                f\"Available versions: {available}\"\n            )\n\n        result = RollbackResult(\n            from_version=self.current_version,\n            to_version=target_version,\n            module_path=self.module_path,\n        )\n\n        # Check if we have file content to restore\n        if not old.files_content:\n            result.success = False\n            result.error = (\n                f\"Version {target_version} has no stored file content. \"\n                \"Was the snapshot created with store_content=False?\"\n            )\n            return result\n\n        # Restore files\n        for file_path, content in old.files_content.items():\n            full_path = os.path.join(project_path, file_path)\n\n            # Check current state\n            current_content = None\n            if os.path.exists(full_path):\n                current_content = read_file_content(full_path)\n                current_hash = hash_file(full_path)\n            else:\n                current_hash = None\n\n            # Check if file has changed from what we expect\n            expected_hash = old.files_hashes.get(file_path)\n\n            file_result = {\n                \"path\": file_path,\n                \"had_content\": current_content is not None,\n                \"content_changed\": current_hash != expected_hash if expected_hash else False,\n            }\n\n            if dry_run:\n                file_result[\"action\"] = \"would_restore\"\n                file_result[\"bytes\"] = len(content)\n            else:\n                try:\n                    # Create parent directories if needed\n                    Path(full_path).parent.mkdir(parents=True, exist_ok=True)\n\n                    # Write the restored content\n                    with open(full_path, 'w') as f:\n                        f.write(content)\n\n                    file_result[\"action\"] = \"restored\"\n                    file_result[\"bytes\"] = len(content)\n                except Exception as e:\n                    file_result[\"action\"] = \"failed\"\n                    file_result[\"error\"] = str(e)\n                    result.files_failed.append(file_path)\n\n            result.files_restored.append(file_result)\n\n        # Rollback metadata too (unless dry run)\n        if not dry_run:\n            self.rollback(target_version)\n            result.metadata_restored = True\n\n        result.success = len(result.files_failed) == 0\n        return result\n\n    def can_rollback_files(self, to_version: Optional[int] = None) -> bool:\n        \"\"\"Check if file rollback is possible for a version.\n\n        Args:\n            to_version: Version NUMBER to check (default: previous)\n\n        Returns:\n            True if version exists and has file content\n        \"\"\"\n        target_version = to_version if to_version is not None else self.current_version - 1\n\n        if target_version < 1:\n            return False\n\n        # Find the version by its version number\n        for v in self.versions:\n            if v.version == target_version:\n                return bool(v.files_content)\n\n        return False\n\n    def get_version(self, version_num: int) -> Optional[LearningVersion]:\n        \"\"\"Get a specific version from history.\"\"\"\n        for v in self.versions:\n            if v.version == version_num:\n                return v\n        return None\n\n    def history_summary(self) -> str:\n        \"\"\"Get a summary of version history.\"\"\"\n        if not self.versions:\n            return \"No version history\"\n\n        lines = [f\"Version history ({len(self.versions)} versions):\"]\n        for v in reversed(self.versions[-5:]):  # Show last 5\n            marker = \" (current)\" if v.version == self.current_version else \"\"\n            lines.append(\n                f\"  v{v.version}{marker} - {v.timestamp.strftime('%Y-%m-%d %H:%M')} - {v.operation}\"\n            )\n            if v.change_description:\n                lines.append(f\"    {v.change_description[:60]}...\")\n        return \"\\n\".join(lines)\n\n    def format_for_context(self, project_path: str = None) -> str:\n        \"\"\"Format learning for inclusion in context file.\n\n        Args:\n            project_path: If provided, include staleness warning if source changed\n\n        Returns:\n            Formatted string for CLI display\n        \"\"\"\n        lines = [\n            f\"### Stored Understanding (from {self.learned_at.strftime('%Y-%m-%d')})\",\n            f\"\",\n            f\"**Summary**: {self.summary}\",\n            f\"\",\n            f\"**Purpose**: {self.purpose}\",\n        ]\n\n        if self.key_functions:\n            lines.append(\"\")\n            lines.append(\"**Key Functions**:\")\n            for name, desc in self.key_functions.items():\n                lines.append(f\"- `{name}`: {desc}\")\n\n        if self.key_params:\n            lines.append(\"\")\n            lines.append(\"**Key Parameters**:\")\n            for name, desc in self.key_params.items():\n                lines.append(f\"- `{name}`: {desc}\")\n\n        if self.gotchas:\n            lines.append(\"\")\n            lines.append(\"**Gotchas**:\")\n            for g in self.gotchas:\n                lines.append(f\"- {g}\")\n\n        if self.dependencies:\n            lines.append(\"\")\n            lines.append(f\"**Dependencies**: {', '.join(self.dependencies)}\")\n\n        if self.transplanted_to:\n            lines.append(\"\")\n            lines.append(f\"**Transplanted to**: `{self.transplanted_to}`\")\n\n        # Add staleness warning if we can check\n        if project_path and self.is_stale(project_path):\n            lines.insert(0, \"\u26a0\ufe0f  **WARNING**: Source file has changed since this learning was created!\")\n            lines.insert(1, \"\")\n\n        return \"\\n\".join(lines)\n\n    def to_dict(self) -> dict:\n        d = {\n            \"module_path\": self.module_path,\n            \"learned_at\": self.learned_at.isoformat(),\n            \"summary\": self.summary,\n            \"purpose\": self.purpose,\n            \"key_functions\": self.key_functions,\n            \"key_params\": self.key_params,\n            \"gotchas\": self.gotchas,\n            \"dependencies\": self.dependencies,\n            \"transplanted_to\": self.transplanted_to,\n            \"confidence\": self.confidence,\n            \"version\": self.version,\n            # New fields for versioning\n            \"transplanted_from\": self.transplanted_from,\n            \"transplanted_to_list\": self.transplanted_to_list,\n            \"current_version\": self.current_version,\n        }\n        if self.source_ref:\n            d[\"source_ref\"] = self.source_ref.to_dict()\n        # Include versions if any exist\n        if self.versions:\n            d[\"versions\"] = [v.to_dict() for v in self.versions]\n        return d\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"StoredLearning\":\n        source_ref = None\n        if \"source_ref\" in d:\n            source_ref = CodeRef.from_dict(d[\"source_ref\"])\n\n        # Load versions if present\n        versions = []\n        if \"versions\" in d:\n            versions = [LearningVersion.from_dict(v) for v in d[\"versions\"]]\n\n        return cls(\n            module_path=d[\"module_path\"],\n            learned_at=datetime.fromisoformat(d[\"learned_at\"]),\n            summary=d.get(\"summary\", \"\"),\n            purpose=d.get(\"purpose\", \"\"),\n            key_functions=d.get(\"key_functions\", {}),\n            key_params=d.get(\"key_params\", {}),\n            gotchas=d.get(\"gotchas\", []),\n            dependencies=d.get(\"dependencies\", []),\n            transplanted_to=d.get(\"transplanted_to\"),\n            source_ref=source_ref,\n            confidence=d.get(\"confidence\", 1.0),\n            version=d.get(\"version\", 1),\n            # New fields for versioning\n            transplanted_from=d.get(\"transplanted_from\"),\n            transplanted_to_list=d.get(\"transplanted_to_list\", []),\n            versions=versions,\n            current_version=d.get(\"current_version\", 0),\n        )\n\n\n@dataclass\nclass StoredDecision:\n    \"\"\"An architectural or design decision stored in knowledge.\"\"\"\n    id: str\n    date: datetime\n    title: str\n    reason: str\n    affects: List[str] = field(default_factory=list)\n    alternatives: List[str] = field(default_factory=list)\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"date\": self.date.isoformat(),\n            \"title\": self.title,\n            \"reason\": self.reason,\n            \"affects\": self.affects,\n            \"alternatives\": self.alternatives,\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"StoredDecision\":\n        return cls(\n            id=d[\"id\"],\n            date=datetime.fromisoformat(d[\"date\"]),\n            title=d[\"title\"],\n            reason=d.get(\"reason\", \"\"),\n            affects=d.get(\"affects\", []),\n            alternatives=d.get(\"alternatives\", []),\n        )\n\n\n@dataclass\nclass KnowledgeStore:\n    \"\"\"Persistent semantic knowledge store.\n\n    Stores learnings, decisions, patterns, and run history\n    independently of the structural graph. Survives reindexing.\n    \"\"\"\n    project: str\n    version: str = \"2.0.0\"\n    learnings: Dict[str, StoredLearning] = field(default_factory=dict)\n    decisions: List[StoredDecision] = field(default_factory=list)\n    patterns: Dict[str, str] = field(default_factory=dict)\n    runs: List[RunRecord] = field(default_factory=list)\n\n    # CRUD for learnings\n\n    def add_learning(self, learning: StoredLearning) -> None:\n        \"\"\"Add or update a learning.\"\"\"\n        self.learnings[learning.module_path] = learning\n\n    def get_learning(self, module_path: str) -> Optional[StoredLearning]:\n        \"\"\"Get learning for a module path.\"\"\"\n        return self.learnings.get(module_path)\n\n    def has_learning(self, module_path: str) -> bool:\n        \"\"\"Check if learning exists for a module.\"\"\"\n        return module_path in self.learnings\n\n    def remove_learning(self, module_path: str) -> bool:\n        \"\"\"Remove a learning. Returns True if it existed.\"\"\"\n        if module_path in self.learnings:\n            del self.learnings[module_path]\n            return True\n        return False\n\n    def list_modules(self) -> List[str]:\n        \"\"\"List all modules with learnings.\"\"\"\n        return list(self.learnings.keys())\n\n    # CRUD for decisions\n\n    def add_decision(self, decision: StoredDecision) -> None:\n        \"\"\"Add a decision.\"\"\"\n        self.decisions.append(decision)\n\n    def get_decisions_for_module(self, module_path: str) -> List[StoredDecision]:\n        \"\"\"Get all decisions affecting a module.\"\"\"\n        return [d for d in self.decisions if module_path in d.affects]\n\n    # CRUD for patterns\n\n    def add_pattern(self, name: str, description: str) -> None:\n        \"\"\"Add or update a pattern.\"\"\"\n        self.patterns[name] = description\n\n    def get_pattern(self, name: str) -> Optional[str]:\n        \"\"\"Get a pattern by name.\"\"\"\n        return self.patterns.get(name)\n\n    # Run tracking\n\n    def add_run(self, run: RunRecord) -> None:\n        \"\"\"Add a run record.\"\"\"\n        self.runs.append(run)\n\n    def get_recent_runs(self, limit: int = 10) -> List[RunRecord]:\n        \"\"\"Get most recent run records.\"\"\"\n        return sorted(self.runs, key=lambda r: r.timestamp, reverse=True)[:limit]\n\n    # Staleness detection\n\n    def get_stale_learnings(self, project_path: str) -> List[str]:\n        \"\"\"Find all learnings whose source files have changed.\n\n        Args:\n            project_path: Root path of the project\n\n        Returns:\n            List of module paths with stale learnings\n        \"\"\"\n        stale = []\n        for module_path, learning in self.learnings.items():\n            if learning.is_stale(project_path):\n                stale.append(module_path)\n        return stale\n\n    def get_fresh_learnings(self, project_path: str) -> List[str]:\n        \"\"\"Find all learnings that are still fresh.\n\n        Args:\n            project_path: Root path of the project\n\n        Returns:\n            List of module paths with fresh learnings\n        \"\"\"\n        fresh = []\n        for module_path, learning in self.learnings.items():\n            if not learning.is_stale(project_path):\n                fresh.append(module_path)\n        return fresh\n\n    # Search\n\n    def search(self, query: str, limit: int = 10) -> List[tuple[str, StoredLearning, float]]:\n        \"\"\"Search learnings by query.\n\n        Simple keyword-based search matching against:\n        - Module path\n        - Summary\n        - Purpose\n        - Key function names and descriptions\n        - Gotchas\n\n        Args:\n            query: Search query (space-separated keywords)\n            limit: Maximum results to return\n\n        Returns:\n            List of (module_path, learning, score) tuples\n        \"\"\"\n        from erirpg.search import search_learnings\n        return search_learnings(self.learnings, query, limit)\n\n    # Statistics\n\n    def stats(self) -> dict:\n        \"\"\"Get knowledge store statistics.\"\"\"\n        return {\n            \"learnings\": len(self.learnings),\n            \"decisions\": len(self.decisions),\n            \"patterns\": len(self.patterns),\n            \"runs\": len(self.runs),\n        }\n\n    # Persistence\n\n    def save(self, path: str) -> None:\n        \"\"\"Save knowledge store to JSON file.\n\n        Args:\n            path: Path to knowledge.json file\n        \"\"\"\n        p = Path(path)\n        p.parent.mkdir(parents=True, exist_ok=True)\n\n        data = {\n            \"project\": self.project,\n            \"version\": self.version,\n            \"saved_at\": datetime.now().isoformat(),\n            \"learnings\": {k: v.to_dict() for k, v in self.learnings.items()},\n            \"decisions\": [d.to_dict() for d in self.decisions],\n            \"patterns\": self.patterns,\n            \"runs\": [r.to_dict() for r in self.runs[-100:]],  # Keep last 100 runs\n        }\n\n        with open(p, \"w\") as f:\n            json.dump(data, f, indent=2)\n\n    @classmethod\n    def load(cls, path: str) -> \"KnowledgeStore\":\n        \"\"\"Load knowledge store from JSON file.\n\n        Args:\n            path: Path to knowledge.json file\n\n        Returns:\n            Loaded KnowledgeStore, or empty one if file doesn't exist\n        \"\"\"\n        if not os.path.exists(path):\n            # Return empty store - caller should set project name\n            return cls(project=\"unknown\")\n\n        with open(path, \"r\") as f:\n            data = json.load(f)\n\n        return cls(\n            project=data.get(\"project\", \"unknown\"),\n            version=data.get(\"version\", \"2.0.0\"),\n            learnings={\n                k: StoredLearning.from_dict(v)\n                for k, v in data.get(\"learnings\", {}).items()\n            },\n            decisions=[\n                StoredDecision.from_dict(d)\n                for d in data.get(\"decisions\", [])\n            ],\n            patterns=data.get(\"patterns\", {}),\n            runs=[\n                RunRecord.from_dict(r)\n                for r in data.get(\"runs\", [])\n            ],\n        )\n\n\ndef get_knowledge_path(project_path: str) -> str:\n    \"\"\"Get the path to knowledge.json for a project.\n\n    Args:\n        project_path: Root path of the project\n\n    Returns:\n        Path to .eri-rpg/knowledge.json\n    \"\"\"\n    return os.path.join(project_path, \".eri-rpg\", \"knowledge.json\")\n\n\ndef load_knowledge(project_path: str, project_name: str) -> KnowledgeStore:\n    \"\"\"Load knowledge store for a project.\n\n    Args:\n        project_path: Root path of the project\n        project_name: Name of the project\n\n    Returns:\n        KnowledgeStore for the project\n    \"\"\"\n    path = get_knowledge_path(project_path)\n    store = KnowledgeStore.load(path)\n    if store.project == \"unknown\":\n        store.project = project_name\n    return store\n\n\ndef save_knowledge(project_path: str, store: KnowledgeStore) -> None:\n    \"\"\"Save knowledge store for a project.\n\n    Args:\n        project_path: Root path of the project\n        store: KnowledgeStore to save\n    \"\"\"\n    path = get_knowledge_path(project_path)\n    store.save(path)\n\n\n# ============================================================================\n# Operation-Aware Learning Updates\n# ============================================================================\n\nclass LearningUpdatePolicy:\n    \"\"\"How to update learnings based on operation type.\"\"\"\n    REFACTOR = \"replace\"      # Old learning replaced with new\n    TRANSPLANT = \"duplicate\"  # Source keeps learning, target gets new one\n    MODIFY = \"append\"         # Add new info, keep existing\n    NEW = \"create\"            # Fresh learning for new code\n\n\ndef update_learning_with_operation(\n    store: KnowledgeStore,\n    module_path: str,\n    operation: str,\n    new_understanding: dict,\n    project_path: str = \"\",\n    source_learning: Optional[StoredLearning] = None,\n    change_description: str = \"\",\n) -> StoredLearning:\n    \"\"\"\n    Update learning based on operation type.\n\n    Different operations handle learnings differently:\n    - refactor: Replace understanding, preserve gotchas\n    - transplant: Duplicate learning to target, link to source\n    - modify: Append new info to existing\n    - new: Create fresh learning\n\n    Args:\n        store: KnowledgeStore to update\n        module_path: Module path\n        operation: \"refactor\" | \"transplant\" | \"modify\" | \"new\"\n        new_understanding: Dict with summary, purpose, key_functions, gotchas\n        project_path: Project root for file path resolution\n        source_learning: For transplants, the source learning\n        change_description: What changed and why\n\n    Returns:\n        Updated or new StoredLearning\n    \"\"\"\n    existing = store.get_learning(module_path)\n\n    if operation == \"new\" or (operation == \"transplant\" and not existing):\n        # Create fresh learning\n        learning = StoredLearning(\n            module_path=module_path,\n            learned_at=datetime.now(),\n            summary=new_understanding.get('summary', ''),\n            purpose=new_understanding.get('purpose', ''),\n            key_functions=new_understanding.get('key_functions', {}),\n            gotchas=new_understanding.get('gotchas', []),\n            current_version=1,\n        )\n\n        if source_learning:\n            learning.transplanted_from = f\"{source_learning.module_path}\"\n            # Update source to track where it was transplanted\n            source_learning.transplanted_to_list.append(module_path)\n\n        # Create initial version snapshot\n        learning.snapshot(\n            operation=\"create\",\n            change_description=change_description or \"Initial learning\",\n            files=[module_path],\n            project_path=project_path,\n        )\n        learning.current_version = 1\n\n        store.add_learning(learning)\n        return learning\n\n    elif operation == \"refactor\":\n        # Replace understanding, preserve gotchas unless explicitly changed\n        existing.snapshot(\n            operation=operation,\n            change_description=change_description,\n            files=[module_path],\n            project_path=project_path,\n        )\n\n        existing.summary = new_understanding.get('summary', existing.summary)\n        existing.purpose = new_understanding.get('purpose', existing.purpose)\n        existing.key_functions = new_understanding.get('key_functions', existing.key_functions)\n\n        # Merge gotchas - don't lose hard-won knowledge\n        new_gotchas = new_understanding.get('gotchas', [])\n        for gotcha in new_gotchas:\n            if gotcha not in existing.gotchas:\n                existing.gotchas.append(gotcha)\n\n        existing.current_version += 1\n        existing.learned_at = datetime.now()\n\n        store.add_learning(existing)\n        return existing\n\n    elif operation == \"modify\":\n        # Append new info, preserve existing\n        existing.snapshot(\n            operation=operation,\n            change_description=change_description,\n            files=[module_path],\n            project_path=project_path,\n        )\n\n        # Append to summary if new info provided\n        new_summary = new_understanding.get('summary', '')\n        if new_summary and new_summary not in existing.summary:\n            existing.summary += f\"\\n\\n[Modified]: {new_summary}\"\n\n        # Append to purpose if new info provided\n        new_purpose = new_understanding.get('purpose', '')\n        if new_purpose and new_purpose not in existing.purpose:\n            existing.purpose += f\"\\n\\n[Modified]: {new_purpose}\"\n\n        # Merge key functions\n        for name, desc in new_understanding.get('key_functions', {}).items():\n            existing.key_functions[name] = desc\n\n        # Append gotchas\n        for gotcha in new_understanding.get('gotchas', []):\n            if gotcha not in existing.gotchas:\n                existing.gotchas.append(gotcha)\n\n        existing.current_version += 1\n        existing.learned_at = datetime.now()\n\n        store.add_learning(existing)\n        return existing\n\n    elif operation == \"transplant\" and existing:\n        # Target already has a learning - update it with source info\n        existing.snapshot(\n            operation=operation,\n            change_description=change_description,\n            files=[module_path],\n            project_path=project_path,\n        )\n\n        # Merge with source learning info\n        if source_learning:\n            existing.transplanted_from = source_learning.module_path\n\n            # Merge gotchas from source\n            for gotcha in source_learning.gotchas:\n                if gotcha not in existing.gotchas:\n                    existing.gotchas.append(gotcha)\n\n        # Update with new understanding\n        if new_understanding.get('summary'):\n            existing.summary = new_understanding['summary']\n        if new_understanding.get('purpose'):\n            existing.purpose = new_understanding['purpose']\n        if new_understanding.get('key_functions'):\n            existing.key_functions.update(new_understanding['key_functions'])\n\n        existing.current_version += 1\n        existing.learned_at = datetime.now()\n\n        store.add_learning(existing)\n        return existing\n\n    else:\n        raise ValueError(f\"Unknown operation: {operation}\")\n", "timestamp": "2026-01-26T20:00:59.235771"}