{
  "project": "erirpg",
  "version": "0.55.0-alpha",
  "indexed_at": "2026-01-29T07:09:11.335202",
  "modules": {
    "cli.py": {
      "path": "cli.py",
      "lang": "python",
      "lines": 37,
      "summary": "EriRPG CLI - One tool. Three modes. No bloat.",
      "interfaces": [
        {
          "name": "cli",
          "type": "function",
          "signature": "def cli()",
          "docstring": "EriRPG - Cross-project feature transplant tool.",
          "methods": [],
          "line": 19
        },
        {
          "name": "main",
          "type": "function",
          "signature": "def main()",
          "docstring": "",
          "methods": [],
          "line": 31
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "erirpg",
        "click"
      ]
    },
    "search.py": {
      "path": "search.py",
      "lang": "python",
      "lines": 242,
      "summary": "Search functionality for EriRPG knowledge.",
      "interfaces": [
        {
          "name": "tokenize",
          "type": "function",
          "signature": "def tokenize(text: str) -> Set[str]",
          "docstring": "Tokenize text into lowercase words.",
          "methods": [],
          "line": 16
        },
        {
          "name": "jaccard_similarity",
          "type": "function",
          "signature": "def jaccard_similarity(set1: Set[str], set2: Set[str]) -> float",
          "docstring": "Compute Jaccard similarity between two sets.",
          "methods": [],
          "line": 30
        },
        {
          "name": "search_learnings",
          "type": "function",
          "signature": "def search_learnings(learnings: Dict[str, 'StoredLearning'], query: str, limit: int, project_path: str) -> List[Tuple[str, 'StoredLearning', float]]",
          "docstring": "Search learnings by query.",
          "methods": [],
          "line": 47
        },
        {
          "name": "search_patterns",
          "type": "function",
          "signature": "def search_patterns(patterns: Dict[str, str], query: str, limit: int) -> List[Tuple[str, str, float]]",
          "docstring": "Search patterns by query.",
          "methods": [],
          "line": 146
        },
        {
          "name": "search_decisions",
          "type": "function",
          "signature": "def search_decisions(decisions: List, query: str, limit: int) -> List[Tuple[int, object, float]]",
          "docstring": "Search decisions by query.",
          "methods": [],
          "line": 192
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "config.py": {
      "path": "config.py",
      "lang": "python",
      "lines": 462,
      "summary": "EriRPG Project Configuration.",
      "interfaces": [
        {
          "name": "TIER_LEVELS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 28
        },
        {
          "name": "tier_includes_command",
          "type": "function",
          "signature": "def tier_includes_command(tier: Tier, command: str) -> bool",
          "docstring": "Check if a tier includes a specific command.",
          "methods": [],
          "line": 101
        },
        {
          "name": "get_tier_for_command",
          "type": "function",
          "signature": "def get_tier_for_command(command: str) -> Optional[Tier]",
          "docstring": "Get the minimum tier required for a command.",
          "methods": [],
          "line": 121
        },
        {
          "name": "EnforcementConfig",
          "type": "class",
          "signature": "",
          "docstring": "Enforcement behavior settings.",
          "methods": [],
          "line": 137
        },
        {
          "name": "MultiAgentConfig",
          "type": "class",
          "signature": "",
          "docstring": "Multi-agent execution settings.",
          "methods": [],
          "line": 144
        },
        {
          "name": "ProjectConfig",
          "type": "class",
          "signature": "",
          "docstring": "Project-level configuration.",
          "methods": [
            "to_dict",
            "from_dict",
            "is_bootstrap",
            "is_maintain",
            "has_graduated",
            "is_lite",
            "is_standard",
            "is_full",
            "tier_level",
            "can_use_command"
          ],
          "line": 152
        },
        {
          "name": "get_config_path",
          "type": "function",
          "signature": "def get_config_path(project_path: str) -> Path",
          "docstring": "Get the config file path for a project.",
          "methods": [],
          "line": 234
        },
        {
          "name": "load_config",
          "type": "function",
          "signature": "def load_config(project_path: str) -> ProjectConfig",
          "docstring": "Load project configuration. Returns defaults if not found.",
          "methods": [],
          "line": 239
        },
        {
          "name": "save_config",
          "type": "function",
          "signature": "def save_config(project_path: str, config: ProjectConfig) -> None",
          "docstring": "Save project configuration.",
          "methods": [],
          "line": 254
        },
        {
          "name": "set_multi_agent",
          "type": "function",
          "signature": "def set_multi_agent(project_path: str, enabled: bool) -> ProjectConfig",
          "docstring": "Enable or disable multi-agent mode.",
          "methods": [],
          "line": 265
        },
        {
          "name": "set_concurrency",
          "type": "function",
          "signature": "def set_concurrency(project_path: str, max_concurrency: int) -> ProjectConfig",
          "docstring": "Set max concurrency for multi-agent mode.",
          "methods": [],
          "line": 273
        },
        {
          "name": "get_mode",
          "type": "function",
          "signature": "def get_mode(project_path: str) -> Mode",
          "docstring": "Get the operational mode for a project.",
          "methods": [],
          "line": 285
        },
        {
          "name": "set_mode",
          "type": "function",
          "signature": "def set_mode(project_path: str, mode: Mode) -> ProjectConfig",
          "docstring": "Set the operational mode for a project.",
          "methods": [],
          "line": 328
        },
        {
          "name": "graduate_project",
          "type": "function",
          "signature": "def graduate_project(project_path: str, by: str) -> ProjectConfig",
          "docstring": "Graduate a project from bootstrap to maintain mode.",
          "methods": [],
          "line": 344
        },
        {
          "name": "init_project_config",
          "type": "function",
          "signature": "def init_project_config(project_path: str, tier: Tier) -> ProjectConfig",
          "docstring": "Initialize config for a new project in bootstrap mode.",
          "methods": [],
          "line": 364
        },
        {
          "name": "get_tier",
          "type": "function",
          "signature": "def get_tier(project_path: str) -> Tier",
          "docstring": "Get the feature tier for a project.",
          "methods": [],
          "line": 389
        },
        {
          "name": "set_tier",
          "type": "function",
          "signature": "def set_tier(project_path: str, tier: Tier) -> ProjectConfig",
          "docstring": "Set the feature tier for a project.",
          "methods": [],
          "line": 402
        },
        {
          "name": "upgrade_tier",
          "type": "function",
          "signature": "def upgrade_tier(project_path: str) -> ProjectConfig",
          "docstring": "Upgrade project to next tier level.",
          "methods": [],
          "line": 421
        },
        {
          "name": "tier_allows",
          "type": "function",
          "signature": "def tier_allows(current_tier: Tier, required_tier: Tier) -> bool",
          "docstring": "Check if current tier includes required tier level.",
          "methods": [],
          "line": 451
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "storage.py": {
      "path": "storage.py",
      "lang": "python",
      "lines": 685,
      "summary": "SQLite storage layer for EriRPG graphs.",
      "interfaces": [
        {
          "name": "DEFAULT_DB_PATH",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 26
        },
        {
          "name": "SCHEMA_VERSION",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 29
        },
        {
          "name": "get_db_path",
          "type": "function",
          "signature": "def get_db_path() -> str",
          "docstring": "Get the database path, respecting ERI_RPG_DB env var.",
          "methods": [],
          "line": 32
        },
        {
          "name": "get_connection",
          "type": "function",
          "signature": "def get_connection(db_path: Optional[str]) -> Iterator[sqlite3.Connection]",
          "docstring": "Get a database connection with proper settings.",
          "methods": [],
          "line": 38
        },
        {
          "name": "init_db",
          "type": "function",
          "signature": "def init_db(db_path: Optional[str]) -> None",
          "docstring": "Initialize the database schema.",
          "methods": [],
          "line": 57
        },
        {
          "name": "get_schema_version",
          "type": "function",
          "signature": "def get_schema_version(db_path: Optional[str]) -> int",
          "docstring": "Get current schema version, or 0 if not initialized.",
          "methods": [],
          "line": 156
        },
        {
          "name": "save_graph",
          "type": "function",
          "signature": "def save_graph(graph: Graph, db_path: Optional[str]) -> None",
          "docstring": "Save a graph to the SQLite database.",
          "methods": [],
          "line": 171
        },
        {
          "name": "delete_project",
          "type": "function",
          "signature": "def delete_project(project_name: str, db_path: Optional[str]) -> bool",
          "docstring": "Delete a project and all its data from the database.",
          "methods": [],
          "line": 261
        },
        {
          "name": "load_graph",
          "type": "function",
          "signature": "def load_graph(project_name: str, db_path: Optional[str]) -> Optional[Graph]",
          "docstring": "Load a graph from the database.",
          "methods": [],
          "line": 276
        },
        {
          "name": "get_module",
          "type": "function",
          "signature": "def get_module(project_name: str, module_path: str, db_path: Optional[str]) -> Optional[Module]",
          "docstring": "Get a single module without loading the full graph.",
          "methods": [],
          "line": 369
        },
        {
          "name": "CrossProjectResult",
          "type": "class",
          "signature": "",
          "docstring": "Result from a cross-project query.",
          "methods": [],
          "line": 427
        },
        {
          "name": "find_interface_across_projects",
          "type": "function",
          "signature": "def find_interface_across_projects(name: str, interface_type: Optional[str], db_path: Optional[str]) -> List[CrossProjectResult]",
          "docstring": "Find interfaces by name across all projects.",
          "methods": [],
          "line": 437
        },
        {
          "name": "find_external_dep_usage",
          "type": "function",
          "signature": "def find_external_dep_usage(package: str, db_path: Optional[str]) -> List[Tuple[str, str]]",
          "docstring": "Find all modules across projects that use an external package.",
          "methods": [],
          "line": 486
        },
        {
          "name": "find_dependents_across_projects",
          "type": "function",
          "signature": "def find_dependents_across_projects(module_path: str, db_path: Optional[str]) -> List[Tuple[str, str]]",
          "docstring": "Find all modules across projects that depend on a given module path.",
          "methods": [],
          "line": 511
        },
        {
          "name": "get_project_stats",
          "type": "function",
          "signature": "def get_project_stats(db_path: Optional[str]) -> Dict[str, dict]",
          "docstring": "Get statistics for all projects in the database.",
          "methods": [],
          "line": 539
        },
        {
          "name": "get_db_stats",
          "type": "function",
          "signature": "def get_db_stats(db_path: Optional[str]) -> dict",
          "docstring": "Get overall database statistics.",
          "methods": [],
          "line": 587
        },
        {
          "name": "migrate_from_json",
          "type": "function",
          "signature": "def migrate_from_json(json_path: str, project_name: str, db_path: Optional[str]) -> bool",
          "docstring": "Migrate a JSON graph file to the SQLite database.",
          "methods": [],
          "line": 617
        },
        {
          "name": "migrate_all_projects",
          "type": "function",
          "signature": "def migrate_all_projects(registry_path: Optional[str], db_path: Optional[str]) -> Dict[str, bool]",
          "docstring": "Migrate all registered projects from JSON to SQLite.",
          "methods": [],
          "line": 636
        },
        {
          "name": "export_to_json",
          "type": "function",
          "signature": "def export_to_json(project_name: str, output_path: str, db_path: Optional[str]) -> bool",
          "docstring": "Export a project's graph to JSON format.",
          "methods": [],
          "line": 669
        }
      ],
      "deps_internal": [
        "graph.py"
      ],
      "deps_external": []
    },
    "write_guard.py": {
      "path": "write_guard.py",
      "lang": "python",
      "lines": 184,
      "summary": "Hard enforcement hooks for EriRPG.",
      "interfaces": [
        {
          "name": "_ALWAYS_ALLOWED_PATTERNS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 24
        },
        {
          "name": "guarded_open",
          "type": "function",
          "signature": "def guarded_open(file, mode, *args, **kwargs)",
          "docstring": "Intercept file opens and block unauthorized writes.",
          "methods": [],
          "line": 35
        },
        {
          "name": "install_hooks",
          "type": "function",
          "signature": "def install_hooks() -> None",
          "docstring": "Install write protection hooks.",
          "methods": [],
          "line": 90
        },
        {
          "name": "uninstall_hooks",
          "type": "function",
          "signature": "def uninstall_hooks() -> None",
          "docstring": "Uninstall write protection hooks.",
          "methods": [],
          "line": 105
        },
        {
          "name": "enable_writes",
          "type": "function",
          "signature": "def enable_writes(paths: List[str], project_path: Optional[str]) -> None",
          "docstring": "Enable writes for specific paths.",
          "methods": [],
          "line": 117
        },
        {
          "name": "disable_writes",
          "type": "function",
          "signature": "def disable_writes() -> None",
          "docstring": "Disable writes.",
          "methods": [],
          "line": 144
        },
        {
          "name": "is_write_allowed",
          "type": "function",
          "signature": "def is_write_allowed() -> bool",
          "docstring": "Check if writes are currently allowed.",
          "methods": [],
          "line": 156
        },
        {
          "name": "get_allowed_paths",
          "type": "function",
          "signature": "def get_allowed_paths() -> List[str]",
          "docstring": "Get list of paths that are allowed to be written.",
          "methods": [],
          "line": 161
        },
        {
          "name": "add_allowed_path",
          "type": "function",
          "signature": "def add_allowed_path(path: str, project_path: Optional[str]) -> None",
          "docstring": "Add a path to the allowed list.",
          "methods": [],
          "line": 166
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "analyze.py": {
      "path": "analyze.py",
      "lang": "python",
      "lines": 508,
      "summary": "EriRPG Project Pattern Analysis",
      "interfaces": [
        {
          "name": "ExtensionPoint",
          "type": "class",
          "signature": "",
          "docstring": "A point where code can be extended (hooks, callbacks, overrides).",
          "methods": [],
          "line": 26
        },
        {
          "name": "Registry",
          "type": "class",
          "signature": "",
          "docstring": "A factory/registry pattern for registering implementations.",
          "methods": [],
          "line": 35
        },
        {
          "name": "ProjectPatterns",
          "type": "class",
          "signature": "",
          "docstring": "Detected patterns for a project.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 44
        },
        {
          "name": "get_patterns_path",
          "type": "function",
          "signature": "def get_patterns_path(project_path: str) -> Path",
          "docstring": "Get path to patterns.json.",
          "methods": [],
          "line": 93
        },
        {
          "name": "load_patterns",
          "type": "function",
          "signature": "def load_patterns(project_path: str) -> Optional[ProjectPatterns]",
          "docstring": "Load patterns from .eri-rpg/patterns.json.",
          "methods": [],
          "line": 98
        },
        {
          "name": "save_patterns",
          "type": "function",
          "signature": "def save_patterns(project_path: str, patterns: ProjectPatterns)",
          "docstring": "Save patterns to .eri-rpg/patterns.json.",
          "methods": [],
          "line": 111
        },
        {
          "name": "analyze_project",
          "type": "function",
          "signature": "def analyze_project(project_path: str) -> ProjectPatterns",
          "docstring": "Analyze codebase for patterns.",
          "methods": [],
          "line": 119
        },
        {
          "name": "detect_structure_patterns",
          "type": "function",
          "signature": "def detect_structure_patterns(project_path: str) -> Dict[str, str]",
          "docstring": "Detect where different types of files live.",
          "methods": [],
          "line": 136
        },
        {
          "name": "detect_conventions",
          "type": "function",
          "signature": "def detect_conventions(project_path: str, graph: Graph) -> Dict[str, str]",
          "docstring": "Detect naming and implementation conventions.",
          "methods": [],
          "line": 180
        },
        {
          "name": "find_extension_points",
          "type": "function",
          "signature": "def find_extension_points(project_path: str, graph: Graph) -> List[ExtensionPoint]",
          "docstring": "Find hook methods, callbacks, overridable points.",
          "methods": [],
          "line": 209
        },
        {
          "name": "find_base_classes",
          "type": "function",
          "signature": "def find_base_classes(project_path: str, graph: Graph) -> Dict[str, str]",
          "docstring": "Find abstract/base classes meant to be inherited.",
          "methods": [],
          "line": 255
        },
        {
          "name": "find_registries",
          "type": "function",
          "signature": "def find_registries(project_path: str, graph: Graph) -> List[Registry]",
          "docstring": "Find factory/registry patterns.",
          "methods": [],
          "line": 324
        },
        {
          "name": "detect_common_imports",
          "type": "function",
          "signature": "def detect_common_imports(project_path: str, graph: Graph) -> Dict[str, List[str]]",
          "docstring": "Detect commonly used imports.",
          "methods": [],
          "line": 388
        },
        {
          "name": "detect_test_patterns",
          "type": "function",
          "signature": "def detect_test_patterns(project_path: str) -> Dict[str, str]",
          "docstring": "Detect test file organization.",
          "methods": [],
          "line": 433
        },
        {
          "name": "format_patterns",
          "type": "function",
          "signature": "def format_patterns(patterns: ProjectPatterns) -> str",
          "docstring": "Format patterns for display.",
          "methods": [],
          "line": 459
        }
      ],
      "deps_internal": [
        "graph.py",
        "registry.py"
      ],
      "deps_external": []
    },
    "graph.py": {
      "path": "graph.py",
      "lang": "python",
      "lines": 324,
      "summary": "Graph data structures for representing codebases.",
      "interfaces": [
        {
          "name": "Interface",
          "type": "class",
          "signature": "",
          "docstring": "A public interface (class, function, method, const) in a module.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 21
        },
        {
          "name": "Module",
          "type": "class",
          "signature": "",
          "docstring": "A source file/module in the project.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 53
        },
        {
          "name": "Edge",
          "type": "class",
          "signature": "",
          "docstring": "A dependency edge between modules.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 88
        },
        {
          "name": "Graph",
          "type": "class",
          "signature": "",
          "docstring": "Complete dependency graph for a project.",
          "methods": [
            "knowledge",
            "knowledge",
            "save",
            "load",
            "get_module",
            "add_module",
            "add_edge",
            "_build_dependents_index",
            "get_deps",
            "get_dependents",
            "get_transitive_deps",
            "_get_transitive_deps_cached",
            "get_transitive_dependents",
            "topo_sort",
            "clear_caches",
            "stats"
          ],
          "line": 114
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "implement.py": {
      "path": "implement.py",
      "lang": "python",
      "lines": 725,
      "summary": "EriRPG Feature Implementation Planning",
      "interfaces": [
        {
          "name": "FeatureComponent",
          "type": "class",
          "signature": "",
          "docstring": "A component of a feature to implement.",
          "methods": [],
          "line": 24
        },
        {
          "name": "FilePlan",
          "type": "class",
          "signature": "",
          "docstring": "Plan for a single file.",
          "methods": [],
          "line": 33
        },
        {
          "name": "Phase",
          "type": "class",
          "signature": "",
          "docstring": "A phase of implementation.",
          "methods": [],
          "line": 47
        },
        {
          "name": "ImplementationPlan",
          "type": "class",
          "signature": "",
          "docstring": "Complete plan for implementing a feature.",
          "methods": [
            "to_dict"
          ],
          "line": 56
        },
        {
          "name": "COMPONENT_KEYWORDS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 94
        },
        {
          "name": "extract_components",
          "type": "function",
          "signature": "def extract_components(feature: str) -> List[FeatureComponent]",
          "docstring": "Parse feature description into components.",
          "methods": [],
          "line": 109
        },
        {
          "name": "detect_component_type",
          "type": "function",
          "signature": "def detect_component_type(text: str) -> str",
          "docstring": "Detect component type from text.",
          "methods": [],
          "line": 169
        },
        {
          "name": "generate_component_name",
          "type": "function",
          "signature": "def generate_component_name(text: str, comp_type: str) -> str",
          "docstring": "Generate a component name from description.",
          "methods": [],
          "line": 179
        },
        {
          "name": "to_pascal_case",
          "type": "function",
          "signature": "def to_pascal_case(text: str) -> str",
          "docstring": "Convert text to PascalCase.",
          "methods": [],
          "line": 203
        },
        {
          "name": "to_snake_case",
          "type": "function",
          "signature": "def to_snake_case(text: str) -> str",
          "docstring": "Convert text to snake_case.",
          "methods": [],
          "line": 209
        },
        {
          "name": "map_component_to_target",
          "type": "function",
          "signature": "def map_component_to_target(comp: FeatureComponent, patterns: ProjectPatterns) -> FilePlan",
          "docstring": "Map component to target location using patterns.",
          "methods": [],
          "line": 216
        },
        {
          "name": "find_needed_registrations",
          "type": "function",
          "signature": "def find_needed_registrations(file_plan: List[FilePlan], patterns: ProjectPatterns) -> List[str]",
          "docstring": "Identify registrations needed for new components.",
          "methods": [],
          "line": 274
        },
        {
          "name": "find_relevant_hooks",
          "type": "function",
          "signature": "def find_relevant_hooks(components: List[FeatureComponent], patterns: ProjectPatterns) -> List[str]",
          "docstring": "Find hooks that the feature should use.",
          "methods": [],
          "line": 295
        },
        {
          "name": "create_phases",
          "type": "function",
          "signature": "def create_phases(file_plan: List[FilePlan], registrations: List[str], hooks: List[str]) -> List[Phase]",
          "docstring": "Order implementation into phases.",
          "methods": [],
          "line": 323
        },
        {
          "name": "plan_implementation",
          "type": "function",
          "signature": "def plan_implementation(project_path: str, feature: str, use_drift: bool) -> ImplementationPlan",
          "docstring": "Generate implementation plan for a feature.",
          "methods": [],
          "line": 390
        },
        {
          "name": "_enrich_with_drift_impact",
          "type": "function",
          "signature": "def _enrich_with_drift_impact(plan: ImplementationPlan, project_path: str) -> ImplementationPlan",
          "docstring": "Enrich implementation plan with Drift impact analysis.",
          "methods": [],
          "line": 458
        },
        {
          "name": "describe_feature",
          "type": "function",
          "signature": "def describe_feature(project_path: str, file_path: str) -> str",
          "docstring": "Extract feature description from a source file.",
          "methods": [],
          "line": 550
        },
        {
          "name": "format_implementation_plan",
          "type": "function",
          "signature": "def format_implementation_plan(plan: ImplementationPlan) -> str",
          "docstring": "Format implementation plan for display.",
          "methods": [],
          "line": 597
        },
        {
          "name": "plan_to_spec",
          "type": "function",
          "signature": "def plan_to_spec(plan: ImplementationPlan, project_path: str) -> Dict[str, Any]",
          "docstring": "Convert implementation plan to EriRPG spec.",
          "methods": [],
          "line": 651
        }
      ],
      "deps_internal": [
        "graph.py",
        "analyze.py",
        "memory.py"
      ],
      "deps_external": []
    },
    "memory.py": {
      "path": "memory.py",
      "lang": "python",
      "lines": 2086,
      "summary": "Persistent semantic memory for EriRPG.",
      "interfaces": [
        {
          "name": "hash_file",
          "type": "function",
          "signature": "def hash_file(path: str) -> str",
          "docstring": "Get SHA256 hash of file content (first 16 chars).",
          "methods": [],
          "line": 35
        },
        {
          "name": "read_file_content",
          "type": "function",
          "signature": "def read_file_content(path: str) -> str",
          "docstring": "Read file content safely.",
          "methods": [],
          "line": 46
        },
        {
          "name": "git_head",
          "type": "function",
          "signature": "def git_head() -> Optional[str]",
          "docstring": "Get current git HEAD commit (first 12 chars).",
          "methods": [],
          "line": 55
        },
        {
          "name": "in_git_repo",
          "type": "function",
          "signature": "def in_git_repo() -> bool",
          "docstring": "Check if we're in a git repo.",
          "methods": [],
          "line": 71
        },
        {
          "name": "LearningVersion",
          "type": "class",
          "signature": "",
          "docstring": "Snapshot of a learning at a point in time.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 81
        },
        {
          "name": "RollbackResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of a file rollback operation.",
          "methods": [
            "format",
            "to_dict"
          ],
          "line": 146
        },
        {
          "name": "RunRecord",
          "type": "class",
          "signature": "",
          "docstring": "Record of a command execution for context tracking.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 225
        },
        {
          "name": "StoredLearning",
          "type": "class",
          "signature": "",
          "docstring": "A learning stored in the knowledge store.",
          "methods": [
            "is_stale",
            "snapshot",
            "rollback",
            "rollback_files",
            "can_rollback_files",
            "get_version",
            "history_summary",
            "enrich_with_drift",
            "_matches_drift_pattern",
            "_is_about_outlier",
            "format_for_context",
            "to_dict",
            "from_dict"
          ],
          "line": 270
        },
        {
          "name": "StoredDecision",
          "type": "class",
          "signature": "",
          "docstring": "An architectural or design decision stored in knowledge.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 763
        },
        {
          "name": "Decision",
          "type": "class",
          "signature": "",
          "docstring": "A decision made during discussion or execution.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 798
        },
        {
          "name": "DeferredIdea",
          "type": "class",
          "signature": "",
          "docstring": "An idea deferred for later implementation.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 844
        },
        {
          "name": "Blocker",
          "type": "class",
          "signature": "",
          "docstring": "A known blocker or issue.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 883
        },
        {
          "name": "SessionState",
          "type": "class",
          "signature": "",
          "docstring": "Rich session state for handoff between sessions.",
          "methods": [
            "add_decision",
            "add_blocker",
            "resolve_blocker",
            "add_deferred",
            "add_next_action",
            "update_position",
            "touch",
            "format_handoff",
            "to_dict",
            "from_dict"
          ],
          "line": 915
        },
        {
          "name": "Gap",
          "type": "class",
          "signature": "",
          "docstring": "A verification gap to be fixed.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 1068
        },
        {
          "name": "Milestone",
          "type": "class",
          "signature": "",
          "docstring": "A phase/milestone in a roadmap.",
          "methods": [
            "done",
            "complete",
            "to_dict",
            "from_dict"
          ],
          "line": 1104
        },
        {
          "name": "Roadmap",
          "type": "class",
          "signature": "",
          "docstring": "A multi-phase roadmap for achieving a goal.",
          "methods": [
            "make_id",
            "create",
            "add_milestone",
            "current_milestone",
            "current_index",
            "advance",
            "progress",
            "progress_percent",
            "is_complete",
            "to_dict",
            "from_dict"
          ],
          "line": 1148
        },
        {
          "name": "Discussion",
          "type": "class",
          "signature": "",
          "docstring": "A goal clarification discussion with optional roadmap.",
          "methods": [
            "make_id",
            "create",
            "answer",
            "unanswered",
            "is_complete",
            "resolve",
            "summary",
            "to_dict",
            "from_dict"
          ],
          "line": 1236
        },
        {
          "name": "KnowledgeStore",
          "type": "class",
          "signature": "",
          "docstring": "Persistent semantic knowledge store.",
          "methods": [
            "add_learning",
            "get_learning",
            "has_learning",
            "remove_learning",
            "list_modules",
            "add_decision",
            "get_decisions_for_module",
            "add_pattern",
            "get_pattern",
            "add_discussion",
            "get_discussion",
            "get_discussion_by_goal",
            "remove_discussion",
            "clear_discussions",
            "list_discussions",
            "add_run",
            "get_recent_runs",
            "get_stale_learnings",
            "get_fresh_learnings",
            "search",
            "add_user_decision",
            "get_user_decisions",
            "search_decisions",
            "next_decision_id",
            "add_deferred_idea",
            "get_deferred_ideas",
            "get_deferred_by_tag",
            "promote_idea",
            "next_idea_id",
            "stats",
            "save",
            "load"
          ],
          "line": 1323
        },
        {
          "name": "get_knowledge_path",
          "type": "function",
          "signature": "def get_knowledge_path(project_path: str) -> str",
          "docstring": "Get the path to knowledge.json for a project.",
          "methods": [],
          "line": 1628
        },
        {
          "name": "load_knowledge",
          "type": "function",
          "signature": "def load_knowledge(project_path: str, project_name: str) -> KnowledgeStore",
          "docstring": "Load knowledge store for a project.",
          "methods": [],
          "line": 1640
        },
        {
          "name": "save_knowledge",
          "type": "function",
          "signature": "def save_knowledge(project_path: str, store: KnowledgeStore) -> None",
          "docstring": "Save knowledge store for a project.",
          "methods": [],
          "line": 1657
        },
        {
          "name": "LearningUpdatePolicy",
          "type": "class",
          "signature": "",
          "docstring": "How to update learnings based on operation type.",
          "methods": [],
          "line": 1672
        },
        {
          "name": "update_learning_with_operation",
          "type": "function",
          "signature": "def update_learning_with_operation(store: KnowledgeStore, module_path: str, operation: str, new_understanding: dict, project_path: str, source_learning: Optional[StoredLearning], change_description: str) -> StoredLearning",
          "docstring": "Update learning based on operation type.",
          "methods": [],
          "line": 1680
        },
        {
          "name": "get_session_path",
          "type": "function",
          "signature": "def get_session_path(project_path: str, run_id: str) -> str",
          "docstring": "Get path to session state file.",
          "methods": [],
          "line": 1839
        },
        {
          "name": "save_session_state",
          "type": "function",
          "signature": "def save_session_state(project_path: str, state: 'SessionState') -> None",
          "docstring": "Save session state to file.",
          "methods": [],
          "line": 1844
        },
        {
          "name": "load_session_state",
          "type": "function",
          "signature": "def load_session_state(project_path: str, run_id: str) -> Optional['SessionState']",
          "docstring": "Load session state from file.",
          "methods": [],
          "line": 1853
        },
        {
          "name": "get_latest_session",
          "type": "function",
          "signature": "def get_latest_session(project_path: str) -> Optional['SessionState']",
          "docstring": "Get the most recent session state.",
          "methods": [],
          "line": 1867
        },
        {
          "name": "create_session",
          "type": "function",
          "signature": "def create_session(project_path: str, run_id: str) -> 'SessionState'",
          "docstring": "Create a new session state.",
          "methods": [],
          "line": 1888
        },
        {
          "name": "analyze_gaps",
          "type": "function",
          "signature": "def analyze_gaps(project_path: str, run_id: str) -> List['Gap']",
          "docstring": "Analyze verification failures and identify gaps.",
          "methods": [],
          "line": 1903
        },
        {
          "name": "_generate_fix_suggestion",
          "type": "function",
          "signature": "def _generate_fix_suggestion(step: dict) -> str",
          "docstring": "Generate a suggested fix based on step failure.",
          "methods": [],
          "line": 1938
        },
        {
          "name": "save_gaps",
          "type": "function",
          "signature": "def save_gaps(project_path: str, run_id: str, gaps: List['Gap']) -> str",
          "docstring": "Save gaps to a file for later processing.",
          "methods": [],
          "line": 1953
        },
        {
          "name": "load_gaps",
          "type": "function",
          "signature": "def load_gaps(project_path: str, run_id: str) -> List['Gap']",
          "docstring": "Load gaps from file.",
          "methods": [],
          "line": 1964
        },
        {
          "name": "enrich_learnings_batch",
          "type": "function",
          "signature": "def enrich_learnings_batch(project_path: str, force: bool) -> dict",
          "docstring": "Batch enrich all stored learnings with Drift pattern data.",
          "methods": [],
          "line": 1982
        },
        {
          "name": "get_drift_status",
          "type": "function",
          "signature": "def get_drift_status(project_path: str) -> dict",
          "docstring": "Get Drift integration status for a project.",
          "methods": [],
          "line": 2065
        }
      ],
      "deps_internal": [
        "refs.py"
      ],
      "deps_external": []
    },
    "workflow.py": {
      "path": "workflow.py",
      "lang": "python",
      "lines": 122,
      "summary": "Workflow stage management with persona integration.",
      "interfaces": [
        {
          "name": "Stage",
          "type": "class",
          "signature": "",
          "docstring": "Workflow stages - each implies a default persona.",
          "methods": [],
          "line": 18
        },
        {
          "name": "get_persona_for_stage",
          "type": "function",
          "signature": "def get_persona_for_stage(stage: Stage) -> Persona",
          "docstring": "Get the default persona for a workflow stage.",
          "methods": [],
          "line": 65
        },
        {
          "name": "get_stage_description",
          "type": "function",
          "signature": "def get_stage_description(stage: Stage) -> str",
          "docstring": "Human-readable stage description.",
          "methods": [],
          "line": 70
        },
        {
          "name": "get_stage_by_name",
          "type": "function",
          "signature": "def get_stage_by_name(name: str) -> Optional[Stage]",
          "docstring": "Get stage enum by name string.",
          "methods": [],
          "line": 75
        },
        {
          "name": "list_stages",
          "type": "function",
          "signature": "def list_stages() -> list[str]",
          "docstring": "List all available stage names.",
          "methods": [],
          "line": 84
        },
        {
          "name": "can_transition",
          "type": "function",
          "signature": "def can_transition(from_stage: Stage, to_stage: Stage) -> bool",
          "docstring": "Check if a stage transition is valid.",
          "methods": [],
          "line": 89
        },
        {
          "name": "get_next_stages",
          "type": "function",
          "signature": "def get_next_stages(current: Stage) -> list[Stage]",
          "docstring": "Get valid next stages from current stage.",
          "methods": [],
          "line": 95
        },
        {
          "name": "detect_stage_from_input",
          "type": "function",
          "signature": "def detect_stage_from_input(user_input: str) -> Optional[Stage]",
          "docstring": "Detect workflow stage from user input.",
          "methods": [],
          "line": 100
        }
      ],
      "deps_internal": [
        "persona.py"
      ],
      "deps_external": []
    },
    "pattern_sync.py": {
      "path": "pattern_sync.py",
      "lang": "python",
      "lines": 513,
      "summary": "Sync patterns between EriRPG and Drift.",
      "interfaces": [
        {
          "name": "SyncResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of a pattern sync operation.",
          "methods": [
            "__post_init__",
            "to_dict"
          ],
          "line": 24
        },
        {
          "name": "sync_patterns",
          "type": "function",
          "signature": "def sync_patterns(project_path: str, direction: str) -> SyncResult",
          "docstring": "Sync patterns between .eri-rpg/patterns.json and .drift/patterns/",
          "methods": [],
          "line": 46
        },
        {
          "name": "_import_from_drift",
          "type": "function",
          "signature": "def _import_from_drift(eri_path: Path, drift_path: Path) -> int",
          "docstring": "Import Drift patterns into EriRPG format.",
          "methods": [],
          "line": 82
        },
        {
          "name": "_export_to_drift",
          "type": "function",
          "signature": "def _export_to_drift(eri_path: Path, drift_path: Path) -> int",
          "docstring": "Export EriRPG patterns to Drift-compatible format.",
          "methods": [],
          "line": 177
        },
        {
          "name": "_to_slug",
          "type": "function",
          "signature": "def _to_slug(text: str) -> str",
          "docstring": "Convert text to URL-friendly slug.",
          "methods": [],
          "line": 271
        },
        {
          "name": "get_combined_confidence",
          "type": "function",
          "signature": "def get_combined_confidence(project_path: str, pattern_type: str) -> float",
          "docstring": "Get combined confidence from both EriRPG and Drift.",
          "methods": [],
          "line": 283
        },
        {
          "name": "get_all_patterns",
          "type": "function",
          "signature": "def get_all_patterns(project_path: str) -> Dict[str, Any]",
          "docstring": "Get all patterns from both EriRPG and Drift.",
          "methods": [],
          "line": 362
        },
        {
          "name": "get_sync_status",
          "type": "function",
          "signature": "def get_sync_status(project_path: str) -> Dict[str, Any]",
          "docstring": "Get status of pattern sync between EriRPG and Drift.",
          "methods": [],
          "line": 457
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "indexer.py": {
      "path": "indexer.py",
      "lang": "python",
      "lines": 396,
      "summary": "Code indexer for building dependency graphs.",
      "interfaces": [
        {
          "name": "STDLIB_MODULES",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 37
        },
        {
          "name": "index_project",
          "type": "function",
          "signature": "def index_project(project: Project, verbose: bool) -> Graph",
          "docstring": "Index a project and build its dependency graph.",
          "methods": [],
          "line": 74
        },
        {
          "name": "_find_python_files",
          "type": "function",
          "signature": "def _find_python_files(root: str) -> List[str]",
          "docstring": "Find all Python files in a directory tree.",
          "methods": [],
          "line": 254
        },
        {
          "name": "_find_c_files",
          "type": "function",
          "signature": "def _find_c_files(root: str) -> List[str]",
          "docstring": "Find all C/C++ files in a directory tree.",
          "methods": [],
          "line": 284
        },
        {
          "name": "_find_rust_files",
          "type": "function",
          "signature": "def _find_rust_files(root: str) -> List[str]",
          "docstring": "Find all Rust files in a directory tree.",
          "methods": [],
          "line": 313
        },
        {
          "name": "_find_mojo_files",
          "type": "function",
          "signature": "def _find_mojo_files(root: str) -> List[str]",
          "docstring": "Find all Mojo files in a directory tree.",
          "methods": [],
          "line": 339
        },
        {
          "name": "get_or_load_graph",
          "type": "function",
          "signature": "def get_or_load_graph(project: Project, prefer_sqlite: bool) -> Graph",
          "docstring": "Get project graph, loading from SQLite or JSON.",
          "methods": [],
          "line": 369
        }
      ],
      "deps_internal": [
        "registry.py",
        "parsers/python.py",
        "parsers/rust.py",
        "graph.py",
        "parsers/mojo.py",
        "parsers/c.py"
      ],
      "deps_external": [
        "erirpg"
      ]
    },
    "runs.py": {
      "path": "runs.py",
      "lang": "python",
      "lines": 430,
      "summary": "Run record storage for EriRPG.",
      "interfaces": [
        {
          "name": "RunStatus",
          "type": "class",
          "signature": "",
          "docstring": "Status of a run.",
          "methods": [],
          "line": 26
        },
        {
          "name": "StepResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of executing a single step.",
          "methods": [
            "to_dict",
            "from_dict",
            "duration"
          ],
          "line": 37
        },
        {
          "name": "RunRecord",
          "type": "class",
          "signature": "",
          "docstring": "Record of a plan execution run.",
          "methods": [
            "validate",
            "to_dict",
            "from_dict",
            "get_step_result",
            "add_step_result",
            "duration",
            "completed_steps",
            "failed_steps",
            "format_summary"
          ],
          "line": 84
        },
        {
          "name": "get_runs_dir",
          "type": "function",
          "signature": "def get_runs_dir(project_path: str) -> str",
          "docstring": "Get the runs directory for a project.",
          "methods": [],
          "line": 219
        },
        {
          "name": "get_run_dir",
          "type": "function",
          "signature": "def get_run_dir(project_path: str, run_id: str) -> str",
          "docstring": "Get directory for a specific run.",
          "methods": [],
          "line": 224
        },
        {
          "name": "_generate_run_id",
          "type": "function",
          "signature": "def _generate_run_id(plan_id: str) -> str",
          "docstring": "Generate a unique run ID.",
          "methods": [],
          "line": 229
        },
        {
          "name": "create_run",
          "type": "function",
          "signature": "def create_run(plan: 'Plan', project_path: str) -> RunRecord",
          "docstring": "Create a new run record for a plan.",
          "methods": [],
          "line": 239
        },
        {
          "name": "save_run",
          "type": "function",
          "signature": "def save_run(project_path: str, run: RunRecord) -> str",
          "docstring": "Save a run record to disk.",
          "methods": [],
          "line": 276
        },
        {
          "name": "load_run",
          "type": "function",
          "signature": "def load_run(project_path: str, run_id: str) -> Optional[RunRecord]",
          "docstring": "Load a run record from disk.",
          "methods": [],
          "line": 296
        },
        {
          "name": "delete_run",
          "type": "function",
          "signature": "def delete_run(project_path: str, run_id: str) -> bool",
          "docstring": "Delete a run and all its artifacts.",
          "methods": [],
          "line": 317
        },
        {
          "name": "list_run_ids",
          "type": "function",
          "signature": "def list_run_ids(project_path: str) -> List[str]",
          "docstring": "List all run IDs in a project.",
          "methods": [],
          "line": 336
        },
        {
          "name": "get_latest_run",
          "type": "function",
          "signature": "def get_latest_run(project_path: str) -> Optional[RunRecord]",
          "docstring": "Get the most recent run for a project.",
          "methods": [],
          "line": 364
        },
        {
          "name": "save_artifact",
          "type": "function",
          "signature": "def save_artifact(project_path: str, run_id: str, step_id: str, name: str, content: str) -> str",
          "docstring": "Save an artifact for a step.",
          "methods": [],
          "line": 380
        },
        {
          "name": "get_artifacts",
          "type": "function",
          "signature": "def get_artifacts(project_path: str, run_id: str, step_id: str) -> List[str]",
          "docstring": "Get all artifacts for a step.",
          "methods": [],
          "line": 409
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "state.py": {
      "path": "state.py",
      "lang": "python",
      "lines": 185,
      "summary": "State tracking for orchestration mode.",
      "interfaces": [
        {
          "name": "State",
          "type": "class",
          "signature": "",
          "docstring": "Orchestration state for tracking progress.",
          "methods": [
            "__post_init__",
            "update",
            "log",
            "reset",
            "set_active_project",
            "get_active_project",
            "get_next_step",
            "save",
            "load",
            "format_status"
          ],
          "line": 16
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "planner.py": {
      "path": "planner.py",
      "lang": "python",
      "lines": 1445,
      "summary": "Planner for EriRPG.",
      "interfaces": [
        {
          "name": "PLAN_VERSION",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 26
        },
        {
          "name": "StepType",
          "type": "class",
          "signature": "",
          "docstring": "Types of plan steps.",
          "methods": [],
          "line": 29
        },
        {
          "name": "StepStatus",
          "type": "class",
          "signature": "",
          "docstring": "Step execution status.",
          "methods": [],
          "line": 42
        },
        {
          "name": "RiskLevel",
          "type": "class",
          "signature": "",
          "docstring": "Risk level for steps.",
          "methods": [],
          "line": 51
        },
        {
          "name": "_generate_step_id",
          "type": "function",
          "signature": "def _generate_step_id(step_type: str, target: str, index: int) -> str",
          "docstring": "Generate a deterministic step ID.",
          "methods": [],
          "line": 59
        },
        {
          "name": "_generate_plan_id",
          "type": "function",
          "signature": "def _generate_plan_id(spec_id: str) -> str",
          "docstring": "Generate a plan ID from spec ID.",
          "methods": [],
          "line": 66
        },
        {
          "name": "PlanStep",
          "type": "class",
          "signature": "",
          "docstring": "A single step in an execution plan.",
          "methods": [
            "validate",
            "to_dict",
            "from_dict",
            "mark_in_progress",
            "mark_completed",
            "mark_failed",
            "mark_skipped"
          ],
          "line": 73
        },
        {
          "name": "Plan",
          "type": "class",
          "signature": "",
          "docstring": "An execution plan with ordered steps.",
          "methods": [
            "validate",
            "_has_cycles",
            "get_step",
            "get_next_step",
            "get_ready_steps",
            "update_stats",
            "to_dict",
            "from_dict",
            "save",
            "load",
            "format_summary"
          ],
          "line": 202
        },
        {
          "name": "_compute_context_hash",
          "type": "function",
          "signature": "def _compute_context_hash(graph: Any, knowledge: Any) -> str",
          "docstring": "Compute hash of graph + knowledge state for reproducibility.",
          "methods": [],
          "line": 431
        },
        {
          "name": "_assess_risk",
          "type": "function",
          "signature": "def _assess_risk(module_path: str, graph: Any, action: str) -> Tuple[str, str]",
          "docstring": "Assess risk level for modifying a module.",
          "methods": [],
          "line": 450
        },
        {
          "name": "generate_plan_for_task",
          "type": "function",
          "signature": "def generate_plan_for_task(spec: TaskSpec, graph: Any, knowledge: Any) -> Plan",
          "docstring": "Generate an execution plan for a TaskSpec.",
          "methods": [],
          "line": 479
        },
        {
          "name": "_generate_extract_steps",
          "type": "function",
          "signature": "def _generate_extract_steps(spec: TaskSpec, graph: Any, knowledge: Any, start_index: int) -> List[PlanStep]",
          "docstring": "Generate steps for an extract task.",
          "methods": [],
          "line": 526
        },
        {
          "name": "_generate_plan_task_steps",
          "type": "function",
          "signature": "def _generate_plan_task_steps(spec: TaskSpec, graph: Any, knowledge: Any, start_index: int) -> List[PlanStep]",
          "docstring": "Generate steps for a plan task.",
          "methods": [],
          "line": 597
        },
        {
          "name": "_generate_implement_steps",
          "type": "function",
          "signature": "def _generate_implement_steps(spec: TaskSpec, graph: Any, knowledge: Any, start_index: int) -> List[PlanStep]",
          "docstring": "Generate steps for an implement task.",
          "methods": [],
          "line": 653
        },
        {
          "name": "_generate_validate_steps",
          "type": "function",
          "signature": "def _generate_validate_steps(spec: TaskSpec, graph: Any, knowledge: Any, start_index: int) -> List[PlanStep]",
          "docstring": "Generate steps for a validate task.",
          "methods": [],
          "line": 720
        },
        {
          "name": "_generate_generic_steps",
          "type": "function",
          "signature": "def _generate_generic_steps(spec: TaskSpec, graph: Any, knowledge: Any, start_index: int) -> List[PlanStep]",
          "docstring": "Generate generic steps for untyped tasks.",
          "methods": [],
          "line": 771
        },
        {
          "name": "generate_plan_for_project",
          "type": "function",
          "signature": "def generate_plan_for_project(spec: ProjectSpec, graph: Any, knowledge: Any) -> Plan",
          "docstring": "Generate an execution plan for a ProjectSpec.",
          "methods": [],
          "line": 822
        },
        {
          "name": "generate_plan_for_transplant",
          "type": "function",
          "signature": "def generate_plan_for_transplant(spec: TransplantSpec, graph: Any, knowledge: Any) -> Plan",
          "docstring": "Generate an execution plan for a TransplantSpec.",
          "methods": [],
          "line": 887
        },
        {
          "name": "generate_plan",
          "type": "function",
          "signature": "def generate_plan(spec: BaseSpec, graph: Any, knowledge: Any) -> Plan",
          "docstring": "Generate an execution plan for any spec type.",
          "methods": [],
          "line": 982
        },
        {
          "name": "order_steps_by_dependencies",
          "type": "function",
          "signature": "def order_steps_by_dependencies(steps: List[PlanStep]) -> List[PlanStep]",
          "docstring": "Order steps respecting dependencies (topological sort).",
          "methods": [],
          "line": 1005
        },
        {
          "name": "get_plans_dir",
          "type": "function",
          "signature": "def get_plans_dir(project_path: str) -> str",
          "docstring": "Get the plans directory for a project.",
          "methods": [],
          "line": 1047
        },
        {
          "name": "list_plans",
          "type": "function",
          "signature": "def list_plans(project_path: str) -> List[str]",
          "docstring": "List all plans in a project.",
          "methods": [],
          "line": 1052
        },
        {
          "name": "save_plan_to_project",
          "type": "function",
          "signature": "def save_plan_to_project(plan: Plan, project_path: str) -> str",
          "docstring": "Save a plan to the project's plans directory.",
          "methods": [],
          "line": 1065
        },
        {
          "name": "Planner",
          "type": "class",
          "signature": "",
          "docstring": "Generates execution specs from goals.",
          "methods": [
            "plan",
            "_is_transplant",
            "_is_refactor",
            "_is_create",
            "_is_modify",
            "_is_fix",
            "_plan_transplant_steps",
            "_plan_refactor_steps",
            "_plan_create_steps",
            "_plan_modify_steps",
            "_plan_fix_steps",
            "_plan_generic_steps",
            "_find_targets",
            "_detect_verification",
            "_get_unknown_files",
            "_get_dependencies",
            "_get_dependents"
          ],
          "line": 1082
        }
      ],
      "deps_internal": [
        "specs.py"
      ],
      "deps_external": []
    },
    "specs.py": {
      "path": "specs.py",
      "lang": "python",
      "lines": 637,
      "summary": "Spec models for EriRPG.",
      "interfaces": [
        {
          "name": "SPEC_VERSION",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 26
        },
        {
          "name": "SpecType",
          "type": "class",
          "signature": "",
          "docstring": "Types of specs supported.",
          "methods": [],
          "line": 29
        },
        {
          "name": "ValidationError",
          "type": "class",
          "signature": "",
          "docstring": "Raised when spec validation fails.",
          "methods": [
            "__init__",
            "_format_message"
          ],
          "line": 36
        },
        {
          "name": "_generate_spec_id",
          "type": "function",
          "signature": "def _generate_spec_id(spec_type: str, name: str) -> str",
          "docstring": "Generate a deterministic spec ID from type and name.",
          "methods": [],
          "line": 53
        },
        {
          "name": "_normalize_path",
          "type": "function",
          "signature": "def _normalize_path(path: str) -> str",
          "docstring": "Normalize a path string.",
          "methods": [],
          "line": 71
        },
        {
          "name": "_normalize_string",
          "type": "function",
          "signature": "def _normalize_string(value: str) -> str",
          "docstring": "Normalize a string value (trim whitespace).",
          "methods": [],
          "line": 79
        },
        {
          "name": "BaseSpec",
          "type": "class",
          "signature": "",
          "docstring": "Base class for all specs.",
          "methods": [
            "validate",
            "normalize",
            "to_dict",
            "from_dict",
            "save",
            "load"
          ],
          "line": 85
        },
        {
          "name": "TaskSpec",
          "type": "class",
          "signature": "",
          "docstring": "Spec for a task to perform.",
          "methods": [
            "validate",
            "normalize",
            "to_dict",
            "from_dict"
          ],
          "line": 147
        },
        {
          "name": "ProjectSpec",
          "type": "class",
          "signature": "",
          "docstring": "Spec for a new project to create.",
          "methods": [
            "validate",
            "normalize",
            "to_dict",
            "from_dict"
          ],
          "line": 263
        },
        {
          "name": "TransplantSpec",
          "type": "class",
          "signature": "",
          "docstring": "Spec for a feature transplant between projects.",
          "methods": [
            "validate",
            "normalize",
            "to_dict",
            "from_dict"
          ],
          "line": 351
        },
        {
          "name": "create_spec",
          "type": "function",
          "signature": "def create_spec(spec_type: str, **kwargs) -> BaseSpec",
          "docstring": "Factory function to create a spec by type.",
          "methods": [],
          "line": 445
        },
        {
          "name": "load_spec",
          "type": "function",
          "signature": "def load_spec(path: str) -> BaseSpec",
          "docstring": "Load a spec from file, auto-detecting type.",
          "methods": [],
          "line": 469
        },
        {
          "name": "validate_spec",
          "type": "function",
          "signature": "def validate_spec(spec: BaseSpec) -> Tuple[bool, List[str]]",
          "docstring": "Validate a spec and return result.",
          "methods": [],
          "line": 495
        },
        {
          "name": "get_spec_template",
          "type": "function",
          "signature": "def get_spec_template(spec_type: str) -> Dict[str, Any]",
          "docstring": "Get a template for a spec type.",
          "methods": [],
          "line": 508
        },
        {
          "name": "get_specs_dir",
          "type": "function",
          "signature": "def get_specs_dir(project_path: str) -> str",
          "docstring": "Get the specs directory for a project.",
          "methods": [],
          "line": 575
        },
        {
          "name": "list_specs",
          "type": "function",
          "signature": "def list_specs(project_path: str, spec_type: Optional[str]) -> List[str]",
          "docstring": "List all specs in a project.",
          "methods": [],
          "line": 587
        },
        {
          "name": "save_spec_to_project",
          "type": "function",
          "signature": "def save_spec_to_project(spec: BaseSpec, project_path: str) -> str",
          "docstring": "Save a spec to the project's specs directory.",
          "methods": [],
          "line": 618
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "spec.py": {
      "path": "spec.py",
      "lang": "python",
      "lines": 604,
      "summary": "Spec-driven execution format for EriRPG.",
      "interfaces": [
        {
          "name": "Step",
          "type": "class",
          "signature": "",
          "docstring": "A single step in an execution spec.",
          "methods": [
            "to_dict",
            "from_dict",
            "is_blocked"
          ],
          "line": 29
        },
        {
          "name": "Artifact",
          "type": "class",
          "signature": "",
          "docstring": "Expected output artifact from a spec execution.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 97
        },
        {
          "name": "KeyLink",
          "type": "class",
          "signature": "",
          "docstring": "Expected import/dependency link between files.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 126
        },
        {
          "name": "MustHaves",
          "type": "class",
          "signature": "",
          "docstring": "Verification requirements for a spec.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 152
        },
        {
          "name": "SpecStep",
          "type": "class",
          "signature": "",
          "docstring": "A goal-based step (legacy/compatibility format).",
          "methods": [
            "from_dict",
            "to_dict",
            "to_step"
          ],
          "line": 181
        },
        {
          "name": "Spec",
          "type": "class",
          "signature": "",
          "docstring": "A complete execution specification.",
          "methods": [
            "generate",
            "load",
            "from_file",
            "from_dict",
            "from_goal",
            "to_dict",
            "save",
            "get_step",
            "current_step",
            "next_step",
            "is_complete",
            "progress",
            "start_step",
            "complete_step",
            "fail_step",
            "format_status",
            "verify_must_haves"
          ],
          "line": 224
        },
        {
          "name": "generate_spec_id",
          "type": "function",
          "signature": "def generate_spec_id(goal: str) -> str",
          "docstring": "Generate a unique spec ID from goal.",
          "methods": [],
          "line": 599
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "yaml"
      ]
    },
    "drift_bridge.py": {
      "path": "drift_bridge.py",
      "lang": "python",
      "lines": 596,
      "summary": "Bridge to Drift codebase intelligence.",
      "interfaces": [
        {
          "name": "DriftPattern",
          "type": "class",
          "signature": "",
          "docstring": "Pattern detected by Drift.",
          "methods": [
            "from_dict"
          ],
          "line": 22
        },
        {
          "name": "DriftImpact",
          "type": "class",
          "signature": "",
          "docstring": "Impact analysis result from Drift callgraph.",
          "methods": [
            "from_dict"
          ],
          "line": 45
        },
        {
          "name": "DriftOutlier",
          "type": "class",
          "signature": "",
          "docstring": "Code that deviates from established patterns.",
          "methods": [
            "from_dict"
          ],
          "line": 64
        },
        {
          "name": "DriftFilePatterns",
          "type": "class",
          "signature": "",
          "docstring": "Patterns and outliers for a specific file.",
          "methods": [
            "from_dict"
          ],
          "line": 87
        },
        {
          "name": "DriftBridge",
          "type": "class",
          "signature": "",
          "docstring": "Interface to Drift CLI/MCP.",
          "methods": [
            "__init__",
            "_run_drift",
            "is_available",
            "scan",
            "clear_cache",
            "get_patterns",
            "get_file_patterns",
            "impact_analysis",
            "find_outliers",
            "validate_change",
            "get_confidence_for_pattern",
            "get_code_examples",
            "suggest_changes",
            "get_status"
          ],
          "line": 103
        },
        {
          "name": "drift_available",
          "type": "function",
          "signature": "def drift_available(project_path: str) -> bool",
          "docstring": "Quick check if Drift is available for a project.",
          "methods": [],
          "line": 593
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "ops.py": {
      "path": "ops.py",
      "lang": "python",
      "lines": 551,
      "summary": "Core operations: find, extract, impact, plan.",
      "interfaces": [
        {
          "name": "Feature",
          "type": "class",
          "signature": "",
          "docstring": "An extracted feature - self-contained unit of code.",
          "methods": [
            "code",
            "code",
            "hydrate_code",
            "get_stale_components",
            "save",
            "load"
          ],
          "line": 24
        },
        {
          "name": "Mapping",
          "type": "class",
          "signature": "",
          "docstring": "A mapping between source and target module/interface.",
          "methods": [
            "to_dict"
          ],
          "line": 168
        },
        {
          "name": "WiringTask",
          "type": "class",
          "signature": "",
          "docstring": "A wiring task for transplant.",
          "methods": [
            "to_dict"
          ],
          "line": 189
        },
        {
          "name": "TransplantPlan",
          "type": "class",
          "signature": "",
          "docstring": "Plan for transplanting a feature to a target project.",
          "methods": [
            "save",
            "load"
          ],
          "line": 200
        },
        {
          "name": "find_modules",
          "type": "function",
          "signature": "def find_modules(graph: Graph, query: str, limit: int) -> List[Tuple[Module, float]]",
          "docstring": "Find modules matching a query.",
          "methods": [],
          "line": 237
        },
        {
          "name": "_tokenize",
          "type": "function",
          "signature": "def _tokenize(text: str) -> Set[str]",
          "docstring": "Tokenize text into words.",
          "methods": [],
          "line": 297
        },
        {
          "name": "_jaccard",
          "type": "function",
          "signature": "def _jaccard(set1: Set[str], set2: Set[str]) -> float",
          "docstring": "Jaccard similarity between two sets.",
          "methods": [],
          "line": 302
        },
        {
          "name": "extract_feature",
          "type": "function",
          "signature": "def extract_feature(graph: Graph, project: Project, query: str, feature_name: str, snapshot: bool) -> Feature",
          "docstring": "Extract a feature from a project.",
          "methods": [],
          "line": 311
        },
        {
          "name": "analyze_impact",
          "type": "function",
          "signature": "def analyze_impact(graph: Graph, module_path: str) -> Dict",
          "docstring": "Analyze impact of changing a module.",
          "methods": [],
          "line": 420
        },
        {
          "name": "plan_transplant",
          "type": "function",
          "signature": "def plan_transplant(feature: Feature, target_graph: Graph, target_project: Project) -> TransplantPlan",
          "docstring": "Plan how to transplant a feature to a target project.",
          "methods": [],
          "line": 462
        },
        {
          "name": "_suggest_target_path",
          "type": "function",
          "signature": "def _suggest_target_path(source_path: str, target_project: Project) -> str",
          "docstring": "Suggest a target path for a new module.",
          "methods": [],
          "line": 545
        }
      ],
      "deps_internal": [
        "graph.py",
        "registry.py",
        "refs.py"
      ],
      "deps_external": []
    },
    "refs.py": {
      "path": "refs.py",
      "lang": "python",
      "lines": 162,
      "summary": "Code references for EriRPG.",
      "interfaces": [
        {
          "name": "CodeRef",
          "type": "class",
          "signature": "",
          "docstring": "Reference to a code location without storing full content.",
          "methods": [
            "is_stale",
            "hydrate",
            "from_file",
            "_compute_hash",
            "_compute_hash_static",
            "to_dict",
            "from_dict",
            "__repr__"
          ],
          "line": 19
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "install.py": {
      "path": "install.py",
      "lang": "python",
      "lines": 388,
      "summary": "One-command setup for Claude Code integration.",
      "interfaces": [
        {
          "name": "get_erirpg_root",
          "type": "function",
          "signature": "def get_erirpg_root() -> Path",
          "docstring": "Get the EriRPG installation root.",
          "methods": [],
          "line": 16
        },
        {
          "name": "install_claude_code",
          "type": "function",
          "signature": "def install_claude_code(verbose: bool) -> bool",
          "docstring": "Install EriRPG commands and hooks for Claude Code.",
          "methods": [],
          "line": 21
        },
        {
          "name": "uninstall_claude_code",
          "type": "function",
          "signature": "def uninstall_claude_code(verbose: bool) -> bool",
          "docstring": "Remove EriRPG from Claude Code.",
          "methods": [],
          "line": 132
        },
        {
          "name": "_create_default_commands",
          "type": "function",
          "signature": "def _create_default_commands(commands_dir: Path, verbose: bool) -> None",
          "docstring": "Create default slash commands if source doesn't exist.",
          "methods": [],
          "line": 193
        },
        {
          "name": "install_commands",
          "type": "function",
          "signature": "def install_commands(verbose: bool) -> bool",
          "docstring": "Install/sync only slash commands (no hooks).",
          "methods": [],
          "line": 273
        },
        {
          "name": "check_installation",
          "type": "function",
          "signature": "def check_installation() -> dict",
          "docstring": "Check current installation status.",
          "methods": [],
          "line": 321
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "sync.py": {
      "path": "sync.py",
      "lang": "python",
      "lines": 542,
      "summary": "Knowledge synchronization for EriRPG.",
      "interfaces": [
        {
          "name": "EXCLUDE_DIRS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 31
        },
        {
          "name": "EXTENSIONS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 46
        },
        {
          "name": "FileStatus",
          "type": "class",
          "signature": "",
          "docstring": "Status of a single file.",
          "methods": [],
          "line": 56
        },
        {
          "name": "SyncResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of a sync operation.",
          "methods": [
            "total_files",
            "needs_attention",
            "summary",
            "to_dict"
          ],
          "line": 66
        },
        {
          "name": "compute_file_hash",
          "type": "function",
          "signature": "def compute_file_hash(file_path: str) -> str",
          "docstring": "Compute SHA256 hash of file content.",
          "methods": [],
          "line": 137
        },
        {
          "name": "find_source_files",
          "type": "function",
          "signature": "def find_source_files(root: str, language: Optional[str]) -> List[str]",
          "docstring": "Find all source files in a directory tree.",
          "methods": [],
          "line": 149
        },
        {
          "name": "sync_knowledge",
          "type": "function",
          "signature": "def sync_knowledge(project_path: str, project_name: str, language: Optional[str], verbose: bool) -> SyncResult",
          "docstring": "Compare codebase files against knowledge.json.",
          "methods": [],
          "line": 198
        },
        {
          "name": "learn_file",
          "type": "function",
          "signature": "def learn_file(project_path: str, rel_path: str, store: KnowledgeStore) -> Tuple[bool, str]",
          "docstring": "Parse a file and create/update its StoredLearning.",
          "methods": [],
          "line": 299
        },
        {
          "name": "sync_and_learn",
          "type": "function",
          "signature": "def sync_and_learn(project_path: str, project_name: str, language: Optional[str], verbose: bool, update_preflight: bool) -> SyncResult",
          "docstring": "Sync knowledge and auto-learn unknown/stale files.",
          "methods": [],
          "line": 412
        },
        {
          "name": "_update_preflight_learnings_status",
          "type": "function",
          "signature": "def _update_preflight_learnings_status(project_path: str, store: KnowledgeStore) -> None",
          "docstring": "Update preflight_state.json with learnings_status for instant lookup.",
          "methods": [],
          "line": 478
        },
        {
          "name": "get_learnings_status",
          "type": "function",
          "signature": "def get_learnings_status(project_path: str) -> Dict[str, str]",
          "docstring": "Get cached learnings_status from preflight_state.json.",
          "methods": [],
          "line": 524
        }
      ],
      "deps_internal": [
        "memory.py",
        "refs.py"
      ],
      "deps_external": [
        "erirpg"
      ]
    },
    "claudemd.py": {
      "path": "claudemd.py",
      "lang": "python",
      "lines": 235,
      "summary": "CLAUDE.md generator for EriRPG.",
      "interfaces": [
        {
          "name": "generate_claude_md",
          "type": "function",
          "signature": "def generate_claude_md(project_path: str, project_name: str, description: str, patterns: List[str], decisions: List[str], key_modules: List[str], current_task: str, must_haves: List[str], roadmap: str, stage: Stage, persona: Persona, compact: bool) -> str",
          "docstring": "Generate CLAUDE.md content for a project.",
          "methods": [],
          "line": 30
        },
        {
          "name": "generate_claude_md_from_store",
          "type": "function",
          "signature": "def generate_claude_md_from_store(project_path: str, project_name: str, stage: Stage, persona: Persona, current_task: str, compact: bool) -> str",
          "docstring": "Generate CLAUDE.md from existing knowledge store.",
          "methods": [],
          "line": 97
        },
        {
          "name": "write_claude_md",
          "type": "function",
          "signature": "def write_claude_md(project_path: str, content: str) -> Path",
          "docstring": "Write CLAUDE.md to project directory.",
          "methods": [],
          "line": 141
        },
        {
          "name": "update_claude_md",
          "type": "function",
          "signature": "def update_claude_md(project_path: str, project_name: str, stage: Stage, persona: Persona, current_task: str) -> Path",
          "docstring": "Update CLAUDE.md from current knowledge store.",
          "methods": [],
          "line": 157
        },
        {
          "name": "_get_version",
          "type": "function",
          "signature": "def _get_version() -> str",
          "docstring": "Get EriRPG version.",
          "methods": [],
          "line": 190
        },
        {
          "name": "MINIMAL_TEMPLATE",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 200
        },
        {
          "name": "generate_minimal_claude_md",
          "type": "function",
          "signature": "def generate_minimal_claude_md(project_name: str) -> str",
          "docstring": "Generate minimal CLAUDE.md for projects without knowledge.",
          "methods": [],
          "line": 232
        }
      ],
      "deps_internal": [
        "workflow.py",
        "persona.py",
        "session_context.py"
      ],
      "deps_external": []
    },
    "migration.py": {
      "path": "migration.py",
      "lang": "python",
      "lines": 300,
      "summary": "Migration utilities for EriRPG storage format.",
      "interfaces": [
        {
          "name": "check_migration_needed",
          "type": "function",
          "signature": "def check_migration_needed(project_path: str) -> Tuple[bool, str]",
          "docstring": "Check if migration is needed for a project.",
          "methods": [],
          "line": 24
        },
        {
          "name": "migrate_knowledge",
          "type": "function",
          "signature": "def migrate_knowledge(project_path: str, project_name: str, create_refs: bool, backup: bool) -> dict",
          "docstring": "Migrate knowledge from graph.json to knowledge.json.",
          "methods": [],
          "line": 64
        },
        {
          "name": "remove_embedded_knowledge",
          "type": "function",
          "signature": "def remove_embedded_knowledge(project_path: str, backup: bool) -> bool",
          "docstring": "Remove embedded knowledge from graph.json after migration.",
          "methods": [],
          "line": 192
        },
        {
          "name": "auto_migrate_if_needed",
          "type": "function",
          "signature": "def auto_migrate_if_needed(project_path: str, project_name: str) -> Optional[dict]",
          "docstring": "Automatically migrate if needed, otherwise return None.",
          "methods": [],
          "line": 228
        },
        {
          "name": "get_migration_status",
          "type": "function",
          "signature": "def get_migration_status(project_path: str) -> dict",
          "docstring": "Get detailed migration status for a project.",
          "methods": [],
          "line": 249
        }
      ],
      "deps_internal": [
        "memory.py",
        "refs.py"
      ],
      "deps_external": []
    },
    "discovery.py": {
      "path": "discovery.py",
      "lang": "python",
      "lines": 122,
      "summary": "Discovery level detection for research pipeline.",
      "interfaces": [
        {
          "name": "ARCH_KEYWORDS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 11
        },
        {
          "name": "INTEGRATION_KEYWORDS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 14
        },
        {
          "name": "SKIP_KEYWORDS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 17
        },
        {
          "name": "DEP_PATTERN",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 20
        },
        {
          "name": "DISCRETION_PHRASES",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 29
        },
        {
          "name": "extract_deps",
          "type": "function",
          "signature": "def extract_deps(text: str) -> Set[str]",
          "docstring": "Extract known library/framework dependencies from text.",
          "methods": [],
          "line": 36
        },
        {
          "name": "detect_discovery_level",
          "type": "function",
          "signature": "def detect_discovery_level(goal: str, known_deps: Optional[Set[str]]) -> Tuple[int, str]",
          "docstring": "Detect how much research is needed for a goal.",
          "methods": [],
          "line": 50
        },
        {
          "name": "is_discretion_answer",
          "type": "function",
          "signature": "def is_discretion_answer(answer: str) -> bool",
          "docstring": "Check if user's answer indicates they want Claude to decide.",
          "methods": [],
          "line": 99
        },
        {
          "name": "get_level_description",
          "type": "function",
          "signature": "def get_level_description(level: int) -> str",
          "docstring": "Get human-readable description of discovery level.",
          "methods": [],
          "line": 113
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "benchmarks.py": {
      "path": "benchmarks.py",
      "lang": "python",
      "lines": 544,
      "summary": "Benchmarking system for EriRPG.",
      "interfaces": [
        {
          "name": "BenchmarkStep",
          "type": "class",
          "signature": "",
          "docstring": "A single step in a benchmark run.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 28
        },
        {
          "name": "Benchmark",
          "type": "class",
          "signature": "",
          "docstring": "A benchmark run measuring performance of a workflow.",
          "methods": [
            "start",
            "finish",
            "record_step",
            "total_duration",
            "success_rate",
            "total_manual_fixes",
            "failed_steps",
            "to_dict",
            "from_dict"
          ],
          "line": 62
        },
        {
          "name": "BenchmarkComparison",
          "type": "class",
          "signature": "",
          "docstring": "Comparison between two benchmark runs.",
          "methods": [
            "calculate_improvements",
            "format_report"
          ],
          "line": 166
        },
        {
          "name": "BacklogItem",
          "type": "class",
          "signature": "",
          "docstring": "An item in the improvement backlog.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 254
        },
        {
          "name": "Backlog",
          "type": "class",
          "signature": "",
          "docstring": "Collection of improvement backlog items.",
          "methods": [
            "add",
            "get_by_priority",
            "get_by_category",
            "get_open",
            "categorize_from_benchmark",
            "to_dict",
            "from_dict",
            "format_summary"
          ],
          "line": 297
        },
        {
          "name": "get_benchmarks_dir",
          "type": "function",
          "signature": "def get_benchmarks_dir(project_path: str) -> str",
          "docstring": "Get the benchmarks directory for a project.",
          "methods": [],
          "line": 443
        },
        {
          "name": "save_benchmark",
          "type": "function",
          "signature": "def save_benchmark(project_path: str, benchmark: Benchmark) -> str",
          "docstring": "Save a benchmark to disk.",
          "methods": [],
          "line": 448
        },
        {
          "name": "load_benchmark",
          "type": "function",
          "signature": "def load_benchmark(filepath: str) -> Benchmark",
          "docstring": "Load a benchmark from disk.",
          "methods": [],
          "line": 471
        },
        {
          "name": "list_benchmarks",
          "type": "function",
          "signature": "def list_benchmarks(project_path: str) -> List[str]",
          "docstring": "List all benchmark files for a project.",
          "methods": [],
          "line": 485
        },
        {
          "name": "save_backlog",
          "type": "function",
          "signature": "def save_backlog(project_path: str, backlog: Backlog) -> str",
          "docstring": "Save a backlog to disk.",
          "methods": [],
          "line": 506
        },
        {
          "name": "load_backlog",
          "type": "function",
          "signature": "def load_backlog(project_path: str) -> Optional[Backlog]",
          "docstring": "Load a backlog from disk.",
          "methods": [],
          "line": 526
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "discuss.py": {
      "path": "discuss.py",
      "lang": "python",
      "lines": 955,
      "summary": "Discussion mode for goal clarification.",
      "interfaces": [
        {
          "name": "DOMAIN_GRAY_AREAS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 34
        },
        {
          "name": "DOMAIN_FILE_PATTERNS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 81
        },
        {
          "name": "DOMAIN_KEYWORDS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 91
        },
        {
          "name": "detect_domain",
          "type": "function",
          "signature": "def detect_domain(goal: str, project_path: str) -> str",
          "docstring": "Detect primary domain from goal text and project structure.",
          "methods": [],
          "line": 101
        },
        {
          "name": "get_gray_area_questions",
          "type": "function",
          "signature": "def get_gray_area_questions(goal: str, domain: str) -> List[str]",
          "docstring": "Generate questions about common ambiguities for a domain.",
          "methods": [],
          "line": 131
        },
        {
          "name": "count_project_files",
          "type": "function",
          "signature": "def count_project_files(project_path: str) -> int",
          "docstring": "Count source files in project (excluding hidden/build dirs).",
          "methods": [],
          "line": 156
        },
        {
          "name": "is_new_project",
          "type": "function",
          "signature": "def is_new_project(project_path: str, threshold: int) -> bool",
          "docstring": "Check if project is new (few source files).",
          "methods": [],
          "line": 176
        },
        {
          "name": "is_vague_goal",
          "type": "function",
          "signature": "def is_vague_goal(goal: str) -> bool",
          "docstring": "Check if goal is vague and needs clarification.",
          "methods": [],
          "line": 181
        },
        {
          "name": "needs_discussion",
          "type": "function",
          "signature": "def needs_discussion(goal: str, project_path: str, force: bool, skip: bool) -> Tuple[bool, str]",
          "docstring": "Determine if a goal needs discussion before spec generation.",
          "methods": [],
          "line": 215
        },
        {
          "name": "generate_questions",
          "type": "function",
          "signature": "def generate_questions(goal: str, project_path: str, project_name: str) -> List[str]",
          "docstring": "Generate clarifying questions for a goal.",
          "methods": [],
          "line": 253
        },
        {
          "name": "start_discussion",
          "type": "function",
          "signature": "def start_discussion(goal: str, project_path: str, project_name: str) -> Discussion",
          "docstring": "Start a new discussion for a goal.",
          "methods": [],
          "line": 317
        },
        {
          "name": "get_or_start_discussion",
          "type": "function",
          "signature": "def get_or_start_discussion(goal: str, project_path: str, project_name: str) -> Tuple[Discussion, bool]",
          "docstring": "Get existing discussion or start a new one.",
          "methods": [],
          "line": 340
        },
        {
          "name": "answer_question",
          "type": "function",
          "signature": "def answer_question(goal: str, project_path: str, project_name: str, question: str, answer: str) -> Discussion",
          "docstring": "Record an answer to a question.",
          "methods": [],
          "line": 361
        },
        {
          "name": "answer_question_with_logging",
          "type": "function",
          "signature": "def answer_question_with_logging(goal: str, project_path: str, project_name: str, question: str, answer: str) -> Tuple['Discussion', Optional['Decision'], Optional['DeferredIdea']]",
          "docstring": "Record an answer to a question with decision logging and defer detection.",
          "methods": [],
          "line": 387
        },
        {
          "name": "resolve_discussion",
          "type": "function",
          "signature": "def resolve_discussion(goal: str, project_path: str, project_name: str) -> Discussion",
          "docstring": "Mark a discussion as resolved.",
          "methods": [],
          "line": 453
        },
        {
          "name": "enrich_goal",
          "type": "function",
          "signature": "def enrich_goal(goal: str, project_path: str, project_name: str) -> str",
          "docstring": "Enrich a goal with discussion context.",
          "methods": [],
          "line": 480
        },
        {
          "name": "get_enriched_goal",
          "type": "function",
          "signature": "def get_enriched_goal(goal: str, project_path: str, project_name: str) -> Tuple[str, Optional[Discussion]]",
          "docstring": "Get enriched goal and discussion if exists.",
          "methods": [],
          "line": 509
        },
        {
          "name": "log_decision",
          "type": "function",
          "signature": "def log_decision(project_path: str, project_name: str, context: str, choice: str, rationale: str, alternatives: List[str], source: str, run_id: Optional[str]) -> 'Decision'",
          "docstring": "Log a decision with rationale.",
          "methods": [],
          "line": 532
        },
        {
          "name": "get_decisions",
          "type": "function",
          "signature": "def get_decisions(project_path: str, project_name: str, limit: int, search: Optional[str]) -> List['Decision']",
          "docstring": "Get recent decisions, optionally filtered by search.",
          "methods": [],
          "line": 580
        },
        {
          "name": "defer_idea",
          "type": "function",
          "signature": "def defer_idea(project_path: str, project_name: str, idea: str, source: str, tags: List[str]) -> 'DeferredIdea'",
          "docstring": "Capture a deferred idea.",
          "methods": [],
          "line": 604
        },
        {
          "name": "get_deferred_ideas",
          "type": "function",
          "signature": "def get_deferred_ideas(project_path: str, project_name: str, tag: Optional[str], include_promoted: bool) -> List['DeferredIdea']",
          "docstring": "Get deferred ideas, optionally filtered by tag.",
          "methods": [],
          "line": 643
        },
        {
          "name": "promote_idea_to_milestone",
          "type": "function",
          "signature": "def promote_idea_to_milestone(project_path: str, project_name: str, idea_id: str, goal: str) -> Optional['Milestone']",
          "docstring": "Promote a deferred idea to a roadmap milestone.",
          "methods": [],
          "line": 663
        },
        {
          "name": "format_discussion",
          "type": "function",
          "signature": "def format_discussion(discussion: Discussion) -> str",
          "docstring": "Format discussion for CLI display.",
          "methods": [],
          "line": 722
        },
        {
          "name": "create_roadmap",
          "type": "function",
          "signature": "def create_roadmap(goal: str, project_path: str, project_name: str) -> Roadmap",
          "docstring": "Create a roadmap for a discussion.",
          "methods": [],
          "line": 765
        },
        {
          "name": "add_milestone",
          "type": "function",
          "signature": "def add_milestone(goal: str, project_path: str, project_name: str, name: str, description: str) -> Milestone",
          "docstring": "Add a milestone to a discussion's roadmap.",
          "methods": [],
          "line": 795
        },
        {
          "name": "advance_roadmap",
          "type": "function",
          "signature": "def advance_roadmap(goal: str, project_path: str, project_name: str) -> Optional[Milestone]",
          "docstring": "Mark current milestone done and return next one.",
          "methods": [],
          "line": 826
        },
        {
          "name": "get_roadmap",
          "type": "function",
          "signature": "def get_roadmap(goal: str, project_path: str, project_name: str) -> Optional[Roadmap]",
          "docstring": "Get roadmap for a goal.",
          "methods": [],
          "line": 852
        },
        {
          "name": "get_active_discussion",
          "type": "function",
          "signature": "def get_active_discussion(project_path: str, project_name: str) -> Optional[Discussion]",
          "docstring": "Get the active (unresolved) discussion for a project.",
          "methods": [],
          "line": 871
        },
        {
          "name": "format_roadmap",
          "type": "function",
          "signature": "def format_roadmap(roadmap: Roadmap) -> str",
          "docstring": "Format roadmap for CLI display.",
          "methods": [],
          "line": 892
        },
        {
          "name": "get_current_milestone_goal",
          "type": "function",
          "signature": "def get_current_milestone_goal(project_path: str, project_name: str) -> Optional[str]",
          "docstring": "Get the goal string for the current milestone.",
          "methods": [],
          "line": 934
        }
      ],
      "deps_internal": [
        "memory.py"
      ],
      "deps_external": []
    },
    "statusline.py": {
      "path": "statusline.py",
      "lang": "python",
      "lines": 161,
      "summary": "EriRPG Status Line for Claude Code.",
      "interfaces": [
        {
          "name": "DEFAULT_SETTINGS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 19
        },
        {
          "name": "load_settings",
          "type": "function",
          "signature": "def load_settings() -> dict",
          "docstring": "Load settings from ~/.eri-rpg/settings.json",
          "methods": [],
          "line": 31
        },
        {
          "name": "find_state_file",
          "type": "function",
          "signature": "def find_state_file() -> Path | None",
          "docstring": "Find STATE.md in current or parent directories.",
          "methods": [],
          "line": 42
        },
        {
          "name": "parse_state_file",
          "type": "function",
          "signature": "def parse_state_file(state_path: Path) -> dict",
          "docstring": "Parse STATE.md for phase info.",
          "methods": [],
          "line": 62
        },
        {
          "name": "format_statusline",
          "type": "function",
          "signature": "def format_statusline(state: dict, context_pct: int | None, settings: dict) -> str",
          "docstring": "Format the status line based on settings.",
          "methods": [],
          "line": 100
        },
        {
          "name": "main",
          "type": "function",
          "signature": "def main()",
          "docstring": "Main entry point.",
          "methods": [],
          "line": 130
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "research.py": {
      "path": "research.py",
      "lang": "python",
      "lines": 283,
      "summary": "Research pipeline for EriRPG.",
      "interfaces": [
        {
          "name": "LibraryChoice",
          "type": "class",
          "signature": "",
          "docstring": "A library/framework choice made during research.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 16
        },
        {
          "name": "Pitfall",
          "type": "class",
          "signature": "",
          "docstring": "A common pitfall discovered during research.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 33
        },
        {
          "name": "ResearchFindings",
          "type": "class",
          "signature": "",
          "docstring": "Complete findings from a research phase.",
          "methods": [
            "to_dict",
            "from_dict",
            "to_markdown",
            "to_avoid_patterns"
          ],
          "line": 48
        },
        {
          "name": "ResearchCache",
          "type": "class",
          "signature": "",
          "docstring": "Cache for research findings by goal hash.",
          "methods": [
            "__init__",
            "_load",
            "_save",
            "_hash_goal",
            "get",
            "set",
            "clear"
          ],
          "line": 182
        },
        {
          "name": "ResearchPhase",
          "type": "class",
          "signature": "",
          "docstring": "Orchestrates research for a goal.",
          "methods": [
            "__init__",
            "execute",
            "save_findings"
          ],
          "line": 235
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "registry.py": {
      "path": "registry.py",
      "lang": "python",
      "lines": 241,
      "summary": "Project registry for managing registered projects.",
      "interfaces": [
        {
          "name": "detect_project_language",
          "type": "function",
          "signature": "def detect_project_language(path: str) -> str",
          "docstring": "Auto-detect project language from files in the project root.",
          "methods": [],
          "line": 16
        },
        {
          "name": "Project",
          "type": "class",
          "signature": "",
          "docstring": "A registered project.",
          "methods": [
            "__post_init__",
            "to_dict",
            "from_dict",
            "is_indexed",
            "index_age_days"
          ],
          "line": 86
        },
        {
          "name": "Registry",
          "type": "class",
          "signature": "",
          "docstring": "Registry of all known projects.",
          "methods": [
            "__post_init__",
            "add",
            "remove",
            "get",
            "list",
            "save",
            "load",
            "update_indexed",
            "get_instance"
          ],
          "line": 144
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "runner.py": {
      "path": "runner.py",
      "lang": "python",
      "lines": 571,
      "summary": "Runner for EriRPG.",
      "interfaces": [
        {
          "name": "StepContext",
          "type": "class",
          "signature": "",
          "docstring": "Context generated for a single step execution.",
          "methods": [
            "to_dict",
            "from_dict",
            "format_for_claude"
          ],
          "line": 39
        },
        {
          "name": "build_step_context",
          "type": "function",
          "signature": "def build_step_context(step: PlanStep, plan: Plan, project_path: str, graph: Any, knowledge: Any) -> StepContext",
          "docstring": "Build focused context for a single step.",
          "methods": [],
          "line": 165
        },
        {
          "name": "save_step_context",
          "type": "function",
          "signature": "def save_step_context(ctx: StepContext, run_dir: str) -> str",
          "docstring": "Save step context to a file and return the path.",
          "methods": [],
          "line": 239
        },
        {
          "name": "Runner",
          "type": "class",
          "signature": "",
          "docstring": "Orchestrates plan execution with checkpoints.",
          "methods": [
            "__init__",
            "resume",
            "start",
            "get_next_step",
            "get_ready_steps",
            "prepare_step",
            "mark_step_started",
            "mark_step_completed",
            "mark_step_failed",
            "mark_step_skipped",
            "pause",
            "verify_step",
            "get_verification_results",
            "_update_run_status",
            "get_progress",
            "get_report"
          ],
          "line": 261
        },
        {
          "name": "list_runs",
          "type": "function",
          "signature": "def list_runs(project_path: str) -> List[RunRecord]",
          "docstring": "List all runs for a project.",
          "methods": [],
          "line": 554
        }
      ],
      "deps_internal": [
        "planner.py",
        "runs.py"
      ],
      "deps_external": []
    },
    "knowledge.py": {
      "path": "knowledge.py",
      "lang": "python",
      "lines": 324,
      "summary": "Knowledge storage for EriRPG.",
      "interfaces": [
        {
          "name": "Learning",
          "type": "class",
          "signature": "",
          "docstring": "What Claude Code learned about a module.",
          "methods": [
            "is_stale",
            "to_dict",
            "from_dict",
            "format_for_context"
          ],
          "line": 28
        },
        {
          "name": "Decision",
          "type": "class",
          "signature": "",
          "docstring": "An architectural or design decision.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 151
        },
        {
          "name": "HistoryEntry",
          "type": "class",
          "signature": "",
          "docstring": "A logged action in the project history.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 183
        },
        {
          "name": "Knowledge",
          "type": "class",
          "signature": "",
          "docstring": "All knowledge stored for a project.",
          "methods": [
            "to_dict",
            "from_dict",
            "add_learning",
            "get_learning",
            "has_learning",
            "remove_learning",
            "add_decision",
            "get_decisions_for_module",
            "add_pattern",
            "get_pattern",
            "log_action",
            "get_recent_history",
            "stats"
          ],
          "line": 215
        },
        {
          "name": "load_knowledge",
          "type": "function",
          "signature": "def load_knowledge(graph_path: str) -> Knowledge",
          "docstring": "Load knowledge from a graph.json file.",
          "methods": [],
          "line": 294
        },
        {
          "name": "save_knowledge",
          "type": "function",
          "signature": "def save_knowledge(graph_path: str, knowledge: Knowledge) -> None",
          "docstring": "Save knowledge to a graph.json file (merges with existing).",
          "methods": [],
          "line": 309
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "context.py": {
      "path": "context.py",
      "lang": "python",
      "lines": 744,
      "summary": "Context generation for Claude Code.",
      "interfaces": [
        {
          "name": "get_encoder",
          "type": "function",
          "signature": "def get_encoder() -> tiktoken.Encoding",
          "docstring": "Get the tiktoken encoder, lazily initialized.",
          "methods": [],
          "line": 47
        },
        {
          "name": "count_tokens",
          "type": "function",
          "signature": "def count_tokens(text: str) -> int",
          "docstring": "Count actual tokens in text using tiktoken.",
          "methods": [],
          "line": 55
        },
        {
          "name": "TOKEN_BUDGET",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 77
        },
        {
          "name": "MIN_CODE_LINES",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 80
        },
        {
          "name": "RESERVED_HEADER",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 83
        },
        {
          "name": "RESERVED_PLAN",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 84
        },
        {
          "name": "RESERVED_INSTRUCTIONS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 85
        },
        {
          "name": "RESERVED_INTERFACES",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 86
        },
        {
          "name": "RESERVED_PER_LEARNING",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 87
        },
        {
          "name": "TokenBudget",
          "type": "class",
          "signature": "",
          "docstring": "Tracks token allocation during context generation.",
          "methods": [
            "remaining",
            "over_budget",
            "allocate",
            "summary"
          ],
          "line": 91
        },
        {
          "name": "EXTENSION_TO_FENCE",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 146
        },
        {
          "name": "get_fence_language",
          "type": "function",
          "signature": "def get_fence_language(file_path: str) -> str",
          "docstring": "Get the appropriate code fence language for a file path.",
          "methods": [],
          "line": 178
        },
        {
          "name": "truncate_code",
          "type": "function",
          "signature": "def truncate_code(code: str, max_tokens: int, file_path: str) -> Tuple[str, int, bool]",
          "docstring": "Truncate code to fit within token budget.",
          "methods": [],
          "line": 196
        },
        {
          "name": "allocate_code_budgets",
          "type": "function",
          "signature": "def allocate_code_budgets(components: List[str], code_dict: Dict[str, str], total_budget: int, primary_module: str) -> Dict[str, int]",
          "docstring": "Allocate token budgets to each code file.",
          "methods": [],
          "line": 268
        },
        {
          "name": "generate_context",
          "type": "function",
          "signature": "def generate_context(feature: Feature, plan: TransplantPlan, source_graph: Optional[Graph], target_graph: Graph, target_project: Project, source_project: Optional[Project], output_dir: Optional[str], use_learnings: bool, max_tokens: Optional[int]) -> str",
          "docstring": "Generate context file for Claude Code.",
          "methods": [],
          "line": 333
        },
        {
          "name": "estimate_tokens",
          "type": "function",
          "signature": "def estimate_tokens(feature: Feature, plan: TransplantPlan, source_project: Optional[Project]) -> int",
          "docstring": "Calculate ACCURATE token count for context using tiktoken.",
          "methods": [],
          "line": 696
        }
      ],
      "deps_internal": [
        "ops.py",
        "graph.py",
        "registry.py",
        "memory.py"
      ],
      "deps_external": [
        "tiktoken"
      ]
    },
    "commands.py": {
      "path": "commands.py",
      "lang": "python",
      "lines": 266,
      "summary": "Slash command system for EriRPG.",
      "interfaces": [
        {
          "name": "CommandConfig",
          "type": "class",
          "signature": "",
          "docstring": "Configuration for a slash command.",
          "methods": [
            "to_dict"
          ],
          "line": 21
        },
        {
          "name": "ParsedCommand",
          "type": "class",
          "signature": "",
          "docstring": "Result of parsing user input.",
          "methods": [
            "has_flag",
            "get_flag"
          ],
          "line": 42
        },
        {
          "name": "_build_alias_map",
          "type": "function",
          "signature": "def _build_alias_map() -> Dict[str, str]",
          "docstring": "Build map from aliases to canonical command names.",
          "methods": [],
          "line": 150
        },
        {
          "name": "ALIAS_MAP",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 159
        },
        {
          "name": "parse_command",
          "type": "function",
          "signature": "def parse_command(user_input: str) -> Optional[ParsedCommand]",
          "docstring": "Parse slash command from user input.",
          "methods": [],
          "line": 162
        },
        {
          "name": "is_command",
          "type": "function",
          "signature": "def is_command(user_input: str) -> bool",
          "docstring": "Check if input looks like a command.",
          "methods": [],
          "line": 221
        },
        {
          "name": "get_help_text",
          "type": "function",
          "signature": "def get_help_text() -> str",
          "docstring": "Generate help text for all commands.",
          "methods": [],
          "line": 230
        },
        {
          "name": "get_command_names",
          "type": "function",
          "signature": "def get_command_names() -> List[str]",
          "docstring": "Get all command names including aliases.",
          "methods": [],
          "line": 261
        }
      ],
      "deps_internal": [
        "workflow.py",
        "persona.py"
      ],
      "deps_external": []
    },
    "cache.py": {
      "path": "cache.py",
      "lang": "python",
      "lines": 331,
      "summary": "Caching system for EriRPG.",
      "interfaces": [
        {
          "name": "CacheEntry",
          "type": "class",
          "signature": "",
          "docstring": "A cached parsing result for a single file.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 25
        },
        {
          "name": "CacheStats",
          "type": "class",
          "signature": "",
          "docstring": "Statistics about cache usage.",
          "methods": [
            "hit_rate",
            "format_summary"
          ],
          "line": 59
        },
        {
          "name": "IndexCache",
          "type": "class",
          "signature": "",
          "docstring": "Cache for parsed file results to enable incremental indexing.",
          "methods": [
            "__init__",
            "_load",
            "save",
            "_get_file_info",
            "is_stale",
            "get",
            "store",
            "invalidate",
            "invalidate_all",
            "_normalize_path",
            "get_stats",
            "cleanup_deleted_files"
          ],
          "line": 88
        },
        {
          "name": "get_index_cache",
          "type": "function",
          "signature": "def get_index_cache(project_path: str) -> IndexCache",
          "docstring": "Get or create an IndexCache for a project.",
          "methods": [],
          "line": 294
        },
        {
          "name": "clear_cache",
          "type": "function",
          "signature": "def clear_cache(project_path: str) -> bool",
          "docstring": "Clear all caches for a project.",
          "methods": [],
          "line": 306
        },
        {
          "name": "get_cache_stats",
          "type": "function",
          "signature": "def get_cache_stats(project_path: str) -> Optional[CacheStats]",
          "docstring": "Get cache statistics for a project.",
          "methods": [],
          "line": 320
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "diagnostics.py": {
      "path": "diagnostics.py",
      "lang": "python",
      "lines": 569,
      "summary": "Diagnostics module for EriRPG.",
      "interfaces": [
        {
          "name": "Hint",
          "type": "class",
          "signature": "",
          "docstring": "An actionable hint for fixing an issue.",
          "methods": [],
          "line": 20
        },
        {
          "name": "ERROR_PATTERNS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 33
        },
        {
          "name": "extract_hints",
          "type": "function",
          "signature": "def extract_hints(output: str) -> List[Hint]",
          "docstring": "Extract hints from error output.",
          "methods": [],
          "line": 128
        },
        {
          "name": "suggest_fixes",
          "type": "function",
          "signature": "def suggest_fixes(output: str) -> List[str]",
          "docstring": "Get list of fix suggestions from error output.",
          "methods": [],
          "line": 164
        },
        {
          "name": "format_step_failure",
          "type": "function",
          "signature": "def format_step_failure(step_id: str, error: str, output: str, context: Optional[Dict[str, Any]]) -> str",
          "docstring": "Format a detailed failure report for a single step.",
          "methods": [],
          "line": 181
        },
        {
          "name": "format_verification_failure",
          "type": "function",
          "signature": "def format_verification_failure(step_id: str, command_results: List[Any]) -> str",
          "docstring": "Format verification failure details.",
          "methods": [],
          "line": 238
        },
        {
          "name": "format_run_failure_summary",
          "type": "function",
          "signature": "def format_run_failure_summary(run: Any, verification_results: Optional[List[Any]]) -> str",
          "docstring": "Format a comprehensive failure summary for a run.",
          "methods": [],
          "line": 287
        },
        {
          "name": "format_progress_bar",
          "type": "function",
          "signature": "def format_progress_bar(current: int, total: int, width: int, fill: str, empty: str) -> str",
          "docstring": "Format a text-based progress bar.",
          "methods": [],
          "line": 357
        },
        {
          "name": "format_status_line",
          "type": "function",
          "signature": "def format_status_line(step: Any, max_width: int) -> str",
          "docstring": "Format a single-line status for a step.",
          "methods": [],
          "line": 386
        },
        {
          "name": "format_next_steps",
          "type": "function",
          "signature": "def format_next_steps(current_step: Optional[Any], ready_steps: List[Any], run_id: str) -> str",
          "docstring": "Format next steps guidance.",
          "methods": [],
          "line": 421
        },
        {
          "name": "format_impact_warning",
          "type": "function",
          "signature": "def format_impact_warning(step: Any, impact_score: float, affected_modules: List[str]) -> str",
          "docstring": "Format a warning for high-impact steps.",
          "methods": [],
          "line": 474
        },
        {
          "name": "assess_step_impact",
          "type": "function",
          "signature": "def assess_step_impact(step: Any, graph: Optional[Any]) -> Tuple[float, List[str]]",
          "docstring": "Assess the impact of a step.",
          "methods": [],
          "line": 515
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "verification.py": {
      "path": "verification.py",
      "lang": "python",
      "lines": 1039,
      "summary": "Verification system for EriRPG.",
      "interfaces": [
        {
          "name": "VerificationStatus",
          "type": "class",
          "signature": "",
          "docstring": "Status of a verification run.",
          "methods": [],
          "line": 27
        },
        {
          "name": "VerificationCommand",
          "type": "class",
          "signature": "",
          "docstring": "A single verification command to run.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 37
        },
        {
          "name": "CommandResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of running a single verification command.",
          "methods": [
            "to_dict",
            "from_dict",
            "passed",
            "duration"
          ],
          "line": 74
        },
        {
          "name": "VerificationResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of running all verification commands for a step.",
          "methods": [
            "to_dict",
            "from_dict",
            "passed",
            "failed_commands",
            "format_report"
          ],
          "line": 129
        },
        {
          "name": "VerificationConfig",
          "type": "class",
          "signature": "",
          "docstring": "Configuration for verification commands.",
          "methods": [
            "to_dict",
            "from_dict",
            "validate",
            "get_commands_for_step"
          ],
          "line": 221
        },
        {
          "name": "Verifier",
          "type": "class",
          "signature": "",
          "docstring": "Executes verification commands.",
          "methods": [
            "__init__",
            "run_command",
            "run_verification",
            "should_run_for_step"
          ],
          "line": 267
        },
        {
          "name": "save_verification_result",
          "type": "function",
          "signature": "def save_verification_result(project_path: str, run_id: str, result: VerificationResult) -> str",
          "docstring": "Save verification result to run directory.",
          "methods": [],
          "line": 412
        },
        {
          "name": "load_verification_result",
          "type": "function",
          "signature": "def load_verification_result(project_path: str, run_id: str, step_id: str) -> Optional[VerificationResult]",
          "docstring": "Load verification result from run directory.",
          "methods": [],
          "line": 439
        },
        {
          "name": "list_verification_results",
          "type": "function",
          "signature": "def list_verification_results(project_path: str, run_id: str) -> List[VerificationResult]",
          "docstring": "List all verification results for a run.",
          "methods": [],
          "line": 471
        },
        {
          "name": "format_verification_summary",
          "type": "function",
          "signature": "def format_verification_summary(results: List[VerificationResult]) -> str",
          "docstring": "Format a summary of all verification results.",
          "methods": [],
          "line": 502
        },
        {
          "name": "load_verification_config",
          "type": "function",
          "signature": "def load_verification_config(project_path: str) -> Optional[VerificationConfig]",
          "docstring": "Load verification config from project.",
          "methods": [],
          "line": 543
        },
        {
          "name": "save_verification_config",
          "type": "function",
          "signature": "def save_verification_config(project_path: str, config: VerificationConfig) -> str",
          "docstring": "Save verification config to project.",
          "methods": [],
          "line": 572
        },
        {
          "name": "get_default_python_config",
          "type": "function",
          "signature": "def get_default_python_config() -> VerificationConfig",
          "docstring": "Get default verification config for Python projects.",
          "methods": [],
          "line": 596
        },
        {
          "name": "get_default_node_config",
          "type": "function",
          "signature": "def get_default_node_config() -> VerificationConfig",
          "docstring": "Get default verification config for Node.js projects.",
          "methods": [],
          "line": 622
        },
        {
          "name": "find_relevant_tests",
          "type": "function",
          "signature": "def find_relevant_tests(changed_files: List[str], project_path: str, test_dirs: Optional[List[str]]) -> Optional[List[str]]",
          "docstring": "Find test files that import any of the changed files.",
          "methods": [],
          "line": 652
        },
        {
          "name": "build_smart_test_command",
          "type": "function",
          "signature": "def build_smart_test_command(changed_files: List[str], project_path: str, base_command: str, fallback_to_all: bool) -> str",
          "docstring": "Build a test command that runs only relevant tests.",
          "methods": [],
          "line": 753
        },
        {
          "name": "SmartVerifier",
          "type": "class",
          "signature": "",
          "docstring": "Verifier with smart test selection support.",
          "methods": [
            "__init__",
            "get_relevant_tests",
            "run_command"
          ],
          "line": 799
        },
        {
          "name": "BreakingChange",
          "type": "class",
          "signature": "",
          "docstring": "A breaking change in an interface signature.",
          "methods": [
            "format"
          ],
          "line": 859
        },
        {
          "name": "signatures_compatible",
          "type": "function",
          "signature": "def signatures_compatible(before: str, after: str) -> bool",
          "docstring": "Check if two signatures are compatible.",
          "methods": [],
          "line": 878
        },
        {
          "name": "validate_interface_contracts",
          "type": "function",
          "signature": "def validate_interface_contracts(before_graph: 'Graph', after_graph: 'Graph') -> List[BreakingChange]",
          "docstring": "Detect if any interface signatures changed incompatibly.",
          "methods": [],
          "line": 947
        },
        {
          "name": "format_breaking_changes",
          "type": "function",
          "signature": "def format_breaking_changes(changes: List[BreakingChange]) -> str",
          "docstring": "Format breaking changes for display.",
          "methods": [],
          "line": 1020
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "quick.py": {
      "path": "quick.py",
      "lang": "python",
      "lines": 545,
      "summary": "EriRPG Quick Fix Mode - Lightweight single-file edits.",
      "interfaces": [
        {
          "name": "is_quick_fix_active",
          "type": "function",
          "signature": "def is_quick_fix_active() -> bool",
          "docstring": "Check if quick fix mode is active.",
          "methods": [],
          "line": 49
        },
        {
          "name": "get_quick_fix_file",
          "type": "function",
          "signature": "def get_quick_fix_file() -> Optional[str]",
          "docstring": "Get the file being quick-fixed.",
          "methods": [],
          "line": 54
        },
        {
          "name": "get_quick_fix_project",
          "type": "function",
          "signature": "def get_quick_fix_project() -> Optional[str]",
          "docstring": "Get the project being quick-fixed.",
          "methods": [],
          "line": 59
        },
        {
          "name": "_set_quick_fix_active",
          "type": "function",
          "signature": "def _set_quick_fix_active(active: bool, file_path: Optional[str], project: Optional[str]) -> None",
          "docstring": "Set quick fix mode state (internal use only).",
          "methods": [],
          "line": 64
        },
        {
          "name": "_is_git_repo",
          "type": "function",
          "signature": "def _is_git_repo(path: str) -> bool",
          "docstring": "Check if path is inside a git repository.",
          "methods": [],
          "line": 76
        },
        {
          "name": "_git_head",
          "type": "function",
          "signature": "def _git_head(path: str) -> Optional[str]",
          "docstring": "Get current git HEAD commit hash.",
          "methods": [],
          "line": 90
        },
        {
          "name": "save_quick_fix_state",
          "type": "function",
          "signature": "def save_quick_fix_state(project_path: str, file_path: str, description: str) -> Path",
          "docstring": "Save quick fix state to file for Claude Code hooks.",
          "methods": [],
          "line": 111
        },
        {
          "name": "clear_quick_fix_state",
          "type": "function",
          "signature": "def clear_quick_fix_state(project_path: str) -> None",
          "docstring": "Clear quick fix state file.",
          "methods": [],
          "line": 135
        },
        {
          "name": "load_quick_fix_state",
          "type": "function",
          "signature": "def load_quick_fix_state(project_path: str) -> Optional[Dict[str, Any]]",
          "docstring": "Load quick fix state from file.",
          "methods": [],
          "line": 142
        },
        {
          "name": "quick_fix",
          "type": "function",
          "signature": "def quick_fix(project: str, file_path: str, description: str, auto_commit: bool, dry_run: bool) -> Optional[str]",
          "docstring": "Single-file edit without full spec ceremony.",
          "methods": [],
          "line": 159
        },
        {
          "name": "quick_done",
          "type": "function",
          "signature": "def quick_done(project: str, auto_commit: bool, commit_message: Optional[str]) -> Optional[str]",
          "docstring": "Complete a quick fix - commit changes and cleanup.",
          "methods": [],
          "line": 235
        },
        {
          "name": "quick_cancel",
          "type": "function",
          "signature": "def quick_cancel(project: str) -> None",
          "docstring": "Cancel a quick fix and restore original file.",
          "methods": [],
          "line": 291
        },
        {
          "name": "QuickAgent",
          "type": "class",
          "signature": "",
          "docstring": "Lightweight agent for quick fixes.",
          "methods": [
            "__init__",
            "fix",
            "done",
            "cancel",
            "is_active"
          ],
          "line": 331
        },
        {
          "name": "_save_snapshot",
          "type": "function",
          "signature": "def _save_snapshot(project_path: str, file_path: str, content: str) -> Path",
          "docstring": "Save file snapshot for potential rollback.",
          "methods": [],
          "line": 452
        },
        {
          "name": "_restore_snapshot",
          "type": "function",
          "signature": "def _restore_snapshot(project_path: str, file_path: str) -> bool",
          "docstring": "Restore file from snapshot.",
          "methods": [],
          "line": 475
        },
        {
          "name": "_git_commit",
          "type": "function",
          "signature": "def _git_commit(project_path: str, files: List[str], message: str) -> Optional[str]",
          "docstring": "Create git commit for files.",
          "methods": [],
          "line": 502
        }
      ],
      "deps_internal": [
        "registry.py"
      ],
      "deps_external": []
    },
    "persona.py": {
      "path": "persona.py",
      "lang": "python",
      "lines": 176,
      "summary": "Persona system for EriRPG.",
      "interfaces": [
        {
          "name": "Persona",
          "type": "class",
          "signature": "",
          "docstring": "5 focused personas derived from workflow stages.",
          "methods": [],
          "line": 15
        },
        {
          "name": "PersonaConfig",
          "type": "class",
          "signature": "",
          "docstring": "Configuration for a persona's behavior.",
          "methods": [
            "to_prompt",
            "to_dict",
            "from_dict"
          ],
          "line": 28
        },
        {
          "name": "detect_persona_from_input",
          "type": "function",
          "signature": "def detect_persona_from_input(user_input: str) -> Persona",
          "docstring": "Auto-detect appropriate persona from user input.",
          "methods": [],
          "line": 129
        },
        {
          "name": "get_persona",
          "type": "function",
          "signature": "def get_persona(persona: Persona) -> PersonaConfig",
          "docstring": "Get configuration for a persona.",
          "methods": [],
          "line": 159
        },
        {
          "name": "get_persona_by_name",
          "type": "function",
          "signature": "def get_persona_by_name(name: str) -> Optional[Persona]",
          "docstring": "Get persona enum by name string.",
          "methods": [],
          "line": 164
        },
        {
          "name": "list_personas",
          "type": "function",
          "signature": "def list_personas() -> List[str]",
          "docstring": "List all available persona names.",
          "methods": [],
          "line": 173
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "must_haves.py": {
      "path": "must_haves.py",
      "lang": "python",
      "lines": 156,
      "summary": "Must-haves validation for plan completeness.",
      "interfaces": [
        {
          "name": "MustHaves",
          "type": "class",
          "signature": "",
          "docstring": "Requirements that must be satisfied by a plan.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 14
        },
        {
          "name": "validate_plan",
          "type": "function",
          "signature": "def validate_plan(plan: Plan, must_haves: MustHaves) -> List[str]",
          "docstring": "Validate that a plan covers all must-haves.",
          "methods": [],
          "line": 42
        },
        {
          "name": "_fuzzy_match",
          "type": "function",
          "signature": "def _fuzzy_match(needle: str, haystack: str) -> bool",
          "docstring": "Check if key words from needle appear in haystack.",
          "methods": [],
          "line": 106
        },
        {
          "name": "derive_must_haves_from_goal",
          "type": "function",
          "signature": "def derive_must_haves_from_goal(goal: str) -> MustHaves",
          "docstring": "Derive basic must-haves from a goal string.",
          "methods": [],
          "line": 120
        }
      ],
      "deps_internal": [
        "agent/plan.py"
      ],
      "deps_external": []
    },
    "preflight.py": {
      "path": "preflight.py",
      "lang": "python",
      "lines": 379,
      "summary": "Preflight checks before any code operation.",
      "interfaces": [
        {
          "name": "PreflightReport",
          "type": "class",
          "signature": "",
          "docstring": "Report from preflight checks.",
          "methods": [
            "format",
            "to_dict"
          ],
          "line": 24
        },
        {
          "name": "normalize_path",
          "type": "function",
          "signature": "def normalize_path(path: str, project_path: str) -> str",
          "docstring": "Normalize a file path for consistent comparison.",
          "methods": [],
          "line": 142
        },
        {
          "name": "_get_cached_learnings_status",
          "type": "function",
          "signature": "def _get_cached_learnings_status(project_path: str) -> Optional[Dict[str, str]]",
          "docstring": "Get cached learnings_status from preflight_state.json.",
          "methods": [],
          "line": 182
        },
        {
          "name": "preflight",
          "type": "function",
          "signature": "def preflight(project_path: str, files: List[str], operation: str, graph: Optional['Graph'], before_graph: Optional['Graph'], strict: bool) -> PreflightReport",
          "docstring": "Run preflight checks before any code operation.",
          "methods": [],
          "line": 204
        },
        {
          "name": "require_preflight",
          "type": "function",
          "signature": "def require_preflight(func)",
          "docstring": "Decorator to require preflight before operation.",
          "methods": [],
          "line": 368
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "session_context.py": {
      "path": "session_context.py",
      "lang": "python",
      "lines": 235,
      "summary": "Dynamic context builder for EriRPG.",
      "interfaces": [
        {
          "name": "SessionContext",
          "type": "class",
          "signature": "",
          "docstring": "All context needed for current session.",
          "methods": [
            "__post_init__",
            "set_stage",
            "set_persona",
            "to_dict"
          ],
          "line": 25
        },
        {
          "name": "build_context",
          "type": "function",
          "signature": "def build_context(ctx: SessionContext, compact: bool) -> str",
          "docstring": "Build dynamic context string.",
          "methods": [],
          "line": 84
        },
        {
          "name": "build_minimal_context",
          "type": "function",
          "signature": "def build_minimal_context(persona: Persona) -> str",
          "docstring": "Build minimal context when no project is loaded.",
          "methods": [],
          "line": 171
        },
        {
          "name": "context_from_knowledge_store",
          "type": "function",
          "signature": "def context_from_knowledge_store(project_path: str, project_name: str, stage: Stage, persona: Persona, current_task: str) -> SessionContext",
          "docstring": "Build SessionContext from EriRPG knowledge store.",
          "methods": [],
          "line": 188
        }
      ],
      "deps_internal": [
        "commands.py",
        "workflow.py",
        "persona.py"
      ],
      "deps_external": []
    },
    "ux.py": {
      "path": "ux.py",
      "lang": "python",
      "lines": 440,
      "summary": "UX utilities for EriRPG CLI.",
      "interfaces": [
        {
          "name": "ICONS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 23
        },
        {
          "name": "COLORS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 42
        },
        {
          "name": "set_colors",
          "type": "function",
          "signature": "def set_colors(enabled: bool) -> None",
          "docstring": "Enable or disable color output.",
          "methods": [],
          "line": 58
        },
        {
          "name": "_color",
          "type": "function",
          "signature": "def _color(text: str, color: str) -> str",
          "docstring": "Apply color if colors are enabled.",
          "methods": [],
          "line": 64
        },
        {
          "name": "print_success",
          "type": "function",
          "signature": "def print_success(message: str) -> None",
          "docstring": "Print a success message.",
          "methods": [],
          "line": 75
        },
        {
          "name": "print_error",
          "type": "function",
          "signature": "def print_error(message: str, file) -> None",
          "docstring": "Print an error message.",
          "methods": [],
          "line": 81
        },
        {
          "name": "print_warning",
          "type": "function",
          "signature": "def print_warning(message: str) -> None",
          "docstring": "Print a warning message.",
          "methods": [],
          "line": 87
        },
        {
          "name": "print_info",
          "type": "function",
          "signature": "def print_info(message: str) -> None",
          "docstring": "Print an info message.",
          "methods": [],
          "line": 93
        },
        {
          "name": "print_step",
          "type": "function",
          "signature": "def print_step(message: str, current: Optional[int], total: Optional[int]) -> None",
          "docstring": "Print a step/progress message.",
          "methods": [],
          "line": 99
        },
        {
          "name": "print_header",
          "type": "function",
          "signature": "def print_header(title: str, char: str) -> None",
          "docstring": "Print a section header.",
          "methods": [],
          "line": 125
        },
        {
          "name": "print_subheader",
          "type": "function",
          "signature": "def print_subheader(title: str) -> None",
          "docstring": "Print a subsection header.",
          "methods": [],
          "line": 132
        },
        {
          "name": "print_section",
          "type": "function",
          "signature": "def print_section(title: str, items: List[str]) -> None",
          "docstring": "Print a section with a title and bullet items.",
          "methods": [],
          "line": 139
        },
        {
          "name": "format_status",
          "type": "function",
          "signature": "def format_status(status: str) -> str",
          "docstring": "Format a status string with icon and color.",
          "methods": [],
          "line": 150
        },
        {
          "name": "format_step_status",
          "type": "function",
          "signature": "def format_step_status(step: Any) -> str",
          "docstring": "Format a plan step with status indicator.",
          "methods": [],
          "line": 173
        },
        {
          "name": "format_run_status",
          "type": "function",
          "signature": "def format_run_status(run: Any) -> str",
          "docstring": "Format a run record status line.",
          "methods": [],
          "line": 200
        },
        {
          "name": "format_progress_bar",
          "type": "function",
          "signature": "def format_progress_bar(current: int, total: int, width: int, fill: str, empty: str, show_percent: bool) -> str",
          "docstring": "Format a text-based progress bar.",
          "methods": [],
          "line": 227
        },
        {
          "name": "print_progress",
          "type": "function",
          "signature": "def print_progress(current: int, total: int, message: str, width: int) -> None",
          "docstring": "Print a progress bar with optional message.",
          "methods": [],
          "line": 261
        },
        {
          "name": "print_next_steps",
          "type": "function",
          "signature": "def print_next_steps(steps: List[str], title: str) -> None",
          "docstring": "Print a numbered list of next steps.",
          "methods": [],
          "line": 286
        },
        {
          "name": "format_command_hint",
          "type": "function",
          "signature": "def format_command_hint(command: str) -> str",
          "docstring": "Format a command as a copyable hint.",
          "methods": [],
          "line": 298
        },
        {
          "name": "print_command_hint",
          "type": "function",
          "signature": "def print_command_hint(description: str, command: str) -> None",
          "docstring": "Print a command hint with description.",
          "methods": [],
          "line": 310
        },
        {
          "name": "print_table",
          "type": "function",
          "signature": "def print_table(headers: List[str], rows: List[List[str]], min_widths: Optional[List[int]]) -> None",
          "docstring": "Print a simple table.",
          "methods": [],
          "line": 325
        },
        {
          "name": "confirm",
          "type": "function",
          "signature": "def confirm(message: str, default: bool) -> bool",
          "docstring": "Ask for confirmation.",
          "methods": [],
          "line": 371
        },
        {
          "name": "print_summary",
          "type": "function",
          "signature": "def print_summary(title: str, stats: dict, status: Optional[str]) -> None",
          "docstring": "Print a summary with statistics.",
          "methods": [],
          "line": 398
        },
        {
          "name": "format_duration",
          "type": "function",
          "signature": "def format_duration(seconds: float) -> str",
          "docstring": "Format a duration in human-readable form.",
          "methods": [],
          "line": 421
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "__init__.py": {
      "path": "__init__.py",
      "lang": "python",
      "lines": 54,
      "summary": "EriRPG - Cross-project feature transplant tool.",
      "interfaces": [],
      "deps_internal": [
        "registry.py",
        "persona.py",
        "commands.py",
        "graph.py",
        "workflow.py"
      ],
      "deps_external": []
    },
    "modes/take.py": {
      "path": "modes/take.py",
      "lang": "python",
      "lines": 496,
      "summary": "Take Mode - Transplant feature from Project A to Project B.",
      "interfaces": [
        {
          "name": "get_module_info",
          "type": "function",
          "signature": "def get_module_info(project_path: str, module_path: str, graph: 'Graph') -> Optional[dict]",
          "docstring": "Get module info, checking v2 knowledge first then v1 graph.",
          "methods": [],
          "line": 34
        },
        {
          "name": "TakeRequest",
          "type": "class",
          "signature": "",
          "docstring": "Parsed take command.",
          "methods": [],
          "line": 71
        },
        {
          "name": "parse_take_request",
          "type": "function",
          "signature": "def parse_take_request(description: str) -> TakeRequest",
          "docstring": "Parse natural language take request.",
          "methods": [],
          "line": 78
        },
        {
          "name": "check_projects",
          "type": "function",
          "signature": "def check_projects(request: TakeRequest, registry: Registry) -> Tuple[str, str, str, str]",
          "docstring": "Check projects exist and are indexed.",
          "methods": [],
          "line": 120
        },
        {
          "name": "find_feature",
          "type": "function",
          "signature": "def find_feature(graph: Graph, feature_query: str, project_name: str) -> list",
          "docstring": "Find modules matching feature query.",
          "methods": [],
          "line": 182
        },
        {
          "name": "check_knowledge",
          "type": "function",
          "signature": "def check_knowledge(graph: Graph, modules: list) -> dict",
          "docstring": "Check what knowledge exists for these modules.",
          "methods": [],
          "line": 203
        },
        {
          "name": "generate_transplant_spec",
          "type": "function",
          "signature": "def generate_transplant_spec(feature: Feature, plan: TransplantPlan, source_graph: Graph, target_name: str, output_dir: str) -> str",
          "docstring": "Generate TRANSPLANT.md spec file.",
          "methods": [],
          "line": 227
        },
        {
          "name": "format_guide",
          "type": "function",
          "signature": "def format_guide(feature_name: str, source_name: str, target_name: str, context_path: str, tokens: int, tokens_saved: int) -> str",
          "docstring": "Format the guide output for the user.",
          "methods": [],
          "line": 303
        },
        {
          "name": "run_take",
          "type": "function",
          "signature": "def run_take(description: str, verbose: bool) -> dict",
          "docstring": "Run the take mode.",
          "methods": [],
          "line": 342
        }
      ],
      "deps_internal": [
        "ops.py",
        "registry.py",
        "state.py",
        "memory.py",
        "graph.py",
        "indexer.py",
        "context.py"
      ],
      "deps_external": []
    },
    "modes/discuss.py": {
      "path": "modes/discuss.py",
      "lang": "python",
      "lines": 191,
      "summary": "Discussion context output.",
      "interfaces": [
        {
          "name": "DiscussionContext",
          "type": "class",
          "signature": "",
          "docstring": "Context extracted from discussion phase.",
          "methods": [
            "to_markdown",
            "to_dict",
            "from_dict",
            "save",
            "load"
          ],
          "line": 18
        },
        {
          "name": "build_discussion_context",
          "type": "function",
          "signature": "def build_discussion_context(phase_id: str, goal: str, phase_boundary: str, decisions: Dict[str, List[str]], answers: Dict[str, str], deferred: List[str], known_deps: set) -> DiscussionContext",
          "docstring": "Build discussion context from phase outputs.",
          "methods": [],
          "line": 143
        }
      ],
      "deps_internal": [
        "discovery.py"
      ],
      "deps_external": []
    },
    "modes/new.py": {
      "path": "modes/new.py",
      "lang": "python",
      "lines": 743,
      "summary": "New Mode - Create new project from scratch.",
      "interfaces": [
        {
          "name": "ProjectSpec",
          "type": "class",
          "signature": "",
          "docstring": "Specification for a new project.",
          "methods": [],
          "line": 27
        },
        {
          "name": "Question",
          "type": "class",
          "signature": "",
          "docstring": "A question to ask the user.",
          "methods": [],
          "line": 49
        },
        {
          "name": "QUESTIONS",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 60
        },
        {
          "name": "slugify",
          "type": "function",
          "signature": "def slugify(name: str) -> str",
          "docstring": "Convert name to valid directory name.",
          "methods": [],
          "line": 99
        },
        {
          "name": "generate_project_spec",
          "type": "function",
          "signature": "def generate_project_spec(answers: Dict[str, str], description: str) -> ProjectSpec",
          "docstring": "Generate project specification from answers.",
          "methods": [],
          "line": 104
        },
        {
          "name": "get_structure_for",
          "type": "function",
          "signature": "def get_structure_for(language: str, framework: Optional[str]) -> tuple",
          "docstring": "Get directory structure and key files for language/framework.",
          "methods": [],
          "line": 139
        },
        {
          "name": "create_chunks",
          "type": "function",
          "signature": "def create_chunks(core_feature: str, language: str, framework: Optional[str]) -> List[Dict]",
          "docstring": "Break core feature into buildable chunks.",
          "methods": [],
          "line": 180
        },
        {
          "name": "generate_project_md",
          "type": "function",
          "signature": "def generate_project_md(spec: ProjectSpec, output_dir: str) -> str",
          "docstring": "Generate PROJECT.md specification.",
          "methods": [],
          "line": 218
        },
        {
          "name": "generate_structure_md",
          "type": "function",
          "signature": "def generate_structure_md(spec: ProjectSpec, output_dir: str) -> str",
          "docstring": "Generate STRUCTURE.md with directory layout.",
          "methods": [],
          "line": 272
        },
        {
          "name": "generate_chunk_context",
          "type": "function",
          "signature": "def generate_chunk_context(spec: ProjectSpec, chunk_id: str, output_dir: str) -> tuple",
          "docstring": "Generate context file for a specific chunk.",
          "methods": [],
          "line": 306
        },
        {
          "name": "create_project_skeleton",
          "type": "function",
          "signature": "def create_project_skeleton(spec: ProjectSpec, base_path: str) -> str",
          "docstring": "Create the actual project directory structure.",
          "methods": [],
          "line": 426
        },
        {
          "name": "format_guide",
          "type": "function",
          "signature": "def format_guide(spec: ProjectSpec, project_path: str, context_path: str, tokens: int, current_chunk: Dict) -> str",
          "docstring": "Format the guide output for the user.",
          "methods": [],
          "line": 471
        },
        {
          "name": "save_new_state",
          "type": "function",
          "signature": "def save_new_state(spec: ProjectSpec, project_path: str, current_chunk: str)",
          "docstring": "Save state for resuming.",
          "methods": [],
          "line": 505
        },
        {
          "name": "load_new_state",
          "type": "function",
          "signature": "def load_new_state(project_path: str) -> Optional[dict]",
          "docstring": "Load saved new project state.",
          "methods": [],
          "line": 533
        },
        {
          "name": "run_new",
          "type": "function",
          "signature": "def run_new(description: str, output_dir: Optional[str], answers: Optional[Dict[str, str]], verbose: bool) -> dict",
          "docstring": "Run the new mode.",
          "methods": [],
          "line": 543
        },
        {
          "name": "run_next",
          "type": "function",
          "signature": "def run_next(project_path: Optional[str], verbose: bool) -> dict",
          "docstring": "Advance to next chunk in new project.",
          "methods": [],
          "line": 658
        }
      ],
      "deps_internal": [
        "registry.py",
        "state.py"
      ],
      "deps_external": []
    },
    "modes/work.py": {
      "path": "modes/work.py",
      "lang": "python",
      "lines": 543,
      "summary": "Work Mode - Modify existing project.",
      "interfaces": [
        {
          "name": "get_module_info",
          "type": "function",
          "signature": "def get_module_info(project_path: str, module_path: str, graph: 'Graph') -> Optional[dict]",
          "docstring": "Get module info, checking v2 knowledge first then v1 graph.",
          "methods": [],
          "line": 32
        },
        {
          "name": "WorkRequest",
          "type": "class",
          "signature": "",
          "docstring": "Parsed work command.",
          "methods": [],
          "line": 69
        },
        {
          "name": "parse_work_request",
          "type": "function",
          "signature": "def parse_work_request(project: Optional[str], task: str) -> WorkRequest",
          "docstring": "Parse work request.",
          "methods": [],
          "line": 75
        },
        {
          "name": "resolve_project",
          "type": "function",
          "signature": "def resolve_project(request: WorkRequest, registry: Registry) -> Tuple[str, str]",
          "docstring": "Resolve which project to work on.",
          "methods": [],
          "line": 80
        },
        {
          "name": "find_relevant_modules",
          "type": "function",
          "signature": "def find_relevant_modules(graph: Graph, task: str, limit: int) -> List[Tuple[Module, float]]",
          "docstring": "Find modules relevant to the task.",
          "methods": [],
          "line": 120
        },
        {
          "name": "gather_knowledge",
          "type": "function",
          "signature": "def gather_knowledge(graph: Graph, modules: List[Tuple[Module, float]]) -> dict",
          "docstring": "Gather existing knowledge about relevant modules.",
          "methods": [],
          "line": 133
        },
        {
          "name": "generate_task_spec",
          "type": "function",
          "signature": "def generate_task_spec(project_name: str, task: str, modules: List[Tuple[Module, float]], knowledge: dict, output_dir: str) -> str",
          "docstring": "Generate TASK.md spec file.",
          "methods": [],
          "line": 174
        },
        {
          "name": "generate_work_context",
          "type": "function",
          "signature": "def generate_work_context(project_name: str, project_path: str, task: str, modules: List[Tuple[Module, float]], knowledge: dict, graph: Graph, output_dir: str) -> Tuple[str, int]",
          "docstring": "Generate context file for CC.",
          "methods": [],
          "line": 241
        },
        {
          "name": "format_guide",
          "type": "function",
          "signature": "def format_guide(project_name: str, task: str, modules: List[Tuple[Module, float]], knowledge: dict, context_path: str, tokens: int) -> str",
          "docstring": "Format the guide output for the user.",
          "methods": [],
          "line": 371
        },
        {
          "name": "run_work",
          "type": "function",
          "signature": "def run_work(project: Optional[str], task: str, verbose: bool) -> dict",
          "docstring": "Run the work mode.",
          "methods": [],
          "line": 416
        }
      ],
      "deps_internal": [
        "ops.py",
        "registry.py",
        "state.py",
        "memory.py",
        "graph.py",
        "indexer.py"
      ],
      "deps_external": []
    },
    "modes/__init__.py": {
      "path": "modes/__init__.py",
      "lang": "python",
      "lines": 23,
      "summary": "EriRPG Modes - Three ways to work.",
      "interfaces": [],
      "deps_internal": [
        "modes/work.py",
        "modes/take.py",
        "modes/new.py",
        "modes/discuss.py"
      ],
      "deps_external": []
    },
    "agent/run.py": {
      "path": "agent/run.py",
      "lang": "python",
      "lines": 623,
      "summary": "Run state management.",
      "interfaces": [
        {
          "name": "StepResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of executing a single step.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 25
        },
        {
          "name": "WaveResult",
          "type": "class",
          "signature": "",
          "docstring": "Result of executing a wave of steps.",
          "methods": [
            "errors",
            "to_dict",
            "from_dict"
          ],
          "line": 42
        },
        {
          "name": "WaveCheckpoint",
          "type": "class",
          "signature": "",
          "docstring": "Checkpoint for resumable wave execution.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 72
        },
        {
          "name": "ExecutionResult",
          "type": "class",
          "signature": "",
          "docstring": "Final result of wave execution.",
          "methods": [
            "to_dict"
          ],
          "line": 104
        },
        {
          "name": "WaveExecutor",
          "type": "class",
          "signature": "",
          "docstring": "Executes plan steps in waves with checkpoint support.",
          "methods": [
            "__init__",
            "save_checkpoint",
            "load_checkpoint",
            "clear_checkpoint"
          ],
          "line": 118
        },
        {
          "name": "Decision",
          "type": "class",
          "signature": "",
          "docstring": "A decision made during run execution.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 264
        },
        {
          "name": "RunSummary",
          "type": "class",
          "signature": "",
          "docstring": "Summary of a completed run.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 293
        },
        {
          "name": "RunState",
          "type": "class",
          "signature": "",
          "docstring": "Persistent state for an agent run.",
          "methods": [
            "current_step",
            "is_complete",
            "progress",
            "add_log",
            "start_step",
            "complete_step",
            "fail_step",
            "skip_step",
            "add_learned_files",
            "track_file_edit",
            "add_decision",
            "generate_summary",
            "get_report",
            "to_dict",
            "from_dict",
            "save",
            "load"
          ],
          "line": 328
        },
        {
          "name": "get_run_dir",
          "type": "function",
          "signature": "def get_run_dir(project_path: str) -> str",
          "docstring": "Get the runs directory for a project.",
          "methods": [],
          "line": 572
        },
        {
          "name": "save_run",
          "type": "function",
          "signature": "def save_run(project_path: str, run: RunState) -> str",
          "docstring": "Save a run to the project's runs directory.",
          "methods": [],
          "line": 577
        },
        {
          "name": "load_run",
          "type": "function",
          "signature": "def load_run(project_path: str, run_id: str) -> Optional[RunState]",
          "docstring": "Load a run by ID.",
          "methods": [],
          "line": 586
        },
        {
          "name": "list_runs",
          "type": "function",
          "signature": "def list_runs(project_path: str) -> List[Dict[str, Any]]",
          "docstring": "List all runs for a project.",
          "methods": [],
          "line": 594
        },
        {
          "name": "get_latest_run",
          "type": "function",
          "signature": "def get_latest_run(project_path: str) -> Optional[RunState]",
          "docstring": "Get the most recent run.",
          "methods": [],
          "line": 617
        }
      ],
      "deps_internal": [
        "spec.py",
        "agent/plan.py"
      ],
      "deps_external": []
    },
    "agent/spec.py": {
      "path": "agent/spec.py",
      "lang": "python",
      "lines": 9,
      "summary": "Backward compatibility - re-exports from erirpg.spec.",
      "interfaces": [],
      "deps_internal": [
        "spec.py"
      ],
      "deps_external": []
    },
    "agent/plan.py": {
      "path": "agent/plan.py",
      "lang": "python",
      "lines": 312,
      "summary": "Plan generation from specs.",
      "interfaces": [
        {
          "name": "StepStatus",
          "type": "class",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 15
        },
        {
          "name": "CircularDependencyError",
          "type": "class",
          "signature": "",
          "docstring": "Raised when circular dependencies are detected in step graph.",
          "methods": [
            "__init__"
          ],
          "line": 23
        },
        {
          "name": "AvoidPattern",
          "type": "class",
          "signature": "",
          "docstring": "A pattern to avoid during step execution.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 31
        },
        {
          "name": "Step",
          "type": "class",
          "signature": "",
          "docstring": "A single executable step in a plan.",
          "methods": [
            "to_dict",
            "from_dict"
          ],
          "line": 54
        },
        {
          "name": "Plan",
          "type": "class",
          "signature": "",
          "docstring": "An executable plan generated from a spec.",
          "methods": [
            "create",
            "current_step",
            "next_step",
            "is_complete",
            "completed_steps",
            "failed_steps",
            "progress",
            "to_dict",
            "from_dict",
            "save",
            "load",
            "waves"
          ],
          "line": 144
        },
        {
          "name": "compute_waves",
          "type": "function",
          "signature": "def compute_waves(steps: List[Step]) -> Dict[int, List[Step]]",
          "docstring": "Compute execution waves based on step dependencies.",
          "methods": [],
          "line": 245
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "agent/learner.py": {
      "path": "agent/learner.py",
      "lang": "python",
      "lines": 200,
      "summary": "Auto-learning module.",
      "interfaces": [
        {
          "name": "auto_learn",
          "type": "function",
          "signature": "def auto_learn(project_path: str, files: List[str], step_goal: str, notes: str, project_name: Optional[str]) -> List[str]",
          "docstring": "Automatically create learnings for touched files.",
          "methods": [],
          "line": 16
        },
        {
          "name": "update_learning",
          "type": "function",
          "signature": "def update_learning(project_path: str, file_path: str, summary: Optional[str], purpose: Optional[str], key_functions: Optional[Dict[str, str]], gotchas: Optional[List[str]], project_name: Optional[str]) -> bool",
          "docstring": "Update an existing learning with richer information.",
          "methods": [],
          "line": 82
        },
        {
          "name": "get_knowledge",
          "type": "function",
          "signature": "def get_knowledge(project_path: str, file_path: str, project_name: Optional[str]) -> Optional[StoredLearning]",
          "docstring": "Get stored knowledge for a file.",
          "methods": [],
          "line": 132
        },
        {
          "name": "is_stale",
          "type": "function",
          "signature": "def is_stale(project_path: str, file_path: str, project_name: Optional[str]) -> bool",
          "docstring": "Check if knowledge for a file is stale.",
          "methods": [],
          "line": 155
        },
        {
          "name": "get_all_knowledge",
          "type": "function",
          "signature": "def get_all_knowledge(project_path: str, project_name: Optional[str]) -> Dict[str, StoredLearning]",
          "docstring": "Get all stored knowledge for a project.",
          "methods": [],
          "line": 173
        },
        {
          "name": "get_stale_knowledge",
          "type": "function",
          "signature": "def get_stale_knowledge(project_path: str, project_name: Optional[str]) -> List[str]",
          "docstring": "Get list of files with stale knowledge.",
          "methods": [],
          "line": 185
        }
      ],
      "deps_internal": [
        "refs.py",
        "memory.py"
      ],
      "deps_external": []
    },
    "agent/__init__.py": {
      "path": "agent/__init__.py",
      "lang": "python",
      "lines": 1679,
      "summary": "EriRPG Agent API.",
      "interfaces": [
        {
          "name": "get_active_agent",
          "type": "function",
          "signature": "def get_active_agent() -> 'Agent'",
          "docstring": "Get the current active agent or raise error.",
          "methods": [],
          "line": 75
        },
        {
          "name": "require_preflight",
          "type": "function",
          "signature": "def require_preflight() -> None",
          "docstring": "Check that preflight was done or raise error.",
          "methods": [],
          "line": 100
        },
        {
          "name": "_set_active_agent",
          "type": "function",
          "signature": "def _set_active_agent(agent: Optional['Agent']) -> None",
          "docstring": "Set the active agent (internal use only).",
          "methods": [],
          "line": 123
        },
        {
          "name": "_set_preflight_done",
          "type": "function",
          "signature": "def _set_preflight_done(done: bool) -> None",
          "docstring": "Set preflight state (internal use only).",
          "methods": [],
          "line": 129
        },
        {
          "name": "Agent",
          "type": "class",
          "signature": "",
          "docstring": "Main agent interface for spec-driven execution.",
          "methods": [
            "__init__",
            "config",
            "multi_agent_enabled",
            "max_concurrency",
            "from_spec",
            "from_goal",
            "resume",
            "_generate_plan",
            "_create_run",
            "from_new_spec",
            "next_step",
            "verify_step",
            "get_spec_status",
            "current_step",
            "is_complete",
            "progress",
            "needs_discussion",
            "start_step",
            "complete_step",
            "_git_commit",
            "_get_project_name",
            "_run_verification",
            "_update_learning_commits",
            "fail_step",
            "skip_step",
            "get_context",
            "_get_relevant_knowledge",
            "recall",
            "learn",
            "is_knowledge_stale",
            "preflight",
            "_save_preflight_state",
            "_clear_preflight_state",
            "_snapshot_file",
            "reset_preflight",
            "get_report",
            "add_decision",
            "generate_summary",
            "edit_file",
            "write_file",
            "rollback",
            "_rollback_git",
            "list_versions",
            "can_rollback",
            "_save"
          ],
          "line": 138
        }
      ],
      "deps_internal": [
        "spec.py",
        "agent/learner.py",
        "config.py",
        "memory.py",
        "agent/run.py",
        "agent/plan.py"
      ],
      "deps_external": []
    },
    "cli_commands/drift.py": {
      "path": "cli_commands/drift.py",
      "lang": "python",
      "lines": 423,
      "summary": "Drift Commands - Drift integration and pattern synchronization.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register drift commands with CLI.",
          "methods": [],
          "line": 21
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/goal.py": {
      "path": "cli_commands/goal.py",
      "lang": "python",
      "lines": 1038,
      "summary": "Goal Commands - Spec-driven execution commands.",
      "interfaces": [
        {
          "name": "_parse_research_for_phases",
          "type": "function",
          "signature": "def _parse_research_for_phases(research_content: str, goal: str)",
          "docstring": "Parse research content to extract phases, files, and structure.",
          "methods": [],
          "line": 20
        },
        {
          "name": "_generate_progress_bar",
          "type": "function",
          "signature": "def _generate_progress_bar(completed: int, total: int, width: int) -> str",
          "docstring": "Generate a text progress bar.",
          "methods": [],
          "line": 106
        },
        {
          "name": "_check_phase_completion",
          "type": "function",
          "signature": "def _check_phase_completion(project_path: str, phase: dict) -> tuple[bool, list[str]]",
          "docstring": "Check if a phase's deliverables exist.",
          "methods": [],
          "line": 115
        },
        {
          "name": "update_session_files",
          "type": "function",
          "signature": "def update_session_files(project_path: str, project_name: str, completed_phase: int, activity: str)",
          "docstring": "Update session-persistent files based on current file state.",
          "methods": [],
          "line": 133
        },
        {
          "name": "_generate_session_files",
          "type": "function",
          "signature": "def _generate_session_files(project_path: str, project_name: str, goal: str, spec, knowledge)",
          "docstring": "Generate all session-persistent files for /clear survival.",
          "methods": [],
          "line": 425
        },
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register goal commands with CLI.",
          "methods": [],
          "line": 810
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/mode.py": {
      "path": "cli_commands/mode.py",
      "lang": "python",
      "lines": 427,
      "summary": "Mode Commands - Bootstrap/Maintain mode and Tier management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register mode commands with CLI.",
          "methods": [],
          "line": 25
        }
      ],
      "deps_internal": [
        "registry.py",
        "config.py",
        "memory.py",
        "indexer.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/plan_group.py": {
      "path": "cli_commands/plan_group.py",
      "lang": "python",
      "lines": 296,
      "summary": "Plan Commands - Plan management for executable workflows.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register plan group commands with CLI.",
          "methods": [],
          "line": 20
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/guards.py": {
      "path": "cli_commands/guards.py",
      "lang": "python",
      "lines": 158,
      "summary": "CLI Command Guards - Tier-based command gating.",
      "interfaces": [
        {
          "name": "get_project_path_from_context",
          "type": "function",
          "signature": "def get_project_path_from_context(ctx: click.Context, project_arg: Optional[str]) -> Optional[str]",
          "docstring": "Extract project path from Click context or argument.",
          "methods": [],
          "line": 21
        },
        {
          "name": "tier_required",
          "type": "function",
          "signature": "def tier_required(min_tier: Tier)",
          "docstring": "Decorator to gate commands by minimum tier level.",
          "methods": [],
          "line": 63
        },
        {
          "name": "tier_hidden",
          "type": "function",
          "signature": "def tier_hidden(min_tier: Tier)",
          "docstring": "Decorator to hide commands from --help if tier is below minimum.",
          "methods": [],
          "line": 125
        },
        {
          "name": "standard_tier",
          "type": "function",
          "signature": "def standard_tier(f: Callable) -> Callable",
          "docstring": "Shorthand for @tier_required(\"standard\").",
          "methods": [],
          "line": 150
        },
        {
          "name": "full_tier",
          "type": "function",
          "signature": "def full_tier(f: Callable) -> Callable",
          "docstring": "Shorthand for @tier_required(\"full\").",
          "methods": [],
          "line": 155
        }
      ],
      "deps_internal": [
        "registry.py",
        "config.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/roadmap.py": {
      "path": "cli_commands/roadmap.py",
      "lang": "python",
      "lines": 213,
      "summary": "Roadmap Commands - Roadmap progress and management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register roadmap commands with CLI.",
          "methods": [],
          "line": 17
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/config_cmd.py": {
      "path": "cli_commands/config_cmd.py",
      "lang": "python",
      "lines": 56,
      "summary": "Configuration Commands - Project settings management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register configuration commands with CLI.",
          "methods": [],
          "line": 12
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/explore.py": {
      "path": "cli_commands/explore.py",
      "lang": "python",
      "lines": 202,
      "summary": "Exploration Commands - Project structure and module discovery.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register exploration commands with CLI.",
          "methods": [],
          "line": 17
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/orchestration.py": {
      "path": "cli_commands/orchestration.py",
      "lang": "python",
      "lines": 251,
      "summary": "Orchestration Commands - Task parsing and workflow coordination.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register orchestration commands with CLI.",
          "methods": [],
          "line": 20
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/persona_cmd.py": {
      "path": "cli_commands/persona_cmd.py",
      "lang": "python",
      "lines": 209,
      "summary": "Persona Commands - Persona and context management (SuperClaude replacement).",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register persona commands with CLI.",
          "methods": [],
          "line": 18
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/install.py": {
      "path": "cli_commands/install.py",
      "lang": "python",
      "lines": 55,
      "summary": "Install Commands - Claude Code integration.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register install commands with CLI.",
          "methods": [],
          "line": 13
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/discuss.py": {
      "path": "cli_commands/discuss.py",
      "lang": "python",
      "lines": 245,
      "summary": "Discuss Commands - Goal clarification and discussion management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register discuss commands with CLI.",
          "methods": [],
          "line": 18
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/verify_group.py": {
      "path": "cli_commands/verify_group.py",
      "lang": "python",
      "lines": 198,
      "summary": "Verify Commands - Code verification and quality checks.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register verify group commands with CLI.",
          "methods": [],
          "line": 18
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/storage_cmd.py": {
      "path": "cli_commands/storage_cmd.py",
      "lang": "python",
      "lines": 203,
      "summary": "Storage CLI commands for SQLite graph operations.",
      "interfaces": [
        {
          "name": "db_stats_cmd",
          "type": "function",
          "signature": "def db_stats_cmd()",
          "docstring": "Show SQLite database statistics.",
          "methods": [],
          "line": 20
        },
        {
          "name": "db_migrate_cmd",
          "type": "function",
          "signature": "def db_migrate_cmd(verbose: bool)",
          "docstring": "Migrate all JSON graphs to SQLite database.",
          "methods": [],
          "line": 57
        },
        {
          "name": "db_export_cmd",
          "type": "function",
          "signature": "def db_export_cmd(project: str, output: Optional[str])",
          "docstring": "Export a project's graph from SQLite to JSON.",
          "methods": [],
          "line": 87
        },
        {
          "name": "find_interface_cmd",
          "type": "function",
          "signature": "def find_interface_cmd(name: str, iface_type: Optional[str])",
          "docstring": "Find interfaces across all projects.",
          "methods": [],
          "line": 105
        },
        {
          "name": "find_package_cmd",
          "type": "function",
          "signature": "def find_package_cmd(package: str)",
          "docstring": "Find usage of an external package across projects.",
          "methods": [],
          "line": 141
        },
        {
          "name": "find_dependents_cmd",
          "type": "function",
          "signature": "def find_dependents_cmd(module_path: str)",
          "docstring": "Find modules depending on a path across projects.",
          "methods": [],
          "line": 169
        },
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli: click.Group) -> None",
          "docstring": "Register storage commands with the CLI.",
          "methods": [],
          "line": 195
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "erirpg",
        "click"
      ]
    },
    "cli_commands/session.py": {
      "path": "cli_commands/session.py",
      "lang": "python",
      "lines": 271,
      "summary": "Session Commands - Session state and gap closure.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register session commands with CLI.",
          "methods": [],
          "line": 14
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/modes.py": {
      "path": "cli_commands/modes.py",
      "lang": "python",
      "lines": 404,
      "summary": "Mode Commands - Core workflow commands for EriRPG.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register mode commands with CLI.",
          "methods": [],
          "line": 24
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/spec_group.py": {
      "path": "cli_commands/spec_group.py",
      "lang": "python",
      "lines": 247,
      "summary": "Spec Commands - Spec management for structured task definitions.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register spec group commands with CLI.",
          "methods": [],
          "line": 19
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/analyze_cmd.py": {
      "path": "cli_commands/analyze_cmd.py",
      "lang": "python",
      "lines": 236,
      "summary": "Analyze Commands - Pattern analysis and implementation.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register analyze commands with CLI.",
          "methods": [],
          "line": 17
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/cleanup.py": {
      "path": "cli_commands/cleanup.py",
      "lang": "python",
      "lines": 206,
      "summary": "Cleanup Commands - Run management and housekeeping.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register cleanup commands with CLI.",
          "methods": [],
          "line": 18
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/ui.py": {
      "path": "cli_commands/ui.py",
      "lang": "python",
      "lines": 55,
      "summary": "UI Commands - Web dashboard.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register UI commands with CLI.",
          "methods": [],
          "line": 14
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/knowledge.py": {
      "path": "cli_commands/knowledge.py",
      "lang": "python",
      "lines": 493,
      "summary": "Knowledge Commands - Learning storage and retrieval.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register knowledge commands with CLI.",
          "methods": [],
          "line": 23
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/run_group.py": {
      "path": "cli_commands/run_group.py",
      "lang": "python",
      "lines": 290,
      "summary": "Run Commands - Execution management for plans.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register run group commands with CLI.",
          "methods": [],
          "line": 21
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/metadata.py": {
      "path": "cli_commands/metadata.py",
      "lang": "python",
      "lines": 341,
      "summary": "Metadata Commands - Project metadata management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register metadata commands with CLI.",
          "methods": [],
          "line": 21
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/setup.py": {
      "path": "cli_commands/setup.py",
      "lang": "python",
      "lines": 129,
      "summary": "Setup Commands - Project registration and indexing.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register setup commands with CLI.",
          "methods": [],
          "line": 19
        }
      ],
      "deps_internal": [
        "registry.py",
        "config.py",
        "indexer.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/memory_group.py": {
      "path": "cli_commands/memory_group.py",
      "lang": "python",
      "lines": 323,
      "summary": "Memory Commands - V2 knowledge storage management.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register memory group commands with CLI.",
          "methods": [],
          "line": 20
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/quick.py": {
      "path": "cli_commands/quick.py",
      "lang": "python",
      "lines": 140,
      "summary": "Quick Fix Commands - Lightweight mode for simple changes.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register quick fix commands with CLI.",
          "methods": [],
          "line": 15
        }
      ],
      "deps_internal": [],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/decisions.py": {
      "path": "cli_commands/decisions.py",
      "lang": "python",
      "lines": 202,
      "summary": "Decision Commands - Decision logging and deferred ideas.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register decision commands with CLI.",
          "methods": [],
          "line": 18
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "cli_commands/__init__.py": {
      "path": "cli_commands/__init__.py",
      "lang": "python",
      "lines": 118,
      "summary": "EriRPG CLI Commands - Modular command structure.",
      "interfaces": [
        {
          "name": "register_all",
          "type": "function",
          "signature": "def register_all(cli: 'click.Group') -> None",
          "docstring": "Register all command modules with the CLI group.",
          "methods": [],
          "line": 53
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "cli_commands/transplant.py": {
      "path": "cli_commands/transplant.py",
      "lang": "python",
      "lines": 205,
      "summary": "Transplant Commands - Feature extraction and transplant operations.",
      "interfaces": [
        {
          "name": "register",
          "type": "function",
          "signature": "def register(cli)",
          "docstring": "Register transplant commands with CLI.",
          "methods": [],
          "line": 17
        }
      ],
      "deps_internal": [
        "cli_commands/guards.py"
      ],
      "deps_external": [
        "click"
      ]
    },
    "hooks/pretooluse.py": {
      "path": "hooks/pretooluse.py",
      "lang": "python",
      "lines": 526,
      "summary": "EriRPG PreToolUse Hook - HARD ENFORCEMENT",
      "interfaces": [
        {
          "name": "HOOK_DIR",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 44
        },
        {
          "name": "ERIRPG_ROOT",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 45
        },
        {
          "name": "LOG_FILE",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 46
        },
        {
          "name": "log",
          "type": "function",
          "signature": "def log(msg: str)",
          "docstring": "Log to file for debugging.",
          "methods": [],
          "line": 49
        },
        {
          "name": "get_active_run_state",
          "type": "function",
          "signature": "def get_active_run_state(project_path: str) -> dict",
          "docstring": "Check for active EriRPG run in project.",
          "methods": [],
          "line": 58
        },
        {
          "name": "get_preflight_state",
          "type": "function",
          "signature": "def get_preflight_state(project_path: str) -> dict",
          "docstring": "Check for active preflight state.",
          "methods": [],
          "line": 85
        },
        {
          "name": "get_quick_fix_state",
          "type": "function",
          "signature": "def get_quick_fix_state(project_path: str) -> dict",
          "docstring": "Check for active quick fix state.",
          "methods": [],
          "line": 98
        },
        {
          "name": "get_project_mode",
          "type": "function",
          "signature": "def get_project_mode(project_path: str) -> str",
          "docstring": "Get the operational mode for a project.",
          "methods": [],
          "line": 111
        },
        {
          "name": "get_enforcement_config",
          "type": "function",
          "signature": "def get_enforcement_config(project_path: str) -> dict",
          "docstring": "Get enforcement configuration for a project.",
          "methods": [],
          "line": 148
        },
        {
          "name": "detect_bash_file_write",
          "type": "function",
          "signature": "def detect_bash_file_write(command: str) -> str",
          "docstring": "Detect if a Bash command writes to a file. Returns the file path or None.",
          "methods": [],
          "line": 177
        },
        {
          "name": "main",
          "type": "function",
          "signature": "def main()",
          "docstring": "Main hook entry point.",
          "methods": [],
          "line": 209
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "hooks/sessionstart.py": {
      "path": "hooks/sessionstart.py",
      "lang": "python",
      "lines": 187,
      "summary": "EriRPG SessionStart Hook - Check for incomplete runs at session start.",
      "interfaces": [
        {
          "name": "log",
          "type": "function",
          "signature": "def log(msg: str)",
          "docstring": "Log to file for debugging.",
          "methods": [],
          "line": 17
        },
        {
          "name": "find_project_roots",
          "type": "function",
          "signature": "def find_project_roots(start_path: str) -> list",
          "docstring": "Find all project roots with .eri-rpg directories.",
          "methods": [],
          "line": 26
        },
        {
          "name": "get_incomplete_runs",
          "type": "function",
          "signature": "def get_incomplete_runs(project_path: str) -> list",
          "docstring": "Get list of incomplete runs.",
          "methods": [],
          "line": 41
        },
        {
          "name": "get_quick_fix_state",
          "type": "function",
          "signature": "def get_quick_fix_state(project_path: str) -> dict",
          "docstring": "Get active quick fix state.",
          "methods": [],
          "line": 87
        },
        {
          "name": "get_resume_file",
          "type": "function",
          "signature": "def get_resume_file(project_path: str) -> str",
          "docstring": "Get contents of resume.md if it exists.",
          "methods": [],
          "line": 100
        },
        {
          "name": "main",
          "type": "function",
          "signature": "def main()",
          "docstring": "Main hook entry point.",
          "methods": [],
          "line": 112
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "hooks/precompact.py": {
      "path": "hooks/precompact.py",
      "lang": "python",
      "lines": 216,
      "summary": "EriRPG PreCompact Hook - Save state before context compaction.",
      "interfaces": [
        {
          "name": "log",
          "type": "function",
          "signature": "def log(msg: str)",
          "docstring": "Log to file for debugging.",
          "methods": [],
          "line": 19
        },
        {
          "name": "find_project_root",
          "type": "function",
          "signature": "def find_project_root(start_path: str) -> str",
          "docstring": "Find project root by looking for .eri-rpg directory.",
          "methods": [],
          "line": 28
        },
        {
          "name": "get_active_run",
          "type": "function",
          "signature": "def get_active_run(project_path: str) -> dict",
          "docstring": "Get the most recent active run.",
          "methods": [],
          "line": 38
        },
        {
          "name": "get_quick_fix_state",
          "type": "function",
          "signature": "def get_quick_fix_state(project_path: str) -> dict",
          "docstring": "Get active quick fix state.",
          "methods": [],
          "line": 63
        },
        {
          "name": "create_resume_file",
          "type": "function",
          "signature": "def create_resume_file(project_path: str, run_state: dict, quick_fix: dict) -> str",
          "docstring": "Create a resume.md file with instructions for continuing after compaction.",
          "methods": [],
          "line": 76
        },
        {
          "name": "main",
          "type": "function",
          "signature": "def main()",
          "docstring": "Main hook entry point.",
          "methods": [],
          "line": 153
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "ui/data.py": {
      "path": "ui/data.py",
      "lang": "python",
      "lines": 283,
      "summary": "Data loading helpers for EriRPG UI.",
      "interfaces": [
        {
          "name": "REGISTRY_PATH",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 9
        },
        {
          "name": "load_registry",
          "type": "function",
          "signature": "def load_registry() -> Dict[str, Any]",
          "docstring": "Load the global project registry.",
          "methods": [],
          "line": 12
        },
        {
          "name": "get_project",
          "type": "function",
          "signature": "def get_project(name: str) -> Optional[Dict[str, Any]]",
          "docstring": "Get a project from registry by name.",
          "methods": [],
          "line": 22
        },
        {
          "name": "get_project_path",
          "type": "function",
          "signature": "def get_project_path(name: str) -> Optional[Path]",
          "docstring": "Get project path from registry.",
          "methods": [],
          "line": 28
        },
        {
          "name": "load_state",
          "type": "function",
          "signature": "def load_state(project_path: str) -> Dict[str, Any]",
          "docstring": "Load project state.json.",
          "methods": [],
          "line": 36
        },
        {
          "name": "load_knowledge",
          "type": "function",
          "signature": "def load_knowledge(project_path: str) -> Dict[str, Any]",
          "docstring": "Load project knowledge.json.",
          "methods": [],
          "line": 47
        },
        {
          "name": "load_graph",
          "type": "function",
          "signature": "def load_graph(project_path: str) -> Dict[str, Any]",
          "docstring": "Load project dependency graph.",
          "methods": [],
          "line": 58
        },
        {
          "name": "load_runs",
          "type": "function",
          "signature": "def load_runs(project_path: str) -> List[Dict[str, Any]]",
          "docstring": "Load all runs from project runs directory.",
          "methods": [],
          "line": 69
        },
        {
          "name": "load_roadmap",
          "type": "function",
          "signature": "def load_roadmap(project_path: str) -> Optional[str]",
          "docstring": "Load project roadmap markdown.",
          "methods": [],
          "line": 88
        },
        {
          "name": "count_modules",
          "type": "function",
          "signature": "def count_modules(project_path: str) -> int",
          "docstring": "Count nodes in dependency graph.",
          "methods": [],
          "line": 99
        },
        {
          "name": "load_config",
          "type": "function",
          "signature": "def load_config(project_path: str) -> Dict[str, Any]",
          "docstring": "Load project config.json.",
          "methods": [],
          "line": 106
        },
        {
          "name": "get_project_mode",
          "type": "function",
          "signature": "def get_project_mode(project_path: str) -> str",
          "docstring": "Get project operational mode (bootstrap or maintain).",
          "methods": [],
          "line": 117
        },
        {
          "name": "count_learned",
          "type": "function",
          "signature": "def count_learned(project_path: str) -> int",
          "docstring": "Count entries in knowledge.learnings.",
          "methods": [],
          "line": 137
        },
        {
          "name": "check_staleness",
          "type": "function",
          "signature": "def check_staleness(project_path: str, file_path: str, source_ref: Dict) -> bool",
          "docstring": "Check if a learning is stale.",
          "methods": [],
          "line": 143
        },
        {
          "name": "format_relative_time",
          "type": "function",
          "signature": "def format_relative_time(timestamp: float) -> str",
          "docstring": "Format timestamp as relative time.",
          "methods": [],
          "line": 158
        },
        {
          "name": "get_last_active",
          "type": "function",
          "signature": "def get_last_active(project_path: str) -> Optional[str]",
          "docstring": "Get timestamp of last activity.",
          "methods": [],
          "line": 172
        },
        {
          "name": "get_git_log",
          "type": "function",
          "signature": "def get_git_log(project_path: str, limit: int) -> List[Dict[str, Any]]",
          "docstring": "Get git log for project.",
          "methods": [],
          "line": 187
        },
        {
          "name": "get_drift_status",
          "type": "function",
          "signature": "def get_drift_status(project_path: str) -> Dict[str, Any]",
          "docstring": "Get Drift integration status.",
          "methods": [],
          "line": 213
        },
        {
          "name": "get_all_projects",
          "type": "function",
          "signature": "def get_all_projects() -> List[Dict[str, Any]]",
          "docstring": "Get all projects with stats.",
          "methods": [],
          "line": 245
        },
        {
          "name": "get_active_task",
          "type": "function",
          "signature": "def get_active_task() -> Optional[Dict[str, Any]]",
          "docstring": "Find currently active task across all projects.",
          "methods": [],
          "line": 266
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "ui/server.py": {
      "path": "ui/server.py",
      "lang": "python",
      "lines": 388,
      "summary": "FastAPI server for EriRPG dashboard.",
      "interfaces": [
        {
          "name": "create_app",
          "type": "function",
          "signature": "def create_app() -> FastAPI",
          "docstring": "Create and configure the FastAPI application.",
          "methods": [],
          "line": 23
        },
        {
          "name": "_format_time",
          "type": "function",
          "signature": "def _format_time(ts) -> str",
          "docstring": "Format timestamp for templates.",
          "methods": [],
          "line": 375
        }
      ],
      "deps_internal": [
        "ui/data.py"
      ],
      "deps_external": [
        "fastapi"
      ]
    },
    "ui/__init__.py": {
      "path": "ui/__init__.py",
      "lang": "python",
      "lines": 4,
      "summary": "EriRPG Web UI - Local dashboard for monitoring EriRPG state.",
      "interfaces": [],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/dart.py": {
      "path": "parsers/dart.py",
      "lang": "python",
      "lines": 454,
      "summary": "Dart parser using regex (no external deps).",
      "interfaces": [
        {
          "name": "parse_dart_file",
          "type": "function",
          "signature": "def parse_dart_file(path: str) -> Dict[str, Any]",
          "docstring": "Parse Dart file, extract interfaces and imports.",
          "methods": [],
          "line": 18
        },
        {
          "name": "_extract_library_doc",
          "type": "function",
          "signature": "def _extract_library_doc(source: str) -> str",
          "docstring": "Extract library-level doc comment.",
          "methods": [],
          "line": 328
        },
        {
          "name": "_extract_doc_comment",
          "type": "function",
          "signature": "def _extract_doc_comment(source: str, pos: int) -> str",
          "docstring": "Extract /// doc comment immediately before a position.",
          "methods": [],
          "line": 358
        },
        {
          "name": "_summarize_params",
          "type": "function",
          "signature": "def _summarize_params(params: str) -> str",
          "docstring": "Summarize function parameters for display.",
          "methods": [],
          "line": 382
        },
        {
          "name": "resolve_import_to_module",
          "type": "function",
          "signature": "def resolve_import_to_module(import_info: dict, project_modules: List[str]) -> Optional[str]",
          "docstring": "Resolve a Dart import to a project module.",
          "methods": [],
          "line": 405
        },
        {
          "name": "classify_external_package",
          "type": "function",
          "signature": "def classify_external_package(import_info: dict) -> Optional[str]",
          "docstring": "Extract external package name from import statement.",
          "methods": [],
          "line": 440
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/rust.py": {
      "path": "parsers/rust.py",
      "lang": "python",
      "lines": 348,
      "summary": "Rust parser using regex (no external deps).",
      "interfaces": [
        {
          "name": "parse_rust_file",
          "type": "function",
          "signature": "def parse_rust_file(path: str) -> Dict[str, Any]",
          "docstring": "Parse Rust file, extract interfaces and imports.",
          "methods": [],
          "line": 17
        },
        {
          "name": "_extract_module_doc",
          "type": "function",
          "signature": "def _extract_module_doc(source: str) -> str",
          "docstring": "Extract module-level doc comment (//! or /*!).",
          "methods": [],
          "line": 229
        },
        {
          "name": "_extract_doc_comment",
          "type": "function",
          "signature": "def _extract_doc_comment(source: str, pos: int) -> str",
          "docstring": "Extract /// doc comment immediately before a position.",
          "methods": [],
          "line": 252
        },
        {
          "name": "_summarize_params",
          "type": "function",
          "signature": "def _summarize_params(params: str) -> str",
          "docstring": "Summarize function parameters for display.",
          "methods": [],
          "line": 275
        },
        {
          "name": "resolve_use_to_module",
          "type": "function",
          "signature": "def resolve_use_to_module(use_info: dict, project_modules: List[str]) -> Optional[str]",
          "docstring": "Resolve a use statement to a project module.",
          "methods": [],
          "line": 298
        },
        {
          "name": "classify_external_crate",
          "type": "function",
          "signature": "def classify_external_crate(use_info: dict) -> Optional[str]",
          "docstring": "Extract external crate name from use statement.",
          "methods": [],
          "line": 331
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/mojo.py": {
      "path": "parsers/mojo.py",
      "lang": "python",
      "lines": 489,
      "summary": "Mojo parser using regex (no external deps).",
      "interfaces": [
        {
          "name": "FIRE_EMOJI",
          "type": "const",
          "signature": "",
          "docstring": "",
          "methods": [],
          "line": 21
        },
        {
          "name": "parse_mojo_file",
          "type": "function",
          "signature": "def parse_mojo_file(path: str) -> Dict[str, Any]",
          "docstring": "Parse Mojo file, extract interfaces and imports.",
          "methods": [],
          "line": 24
        },
        {
          "name": "_extract_module_doc",
          "type": "function",
          "signature": "def _extract_module_doc(source: str) -> str",
          "docstring": "Extract module-level docstring (triple-quoted at start).",
          "methods": [],
          "line": 285
        },
        {
          "name": "_extract_doc_comment",
          "type": "function",
          "signature": "def _extract_doc_comment(source: str, pos: int) -> str",
          "docstring": "Extract docstring or # comment immediately before a position.",
          "methods": [],
          "line": 315
        },
        {
          "name": "_extract_indented_block",
          "type": "function",
          "signature": "def _extract_indented_block(source: str, start: int) -> str",
          "docstring": "Extract an indented block starting at position.",
          "methods": [],
          "line": 338
        },
        {
          "name": "_extract_struct_fields",
          "type": "function",
          "signature": "def _extract_struct_fields(body: str) -> List[str]",
          "docstring": "Extract field names from struct body.",
          "methods": [],
          "line": 371
        },
        {
          "name": "_extract_struct_methods",
          "type": "function",
          "signature": "def _extract_struct_methods(body: str) -> List[str]",
          "docstring": "Extract method names from struct body.",
          "methods": [],
          "line": 379
        },
        {
          "name": "_summarize_params",
          "type": "function",
          "signature": "def _summarize_params(params: str) -> str",
          "docstring": "Summarize function parameters for display.",
          "methods": [],
          "line": 387
        },
        {
          "name": "resolve_import_to_module",
          "type": "function",
          "signature": "def resolve_import_to_module(import_info: dict, project_modules: List[str], project_name: str, current_module: str) -> Optional[str]",
          "docstring": "Resolve a Mojo import to a project module path.",
          "methods": [],
          "line": 410
        },
        {
          "name": "classify_external_package",
          "type": "function",
          "signature": "def classify_external_package(import_info: dict) -> Optional[str]",
          "docstring": "Extract external package name from import.",
          "methods": [],
          "line": 464
        },
        {
          "name": "is_mojo_file",
          "type": "function",
          "signature": "def is_mojo_file(path: str) -> bool",
          "docstring": "Check if a file is a Mojo source file.",
          "methods": [],
          "line": 483
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/c.py": {
      "path": "parsers/c.py",
      "lang": "python",
      "lines": 219,
      "summary": "C/C++ parser using regex (no external deps).",
      "interfaces": [
        {
          "name": "parse_c_file",
          "type": "function",
          "signature": "def parse_c_file(path: str) -> Dict[str, Any]",
          "docstring": "Parse C/C++ file, extract interfaces and includes.",
          "methods": [],
          "line": 16
        },
        {
          "name": "_extract_file_comment",
          "type": "function",
          "signature": "def _extract_file_comment(source: str) -> str",
          "docstring": "Extract first block comment as file docstring.",
          "methods": [],
          "line": 157
        },
        {
          "name": "_extract_preceding_comment",
          "type": "function",
          "signature": "def _extract_preceding_comment(source: str, pos: int) -> str",
          "docstring": "Extract comment immediately before a position.",
          "methods": [],
          "line": 171
        },
        {
          "name": "resolve_include_to_module",
          "type": "function",
          "signature": "def resolve_include_to_module(include_info: dict, project_headers: List[str]) -> Optional[str]",
          "docstring": "Resolve an include to a project header.",
          "methods": [],
          "line": 195
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/python.py": {
      "path": "parsers/python.py",
      "lang": "python",
      "lines": 366,
      "summary": "Python parser using stdlib ast module.",
      "interfaces": [
        {
          "name": "parse_python_file",
          "type": "function",
          "signature": "def parse_python_file(path: str) -> Dict[str, Any]",
          "docstring": "Parse Python file, extract interfaces and imports.",
          "methods": [],
          "line": 16
        },
        {
          "name": "_get_first_line",
          "type": "function",
          "signature": "def _get_first_line(docstring: Optional[str]) -> str",
          "docstring": "Extract first line of docstring.",
          "methods": [],
          "line": 116
        },
        {
          "name": "_get_name",
          "type": "function",
          "signature": "def _get_name(node: ast.expr) -> str",
          "docstring": "Get string name from AST node.",
          "methods": [],
          "line": 124
        },
        {
          "name": "_get_function_signature",
          "type": "function",
          "signature": "def _get_function_signature(node, is_async: bool) -> str",
          "docstring": "Extract function signature as string.",
          "methods": [],
          "line": 136
        },
        {
          "name": "_resolve_relative_import",
          "type": "function",
          "signature": "def _resolve_relative_import(module: str, level: int, current_module: str, project_modules: List[str]) -> Optional[str]",
          "docstring": "Resolve a relative import to a project module path.",
          "methods": [],
          "line": 190
        },
        {
          "name": "resolve_import_to_module",
          "type": "function",
          "signature": "def resolve_import_to_module(import_info: dict, project_modules: List[str], project_name: str, current_module: str) -> Optional[str]",
          "docstring": "Resolve an import to a project module path.",
          "methods": [],
          "line": 262
        },
        {
          "name": "classify_external_package",
          "type": "function",
          "signature": "def classify_external_package(import_info: dict) -> Optional[str]",
          "docstring": "Extract external package name from import.",
          "methods": [],
          "line": 349
        }
      ],
      "deps_internal": [],
      "deps_external": []
    },
    "parsers/__init__.py": {
      "path": "parsers/__init__.py",
      "lang": "python",
      "lines": 82,
      "summary": "Language-specific parsers for code analysis.",
      "interfaces": [
        {
          "name": "get_parser_for_file",
          "type": "function",
          "signature": "def get_parser_for_file(path: str)",
          "docstring": "Get appropriate parser function for a file path.",
          "methods": [],
          "line": 46
        },
        {
          "name": "detect_language",
          "type": "function",
          "signature": "def detect_language(path: str) -> str",
          "docstring": "Detect language from file extension.",
          "methods": [],
          "line": 65
        }
      ],
      "deps_internal": [
        "parsers/python.py",
        "parsers/rust.py",
        "parsers/mojo.py",
        "parsers/c.py",
        "parsers/dart.py"
      ],
      "deps_external": []
    }
  },
  "edges": [
    {
      "source": "storage.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "analyze.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "analyze.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "implement.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "implement.py",
      "target": "analyze.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "implement.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "memory.py",
      "target": "refs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "workflow.py",
      "target": "persona.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "parsers/python.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "parsers/rust.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "parsers/mojo.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "indexer.py",
      "target": "parsers/c.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "planner.py",
      "target": "specs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "ops.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "ops.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "ops.py",
      "target": "refs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "sync.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "sync.py",
      "target": "refs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "claudemd.py",
      "target": "workflow.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "claudemd.py",
      "target": "persona.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "claudemd.py",
      "target": "session_context.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "migration.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "migration.py",
      "target": "refs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "discuss.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "runner.py",
      "target": "planner.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "runner.py",
      "target": "runs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "context.py",
      "target": "ops.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "context.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "context.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "context.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "commands.py",
      "target": "workflow.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "commands.py",
      "target": "persona.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "quick.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "must_haves.py",
      "target": "agent/plan.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "session_context.py",
      "target": "commands.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "session_context.py",
      "target": "workflow.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "session_context.py",
      "target": "persona.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "__init__.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "__init__.py",
      "target": "persona.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "__init__.py",
      "target": "commands.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "__init__.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "__init__.py",
      "target": "workflow.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "ops.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "state.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "indexer.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/take.py",
      "target": "context.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/discuss.py",
      "target": "discovery.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/new.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/new.py",
      "target": "state.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "ops.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "state.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "graph.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/work.py",
      "target": "indexer.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/__init__.py",
      "target": "modes/work.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/__init__.py",
      "target": "modes/take.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/__init__.py",
      "target": "modes/new.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "modes/__init__.py",
      "target": "modes/discuss.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/run.py",
      "target": "spec.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/run.py",
      "target": "agent/plan.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/spec.py",
      "target": "spec.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/learner.py",
      "target": "refs.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/learner.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "spec.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "agent/learner.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "config.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "agent/run.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "agent/__init__.py",
      "target": "agent/plan.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/drift.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/goal.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/mode.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/mode.py",
      "target": "config.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/mode.py",
      "target": "memory.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/mode.py",
      "target": "indexer.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/plan_group.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/guards.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/guards.py",
      "target": "config.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/roadmap.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/explore.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/orchestration.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/persona_cmd.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/discuss.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/verify_group.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/modes.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/spec_group.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/analyze_cmd.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/cleanup.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/ui.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/knowledge.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/run_group.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/metadata.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/setup.py",
      "target": "registry.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/setup.py",
      "target": "config.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/setup.py",
      "target": "indexer.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/memory_group.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/decisions.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "cli_commands/transplant.py",
      "target": "cli_commands/guards.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "ui/server.py",
      "target": "ui/data.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "parsers/__init__.py",
      "target": "parsers/python.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "parsers/__init__.py",
      "target": "parsers/rust.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "parsers/__init__.py",
      "target": "parsers/mojo.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "parsers/__init__.py",
      "target": "parsers/c.py",
      "edge_type": "imports",
      "specifics": []
    },
    {
      "source": "parsers/__init__.py",
      "target": "parsers/dart.py",
      "edge_type": "imports",
      "specifics": []
    }
  ]
}