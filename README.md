# EriRPG

> *This README was generated by EriRPG. The developer was feeling lazy.* ğŸ˜

**Make Claude better at complex code changes.**

EriRPG gives Claude a structured workflow and persistent memory. You talk to Claude, Claude uses EriRPG internally to track specs, remember code, verify changes, and avoid mistakes.

## Why?

Without EriRPG, Claude:
- Re-reads the same files repeatedly (wastes tokens)
- Forgets decisions from earlier in the session
- Makes changes without verifying they work
- Gets confused on multi-step tasks

With EriRPG, Claude:
- Stores knowledge about modules and recalls it instantly
- Tracks decisions and context across sessions
- Verifies changes before marking complete
- Follows a structured workflow: discuss â†’ plan â†’ implement â†’ verify

## Setup (5 minutes)

```bash
# Install
pip install -e /path/to/eri-rpg

# Register your project
eri-rpg add myproject /path/to/project

# Install Claude Code integration
eri-rpg install
```

That's it. Now use Claude Code normally.

## Usage

Talk to Claude using slash commands:

| Command | What it does |
|---------|--------------|
| `/eri:start` | Begin a coding session |
| `/eri:execute "add auth"` | Execute a goal with full workflow |
| `/eri:quick file.py "fix bug"` | Quick single-file edit |
| `/eri:status` | Check current state |
| `/eri:recall auth` | Get Claude's stored knowledge |
| `/eri:resume` | Continue from last session |

### Example

```
You: /eri:start
You: Add retry logic to the API client

Claude: [Internally runs eri-rpg commands to:]
  - Check what it knows about the API client
  - Create a plan
  - Make edits with verification
  - Track the decision for future sessions
```

You describe what you want. Claude handles the workflow.

### Typical workflow

```
/eri:start myproject           # 1. Start session
/eri:discuss "add auth"        # 2. Clarify requirements
/eri:spec create auth          # 3. Lock down spec
/eri:research auth             # 4. Learn existing code
/eri:plan                      # 5. Create implementation plan
/eri:execute                   # 6. Implement with verification
/eri:done                      # 7. Mark complete
```

Or skip the ceremony for quick fixes:
```
/eri:quick myproject src/utils.py "fix off-by-one"
```

See [docs/TYPICAL_WORKFLOW.md](docs/TYPICAL_WORKFLOW.md) for details.

## Tiers

| Tier | What Claude can do |
|------|-------------------|
| **lite** | Quick fixes, search, cross-project queries |
| **standard** | + Discussion mode, goal clarification |
| **full** | + Full agent runs, specs, verification |

Default is `lite`. Upgrade with: `eri-rpg mode myproject --standard`

## Project management

These are the only CLI commands you need to run directly:

```bash
eri-rpg add <name> <path>    # Register a project
eri-rpg remove <name>        # Unregister
eri-rpg list                 # Show registered projects
eri-rpg install              # Set up Claude Code hooks
eri-rpg install-status       # Check installation
```

Everything else? Claude handles it.

## Status line

EriRPG adds a status line to Claude Code showing current context:

![Status Line](docs/images/status-line.png)

- **Persona** - Auto-detected from tool usage (see below)
- **Context %** - How much of the context window is used
- **Branch** - Current git branch
- **Tier** - lite/standard/full (âš¡ indicators)
- **Project** - Active EriRPG project

## Personas

EriRPG auto-detects what Claude is doing and sets a persona:

| Persona | Triggered by |
|---------|--------------|
| `analyzer` | Reading files, searching code |
| `backend` | Editing .py, .go, .rs files |
| `frontend` | Editing .jsx, .tsx, .vue, .css |
| `security` | Touching auth, crypto, security files |
| `qa` | Running tests |
| `devops` | Docker, kubectl, deploy commands |
| `scribe` | Editing docs, markdown, README |
| `refactorer` | Running linters, formatters |
| `architect` | Using Task tool for planning |

Set manually with `/eri:persona backend` or let it auto-detect.

## How it works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     slash commands      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   You   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Claude â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                                         â”‚
                                         â”‚ CLI calls
                                         â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚ EriRPG  â”‚
                                    â”‚   CLI   â”‚
                                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                                         â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                    â–¼                    â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Knowledgeâ”‚        â”‚  Specs   â”‚        â”‚  Verify  â”‚
              â”‚  Graph   â”‚        â”‚ & Plans  â”‚        â”‚  Tests   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

EriRPG stores:
- **Knowledge graph** - What Claude learned about your code
- **Specs & plans** - Goals broken into steps
- **Decisions** - Why Claude made certain choices
- **Run state** - Progress on multi-step tasks

This persists across sessions. Claude resumes where it left off.

## Language support

| Language | Support |
|----------|---------|
| Python | Full (AST-based) |
| Mojo | Full (regex) |
| Rust | Basic (regex) |
| C/C++ | Basic (regex) |
| Dart | Full (regex) |

## Requirements

- Python 3.10+
- Claude Code (CLI)

## Documentation

### Command references
- [docs/ERI-COMMANDS.md](docs/ERI-COMMANDS.md) - All 44 `/eri:*` commands (existing codebases)
- [docs/CODER-COMMANDS.md](docs/CODER-COMMANDS.md) - All 34 `/coder:*` commands (new projects)

### Guides
- [docs/CODER-USAGE.md](docs/CODER-USAGE.md) - Vibe coding guide (no code required)
- [docs/BLUEPRINT-BEHAVIOR.md](docs/BLUEPRINT-BEHAVIOR.md) - Cross-language feature porting
- [docs/MANUAL.md](docs/MANUAL.md) - Complete EriRPG reference
- [docs/TYPICAL_WORKFLOW.md](docs/TYPICAL_WORKFLOW.md) - Quick workflow guide

### Architecture
- [DESIGN.md](DESIGN.md) - Technical architecture
- [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) - System design

## Empowerment directive

EriRPG includes [EMPOWERMENT.md](EMPOWERMENT.md). It tells Claude to push back on bad ideas, ask "why" before executing "what", and explain reasoning so you learn â€” not just get code dumped on you.

Based on: [Who's in Charge? Disempowerment Patterns in Real-World LLM Usage](https://arxiv.org/abs/2601.19062) (Sharma et al., 2026)

The short version: users rate sycophantic AI responses higher but are worse off for receiving them. EriRPG optimizes for your growth, not your approval.

## Blueprint & behavior: cross-language feature porting

EriRPG can document programs as behavior specs and port features across languages.

### The problem

You have a Python ML training feature. You want to port it to Rust. Copy-pasting doesn't work â€” different idioms, different memory models.

### The solution

Extract what it does (behavior), not how it's coded. Then implement the behavior in the target's style.

```bash
# 1. Create behavior spec from source
/coder:blueprint add onetrainer models/sana "Sana model" --extract-tests

# 2. Add feature to target using source behavior
/coder:add-feature eritrainer sana "Sana model" --reference onetrainer/models/sana

# 3. Verify implementation matches spec
/coder:verify-behavior eritrainer/sana
```

### What gets extracted

| Section | Purpose |
|---------|---------|
| **Interface Contract** | Input/output types, method signatures |
| **Global State Impact** | Env vars, files, threads, network |
| **Ownership Model** | Borrow/move/clone semantics for Rust |
| **Resource Budget** | Memory, time, constraints |
| **State Machine** | States, transitions, valid actions |
| **Test Contracts** | Given/When/Then from source tests |

### What gets checked

When you run `add-feature --reference`:
- âœ… Scans target for interface requirements (traits, wrappers)
- âœ… Checks ownership compatibility
- âœ… Checks side effect compatibility
- âŒ Reports violations you must fix
- âš ï¸ Flags items needing manual review

### Verification table

After implementation, `verify-behavior` generates:

```
| Behavior Spec           | Code Check              | Status |
|-------------------------|-------------------------|--------|
| Input: Dataset          | fn new(dataset: &Dataset)| âœ…     |
| State: Idleâ†’Loading     | Found state enum        | âœ…     |
| No global mutations     | No static mut           | âœ…     |
| Resource: <24GB VRAM    | No check possible       | âš ï¸ Manual |
```

**Guides:**
- [docs/BLUEPRINT-BEHAVIOR.md](docs/BLUEPRINT-BEHAVIOR.md) - Complete blueprint & behavior reference

---

## Eri-Coder: vibe code new projects

Eri-coder builds new projects from scratch. You describe what you want, it does the rest.

```bash
/coder:new-project my-app "A task management app"
```

This runs an 8-phase workflow:
1. **Setup** - Project initialization
2. **Brownfield** - Detect existing code
3. **Questioning** - Deep requirements gathering
4. **PROJECT.md** - Vision documentation
5. **Preferences** - YOLO or interactive mode
6. **Research** - 4 parallel agents research stack, features, architecture, pitfalls
7. **Requirements** - Generate REQ-IDs
8. **Roadmap** - Create phased implementation plan

Then execute phase by phase:
```bash
/coder:plan-phase 1
/coder:execute-phase 1
/coder:verify-work 1
```

We built a Rust chat app (995 lines, egui UI, SQLite, streaming API) in one session with this: [rust-llm-chat-interface](https://github.com/CodeAlexx/rust-llm-chat-interface)

![Parallel Research Agents](https://raw.githubusercontent.com/CodeAlexx/rust-llm-chat-interface/main/docs/screenshot-agents.png)

**Guides:**
- [docs/CODER-USAGE.md](docs/CODER-USAGE.md) - No-code guide for non-programmers
- [docs/CODER-COMMANDS.md](docs/CODER-COMMANDS.md) - All 34 commands with detailed usage

## Status

Alpha v0.57 - usable but evolving.

### Working
- Knowledge storage and recall
- Cross-project search (<1ms queries)
- Quick fix mode, discussion mode
- Run tracking with decisions
- Claude Code hooks
- Session context persistence (SQLite)
- Automatic git branch tracking
- Eri-Coder vibe coding workflow
- Blueprint system (program documentation)
- Behavior extraction and verification (cross-language porting)

### In progress
- Multi-agent parallel execution

## License

MIT
