# EriRPG

> *This README was generated by EriRPG. The developer was feeling lazy.* üòè

**Make Claude better at complex code changes.**

EriRPG gives Claude a structured workflow and persistent memory. You talk to Claude, Claude uses EriRPG internally to track specs, remember code, verify changes, and avoid mistakes.

## Why?

Without EriRPG, Claude:
- Re-reads the same files repeatedly (wastes tokens)
- Forgets decisions from earlier in the session
- Makes changes without verifying they work
- Gets confused on multi-step tasks

With EriRPG, Claude:
- Stores knowledge about modules and recalls it instantly
- Tracks decisions and context across sessions
- Verifies changes before marking complete
- Follows a structured workflow: discuss ‚Üí plan ‚Üí implement ‚Üí verify

## Setup (5 minutes)

```bash
# Install
pip install -e /path/to/eri-rpg

# Register your project
eri-rpg add myproject /path/to/project

# Install Claude Code integration
eri-rpg install
```

That's it. Now use Claude Code normally.

## Usage

Talk to Claude using slash commands:

| Command | What it does |
|---------|--------------|
| `/eri:start` | Begin a coding session |
| `/eri:execute "add auth"` | Execute a goal with full workflow |
| `/eri:quick file.py "fix bug"` | Quick single-file edit |
| `/eri:status` | Check current state |
| `/eri:recall auth` | Get Claude's stored knowledge |
| `/eri:resume` | Continue from last session |

### Example

```
You: /eri:start
You: Add retry logic to the API client

Claude: [Internally runs eri-rpg commands to:]
  - Check what it knows about the API client
  - Create a plan
  - Make edits with verification
  - Track the decision for future sessions
```

You describe what you want. Claude handles the workflow.

### Typical Workflow

```
/eri:start myproject           # 1. Start session
/eri:discuss "add auth"        # 2. Clarify requirements
/eri:spec create auth          # 3. Lock down spec
/eri:research auth             # 4. Learn existing code
/eri:plan                      # 5. Create implementation plan
/eri:execute                   # 6. Implement with verification
/eri:done                      # 7. Mark complete
```

Or skip the ceremony for quick fixes:
```
/eri:quick myproject src/utils.py "fix off-by-one"
```

See [docs/TYPICAL_WORKFLOW.md](docs/TYPICAL_WORKFLOW.md) for details.

## Tiers

| Tier | What Claude can do |
|------|-------------------|
| **lite** | Quick fixes, search, cross-project queries |
| **standard** | + Discussion mode, goal clarification |
| **full** | + Full agent runs, specs, verification |

Default is `lite`. Upgrade with: `eri-rpg mode myproject --standard`

## Project Management

These are the only CLI commands you need to run directly:

```bash
eri-rpg add <name> <path>    # Register a project
eri-rpg remove <name>        # Unregister
eri-rpg list                 # Show registered projects
eri-rpg install              # Set up Claude Code hooks
eri-rpg install-status       # Check installation
```

Everything else? Claude handles it.

## Status Line

EriRPG adds a status line to Claude Code showing current context:

![Status Line](docs/images/status-line.png)

- **Persona** - Auto-detected from tool usage (see below)
- **Context %** - How much of the context window is used
- **Branch** - Current git branch
- **Tier** - lite/standard/full (‚ö° indicators)
- **Project** - Active EriRPG project

## Personas

EriRPG auto-detects what Claude is doing and sets a persona:

| Persona | Triggered by |
|---------|--------------|
| `analyzer` | Reading files, searching code |
| `backend` | Editing .py, .go, .rs files |
| `frontend` | Editing .jsx, .tsx, .vue, .css |
| `security` | Touching auth, crypto, security files |
| `qa` | Running tests |
| `devops` | Docker, kubectl, deploy commands |
| `scribe` | Editing docs, markdown, README |
| `refactorer` | Running linters, formatters |
| `architect` | Using Task tool for planning |

Set manually with `/eri:persona backend` or let it auto-detect.

## How It Works

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     slash commands      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   You   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Claude ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                         ‚îÇ
                                         ‚îÇ CLI calls
                                         ‚ñº
                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îÇ EriRPG  ‚îÇ
                                    ‚îÇ   CLI   ‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                         ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚ñº                    ‚ñº                    ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ Knowledge‚îÇ        ‚îÇ  Specs   ‚îÇ        ‚îÇ  Verify  ‚îÇ
              ‚îÇ  Graph   ‚îÇ        ‚îÇ & Plans  ‚îÇ        ‚îÇ  Tests   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

EriRPG stores:
- **Knowledge graph** - What Claude learned about your code
- **Specs & plans** - Goals broken into steps
- **Decisions** - Why Claude made certain choices
- **Run state** - Progress on multi-step tasks

This persists across sessions. Claude resumes where it left off.

## Language Support

| Language | Support |
|----------|---------|
| Python | Full (AST-based) |
| Mojo | Full (regex) |
| Rust | Basic (regex) |
| C/C++ | Basic (regex) |
| Dart | Full (regex) |

## Requirements

- Python 3.10+
- Claude Code (CLI)

## Documentation

### Command References
- [docs/ERI-COMMANDS.md](docs/ERI-COMMANDS.md) - All 44 `/eri:*` commands (existing codebases)
- [docs/CODER-COMMANDS.md](docs/CODER-COMMANDS.md) - All 34 `/coder:*` commands (new projects)

### Guides
- [docs/CODER-USAGE.md](docs/CODER-USAGE.md) - Vibe coding guide (no code required)
- [docs/BLUEPRINT-BEHAVIOR.md](docs/BLUEPRINT-BEHAVIOR.md) - Cross-language feature porting
- [docs/MANUAL.md](docs/MANUAL.md) - Complete EriRPG reference
- [docs/TYPICAL_WORKFLOW.md](docs/TYPICAL_WORKFLOW.md) - Quick workflow guide

### Architecture
- [DESIGN.md](DESIGN.md) - Technical architecture
- [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) - System design

## Empowerment Directive

EriRPG includes [EMPOWERMENT.md](EMPOWERMENT.md) - a mandatory behavior directive based on research showing AI assistants can inadvertently undermine user autonomy and skill development.

**The core principle:** Make the developer better, not unnecessary.

This means Claude will:
- **Challenge before compliance** - Push back on bad ideas before implementing
- **Require intent** - Ask "why" before blindly executing "what"
- **Flag autonomy transfers** - Enumerate significant decisions before making them
- **Preserve skills** - Explain reasoning so you can do it yourself next time
- **No sycophancy** - Honest feedback over empty validation

Based on: [Who's in Charge? Disempowerment Patterns in Real-World LLM Usage](https://arxiv.org/abs/2601.19062) (Sharma et al., 2026)

> "Interactions with greater disempowerment potential receive higher user approval ratings, possibly suggesting a tension between short-term user preferences and long-term human empowerment."

EriRPG optimizes for your growth, not your approval.

## Blueprint & Behavior: Cross-Language Feature Porting

EriRPG includes a **blueprint system** for documenting complex programs and a **behavior extraction** system for porting features across languages.

### The Problem

You have a Python ML training feature. You want to port it to Rust. Copy-pasting doesn't work - different idioms, different patterns, different memory models.

### The Solution

Extract **WHAT** it does (behavior), not **HOW** it's coded. Then implement the behavior in the target's style.

```bash
# 1. Create behavior spec from source
/coder:blueprint add onetrainer models/sana "Sana model" --extract-tests

# 2. Add feature to target using source behavior
/coder:add-feature eritrainer sana "Sana model" --reference onetrainer/models/sana

# 3. Verify implementation matches spec
/coder:verify-behavior eritrainer/sana
```

### What Gets Extracted

| Section | Purpose |
|---------|---------|
| **Interface Contract** | Input/output types, method signatures |
| **Global State Impact** | Env vars, files, threads, network |
| **Ownership Model** | Borrow/move/clone semantics for Rust |
| **Resource Budget** | Memory, time, constraints |
| **State Machine** | States, transitions, valid actions |
| **Test Contracts** | Given/When/Then from source tests |

### What Gets Checked

When you run `add-feature --reference`:
- ‚úÖ Scans target for interface requirements (traits, wrappers)
- ‚úÖ Checks ownership compatibility
- ‚úÖ Checks side effect compatibility
- ‚ùå Reports violations you must fix
- ‚ö†Ô∏è Flags items needing manual review

### Verification Table

After implementation, `verify-behavior` generates:

```
| Behavior Spec           | Code Check              | Status |
|-------------------------|-------------------------|--------|
| Input: Dataset          | fn new(dataset: &Dataset)| ‚úÖ     |
| State: Idle‚ÜíLoading     | Found state enum        | ‚úÖ     |
| No global mutations     | No static mut           | ‚úÖ     |
| Resource: <24GB VRAM    | No check possible       | ‚ö†Ô∏è Manual |
```

**Guides:**
- [docs/BLUEPRINT-BEHAVIOR.md](docs/BLUEPRINT-BEHAVIOR.md) - Complete blueprint & behavior reference

---

## Eri-Coder: Vibe Code New Projects

EriRPG includes **eri-coder** - a workflow for building new projects from scratch without writing code yourself.

```bash
/coder:new-project my-app "A task management app"
```

This runs an 8-phase workflow:
1. **Setup** - Project initialization
2. **Brownfield** - Detect existing code
3. **Questioning** - Deep requirements gathering
4. **PROJECT.md** - Vision documentation
5. **Preferences** - YOLO or interactive mode
6. **Research** - 4 parallel agents research stack, features, architecture, pitfalls
7. **Requirements** - Generate REQ-IDs
8. **Roadmap** - Create phased implementation plan

Then execute phase by phase:
```bash
/coder:plan-phase 1
/coder:execute-phase 1
/coder:verify-work 1
```

**Real Example:** We built a complete Rust chat application (995 lines, egui UI, SQLite, streaming API) in one session using this workflow. See: [rust-llm-chat-interface](https://github.com/CodeAlexx/rust-llm-chat-interface)

![Parallel Research Agents](https://raw.githubusercontent.com/CodeAlexx/rust-llm-chat-interface/main/docs/screenshot-agents.png)

**Guides:**
- [docs/CODER-USAGE.md](docs/CODER-USAGE.md) - No-code guide for non-programmers
- [docs/CODER-COMMANDS.md](docs/CODER-COMMANDS.md) - All 34 commands with detailed usage

## Status

Alpha v0.57 - usable but evolving.

### Working
- ‚úÖ Knowledge storage and recall
- ‚úÖ Cross-project search (<1ms queries)
- ‚úÖ Quick fix mode
- ‚úÖ Discussion mode
- ‚úÖ Run tracking with decisions
- ‚úÖ Claude Code hooks
- ‚úÖ Session context persistence (SQLite)
- ‚úÖ Automatic git branch tracking
- ‚úÖ **Eri-Coder vibe coding workflow**
- ‚úÖ **Blueprint system** (program documentation)
- ‚úÖ **Behavior extraction** (cross-language porting)
- ‚úÖ **Behavior verification** (implementation validation)

### In Progress
- ‚ö†Ô∏è Multi-agent parallel execution

## License

MIT
