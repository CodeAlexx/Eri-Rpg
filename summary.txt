EriRPG Basis Review (Read-Only Findings)

Goal context:
- Targeting a full spec-driven runner, better than GSD.
- Current codebase is a strong foundation for indexing/context, but not yet a spec runner.

Strengths (good foundation):
- Clean separation: graph/indexer/ops/context/knowledge/modes.
- Graph + learnings + context pipeline is a solid retrieval base.
- CLI flows are clear and predictable.

High-risk gaps to fix first:
1) Wrong source mapping in transplant plans
   - plan_transplant uses feature.components[0] as source for all mappings.
   - components is topo-sorted; first item is often a dependency, not the main module.
   - Result: plans and context can point to the wrong source module.
   - File: erirpg/ops.py:358

2) Relative imports ignored
   - resolve_import_to_module returns None for relative imports, so internal deps are missed.
   - This breaks extraction/impact accuracy for most real Python codebases.
   - Files: erirpg/parsers/python.py:227, erirpg/indexer.py:134

Structural mismatches / reliability gaps:
- TS/Go exposed in CLI/new mode, but indexer only supports python/c/rust.
  Files: erirpg/cli.py:52, erirpg/modes/new.py:75, erirpg/indexer.py:76
- Decisions/history are logged to state but never stored in graph knowledge.
  Work mode expects decisions/patterns from graph, so views are empty.
  Files: erirpg/cli.py:1006, erirpg/cli.py:1083, erirpg/modes/work.py:122
- New mode sets phase="building" but state machine doesn’t handle it.
  Files: erirpg/modes/new.py:651, erirpg/state.py:61
- Context code fences are always python, even for C/Rust.
  Files: erirpg/context.py:96, erirpg/modes/work.py:277
- No tests present despite pytest config.
  File: pyproject.toml:64

Long-term memory assessment:
- Graph is a structural snapshot; useful for retrieval but not memory.
- Learnings are true “memory,” but stored inside graph.json.
- Reindexing rebuilds the graph and can drop learnings (no merge step).
- Feature files are snapshots without staleness detection.
- State/history is transient, not durable knowledge.

Verdict:
- Solid base for a spec-driven system, but currently closer to a context/index helper.
- To become a full spec runner (better than GSD), focus on correctness, memory durability,
  and orchestration depth (spec -> plan -> execute -> verify loop).

Recommended priorities (minimal to unlock reliability):
1) Preserve/merge knowledge across reindex (or store knowledge separately).
2) Track file hash/mtime and mark learnings stale when code changes.
3) Fix mapping provenance in plan_transplant (track true primary module per interface).
4) Implement relative-import resolution (use file context).
5) Align language support: either add TS/Go indexing or hide in CLI.
6) Add tests around index/graph/extract/plan/context.

If you want, I can draft a concrete roadmap or design a spec-runner core on top of this.
